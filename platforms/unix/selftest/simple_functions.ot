/* -*- Mode: c++; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */

group "unix simple functions";

require UNIX;

include "platforms/unix/selftest/simple_functions.h";


subtest test_parse_a_pointer(const char * s, void * p)
{
	if (parse_pointer(s) != p)
	{
		char msg[100];
		snprintf(msg, 100, "parse_pointer(%s) returned %p instead of %p\n", s, parse_pointer(s), p);
		verify_string(msg, "SUCCESS");
	}
}

subtest test_parse_a_pointer(void * p)
{
	/* It is expected that the input to parse_pointer will be
	 * generated by sprintf("%#lx").  So this code tests that the
	 * roundtrip conversion ends up with the original pointer.
	 */
	char s[100];
	snprintf(s, 100, "%#lx", static_cast<unsigned long>(reinterpret_cast<UINTPTR>(p)));
	if (parse_pointer(s) != p)
	{
		char msg[100];
		snprintf(msg, 100, "parse_pointer(%p -> %s) returned %p instead of %p\n", p, s, parse_pointer(s), p);
		verify_string(msg, "SUCCESS");
	}
}

subtest test_parse_a_pointer_error(const char * s, bool require_assert)
{
	/* Automatic testing should not trigger unexpected assertions, but
	 * the selftest infrastructure does not currently allow testing
	 * for expected assertions.  See "parse_pointer: enable aserting
	 * tests" below.
	 */
	char msg[100];
	void * p;
	bool failed = false;
#ifdef SELFTEST_SUPPORTS_TESTING_FOR_ASSERTIONS
	CATCH_ASSERT(assertion, p = parse_pointer(s));
	if (require_assert && !assertion)
	{
		failed = true;
		snprintf(msg, 100, "parse_pointer(%s) did not raise an assertion\n", s);
	}
#else
	p = parse_pointer(s);
#endif
	if (p)
	{
		failed = true;
		snprintf(msg, 100, "parse_pointer(%s) returned %p instead of NULL\n", s, parse_pointer(s));
	}
	if (failed)
		verify_string(msg, "SUCCESS");
}


/* Automatic testing should not trigger unexpected assertions, but the
 * selftest infrastructure does not currently allow testing for
 * expected assertions.
 *
 * Thus, all (potentially) asserting tests are set to depend on this
 * test, so to enable them (and live with the resulting assertions),
 * just enable this test.
 */
test("parse_pointer: enable asserting tests") disabled;
{
}
test("parse_pointer(NULL)")
{
	test_parse_a_pointer(NULL);
}
test("parse_pointer(1)")
{
	test_parse_a_pointer((void*)1);
}
test("parse_pointer(&local)")
{
	char p;
	test_parse_a_pointer(&p);
}
test("parse_pointer(maxptr)")
{
	test_parse_a_pointer((void*)((UINTPTR)-1));
}
test("parse_pointer(\"0\")")
{
	test_parse_a_pointer("0", NULL);
}
test("parse_pointer(\"0x0\")")
{
	test_parse_a_pointer("0x0", NULL);
}
test("parse_pointer(\"\")") require success "parse_pointer: enable asserting tests";
{
	/* As a special case, I don't particularly care whether the empty
	 * string is parsed as a NULL pointer or considered an invalid
	 * pointer value.  Both cases return NULL, but the second would
	 * also raise an assertion.
	 */
	test_parse_a_pointer_error("", false);
}
test("parse_pointer(\"12\")") require success "parse_pointer: enable asserting tests";
{
	test_parse_a_pointer_error("12", true);
}
test("parse_pointer(\"0x12x\")") require success "parse_pointer: enable asserting tests";
{
	test_parse_a_pointer_error("0x12x", true);
}
test("parse_pointer(\"-12\")") require success "parse_pointer: enable asserting tests";
{
	test_parse_a_pointer_error("-12", true);
}
test("parse_pointer(maxptr + \"0\")") require success "parse_pointer: enable asserting tests";
{
	char s[100];
	int slen = snprintf(s, 90, "%#lx", (unsigned long)(UINTPTR)(void*)((UINTPTR)-1));
	test_parse_a_pointer(s, (void*)((UINTPTR)-1));
	s[slen] = '0';
	s[slen+1] = 0;
	test_parse_a_pointer_error(s, true);
}
