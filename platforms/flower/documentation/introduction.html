<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Flower: Introduction</title>
<link rel="stylesheet" href="doc.css"/>
</head>
<body>
<h1>Flower: Introduction</h1>
<p><strong>Flower</strong> is a build tool designed to replace GNU make for building Opera products on UNIX-like systems. Flower is written in Python and included in the Opera source tree, so no installation is required.</p>
<h2 id="why">Why Flower?</h2>
<p>There are several issues with GNU make that make it unsuitable for Opera. These issues can be worked around more or less successfully, as demonstrated by the existence of the <code>unix-build</code> and <code>minimake</code> modules. However, having the right tool for the job is better than forcing the wrong one to do it. The high complexity and maintenance costs of <code>unix-build</code> demonstrate that, and although <code>minimake</code> is clearly a step in the right direction, it's still restricted by the limitations of GNU make.</p>
<dl>
  <dt>Make builds the full dependency graph before it starts building.</dt>
  <dd>This is the biggest and most fundamental limitation of make. Also, pretty much every alternative build tool mirrors this design decision.</dd>
  <dd>Make operates in two phases. First, it parses the makefiles and builds a graph of all targets describing how they depend on each other; second, it traverses the graph, executing commands on the way to update the targets. This is true even though make has some ways to express generic rules, such as pattern rules. In Opera products, we have certain parts of the dependency tree unknown until some setup steps have run. For example, the list of all source files is produced by a hardcore setup step.</dd>
  <dd>One possible solution to this is to run all such steps during parsing of the makefiles (first phase), which is slow because it's not always necessary, and ugly because we can't use make's dependency engine to express when they need to be run and when they don't. Another approach is to invoke make recursively after executing the setup steps (this is the approach taken by <code>minimake</code>). This is somewhat nicer because unnecessary invocations of the setup steps can be spared, but still a workaround with unnecessary complexity which could be avoided if we didn't have to fight make's architecture.</dd>
  <dd>Flower solves this by not requiring the entire dependency graph to be known before it begins traversing it. Instead, a node references and brings to life its dependencies when asked to build itself.</dd>
  <dt>Make's configuration system is a flat namespace of string variables.</dt>
  <dd>There are no lists, dictionaries or even boolean values. As a result, all we can do with those variables is string manipulations, which are often difficult to read and write, and are picked out of make's quite limited set of operations.</dd>
  <dd>Flower's configuration system is hierarchical and can use all data types available in Python, so that strings don't have to be abused for expressing structured information.</dd>
  <dt>Make's output log is difficult to read.</dt>
  <dd>Make doesn't really have proper logging; it just lets the commands it runs write directly to the standard output and standard error, and optionally echoes each command before invoking it. When running many commands in parallel, this results in an unreadable mess.</dd>
  <dd>Flower has an extensible logging facility that captures and reorders the output of individual commands so that it doesn't intermix during parallel execution.</dd>
  <dt>One has to read the makefiles to figure out how to invoke make for the desired result.</dt>
  <dd>Sophisticated makefiles contain hundreds of targets and configuration variables, some of which are internal and some meant to be invoked or configured by the end user wishing to build the project. Well-documented makefiles help to a certain point.</dd>
  <dd>In Flower, goals and options exposed to the end user are explicitly declared as such, and become part of the self-documented command line syntax. Invoking Flower with <code>--help</code> generates a description of all such goals and options dynamically.</dd>
</dl>
<p>Flower contains two major subsystems that can be described separately: the <em>flow subsystem</em> and the <em>configuration subsystem</em>.</p>
<h2 id="flow-subsystem">Flow subsystem</h2>
<p>This is what roughly corresponds to the target and dependency system of GNU make.</p>
<h3 id="nodes-and-flows">Nodes and flows</h3>
<p>Flower operates on <strong id="node">nodes</strong> that can be thought of as relatives of targets in GNU make. A node is an abstract entity that does not necessarily correspond to a file. Every node is associated with an algorithm (a piece of Python code) that describes how to <em>make</em> it; this algorithm is called a <strong id="flow">flow</strong>. This notion gave Flower its name.</p>
<p>One flow can be associated with a single unique node, but more commonly it's associated with a family of similar nodes. For example, there are many similar nodes sharing the same flow that compiles a source file into an object file; the only difference between them is the actual source (and therefore also target) file the flow operates on. Such a flow is written once and used for many similar nodes, somewhat like when a class in an object-oriented programming language is written once and then instantiated many times.</p>
<p>Flower looks for flows in every module listed in a <code>readme.txt</code> file. Any module can contain a <code>module.build</code> directory at its top level. Flower looks for <strong id="flow-file">flow files</strong> named <code>flow.py</code> or <code>*.flow.py</code> in these directories. They are essentially Python source code and are all read as if they were was one long Python module. The order in which flows are defined doesn't matter. There is just one flat namespace for all flows.</p>
<h3 id="example-flow">A close look at a flow</h3>
<p>Here is an example of a flow that compiles a source file. (The actual <code>compileSource</code> flow is a little more complex.)</p>
<pre>@flow
def compileSource(self, source):
    self['target'] = config.targetPlatform.compiler.target
    yield sourceSetup()
    if self &lt; (util.readDepFile(config.targetPlatform.compiler.depFile) or [source]):
        util.makeDirs(self)
        yield command(config.targetPlatform.compiler.compileCommand, "Compiling %(source)s")</pre>
<p>A flow is essentially a Python function wrapped in the <code><a href="reference.html#flow">@flow</a></code> decorator that adds a bit of magic around it. The first formal argument of the flow is always <code>self</code> which will refer to the <a href="reference.html#Node">node object</a> when the flow runs. The remaining formal arguments are keyword arguments that distinguish one such node from all other nodes using the same flow. In this case, the flow is used once per source file, and the name of that source file is the parameter that makes it possible to identify the exact node. If another flow was to refer to a particular node using this flow, it would use an expression like <code>compileSource(source='dir/file.cpp')</code>. Note the absence of the <code>self</code> argument here: it will be supplied by the decorator when it instantiates the node.</p>
<p>The <code>source</code> argument in the flow above is a <strong id="node-parameter">node parameter</strong>. Every node has a dictionary of such parameters. They are available through the array subscript syntax on the node object, as demonstrated by the first line of the flow above: it adds a node parameter <code>target</code>, which by convention is used to store the name of the output or timestamp file produced by the flow. A node is not required to have a target.</p>
<p>The call to <code><a href="reference.html#makeDirs">util.makeDirs</a></code> makes sure that the destination directory is created before running the compiler (again, the <code>target</code> node parameter is used to determine the location of the output file).</p>
<p>The long dotted expressions starting with <code>config</code> are queries into the configuration subsystem, which has the next section dedicated to it. The configuration system knows which node is querying it, and tailors its answers to the particular node based on its node parameters. For example, the <code>config.targetPlatform.compiler.target</code> expression returns the name of the object file that will be produced by compiling the source file, according to the naming conventions used by the particular compiler on the particular platform (with typical UNIX C/C++ compilers, this means taking the <code>source</code> node parameter and replacing the filename suffix with <code>.o</code>).</p>
<h3 id="depending">Depending on other nodes</h3>
<p>Flows typically depend on other nodes' flows having completed. For example, the <code>compileSource</code> flow requires that the <code>sourceSetup()</code> node has completed. If not for the parallelism, flows could have called each other as ordinary functions, but Flower supports parallel execution, so it requires that flows yield execution (they are technically Python generators) instead of calling other flows. This is what the flow above does: it yields a the <code>sourceSetup()</code> node. A yield statement in a flow can pass a single node or a sequence of nodes (a sequence is any container that has a length and is indexable, such as a list or a tuple).</p>
<p>To get a reference to a node you want made, you invoke its flow as a function. Doing so does not in itself cause the flow to be executed. In our example, <code>sourceSetup</code> is a flow corresponding to one unique node, that's why it's called with no arguments; if it was a flow that's used for many nodes, keyword arguments would have to be specified, narrowing it down to a single node. If you evaluate such an expression several times, you'll get references to the same object every time, because a node with a particular flow and each particular combination of node parameters is unique.</p>
<p>A <code><a href="reference.html#yield">yield</a></code> statement in the body of a flow with one or more references to other nodes means that the execution of this flow should be suspended until each of these nodes completes its flow. By the time such a statement is reached, some of the nodes listed might be already made, some might be in progress because of the parallelism, and some might not yet be started upon. The current flow will be suspended, and other flows will be scheduled for execution. The Python code itself is not multi-threaded; flows only multitask by yielding, which allows the scheduler to let a different flow start or continue.</p>
<h3 id="needs-update">Checking if the target needs updating</h3>
<p>Next, the flow checks if the target file is older than the files used to produce it. The <code>source</code> is obviously one such file. The <code><a href="reference.html#readDepFile">util.readDepFile</a></code> function is used to parse a <code>.d</code> file produced by the compiler as a side effect (e.g. enabled with gcc's <code>-MMD</code> flag), if one already exists, and returns a list of dependencies mentioned in it. Obviously, this list includes <code>source</code>. If the <code>.d</code> file does not exist, or <code>None</code> is passed instead of its name, the function returns an empty list, and <code>[source]</code> is used as fallback. (Note that parentheses are necessary to enforce the desired evaluation order.) There is no need to run any dependency generation in advance: if a <code>.d</code> file does not exist, this means the file hasn't been compiled before, and the target won't exist either, forcing the remake.</p>
<p>The comparison <code>self &lt; deps</code> uses the overloaded <a href="reference.html#Node-__lt__">&lt; operator</a> of the node object. The operator should be read as <em>older than</em> in this context. On the right-hand side, it accepts a single filename or node or a sequence of those, and returns true if the target needs to be remade. For the node on the left-hand side and for any nodes listed on the right-hand side, the operator uses the <code>target</code> node parameter as the name of the file whose modification time to use. Absent target file forces a remake, and so does an absent dependency.</p>
<h3 id="invoking-commands">Invoking a command</h3>
<p>Finally, another <code>yield</code> statement is executed, this time with a <code><a href="reference.html#Command">command</a></code> object. This means that the current flow is to be suspended, and the command should be scheduled for execution. It might not be started right away because of the configured limit on the number of processes to run in parallel. When the command completes, the current flow will be resumed (in our case, only to succeed immediately). The scheduler might let other flows run while the current flow is blocked on a command object.</p>
<p>The first argument of the <code>command</code> constructor is a list of words making up the command. In this case, the configuration system supplies the compiler command, which can be quite long, but if we were to hardcode a minimal gcc invocation here, it would look like this: <code>yield command(['g++', '-c', source, '-o', self['target'], '-MMD'], "Compiling %(source)s")</code>. The command is invoked directly without using the shell, so you don't have to escape any special characters, for example, in filenames. The optional second argument to the constructor is the progress message that should appear in the output describing what's being done. Named substitutions in it can refer to the parameters of the current node. If the command fails to start or returns a non-zero exit code, the flow does not continue, and the whole build fails (this behavior can be overridden for a particular command object, if necessary).</p>
<h3 id="node-id">How nodes are identified</h3>
<p>Note how the name of the flow is a verb phrase rather than a noun phrase referring to the output file, such as <code>objectFile</code>. Unlike GNU make, in Flower the node is primary, and the file it creates or updates is secondary (and doesn't always exist). The whole build process is a flow invoking other flows invoking other flows, each of which accomplishes something like compiling a source file or linking a binary. Also, note that among all the nodes using this flow, a particular one is identified using the source file name rather than the output file name. This is an arbitrary design decision made for this particular flow, in this case because when we think of a build step such as <em>compiling a source file</em>, what we really care about is which source file we are compiling, not where the output is written. It also makes it simpler to refer to all such nodes after reading a list of all source files to be compiled. Here is another simplified example that produces the Opera binary file:</p>
<pre>@flow
def linkBinary(self):
    self['target'] = config.binaryTarget
    scan = scanSources()
    yield scan
    sources = [compileSource(source=s) for s in scan['sources']]
    yield sources
    if self &lt; sources:
        util.makeDirs(self)
        yield command(config.targetPlatform.linker.linkCommand, "Linking %(target)s")</pre>
<p>This example assumes that only one binary is ever produced, so the <code>linkBinary</code> flow does not expect any node parameters. The real <code>linkBinary</code> flow takes a <code>binary</code> parameter which specifies which binary we are building (<code>opera</code>, <code>operapluginwrapper-native</code> etc).</p>
<p>First, a <code>scanSources()</code> node is brought up to date. Its flow makes sure that all necessary hardcore scripts have been run that produce the source list, and then reads the list and makes it available as the <code>sources</code> node parameter on itself. Then, we use a list comprehension (Python FTW) to build a list of nodes for compiling each of the source files. We yield on the list, making sure all the source files are compiled before the next line of our flow is reached. Then, we reuse the <code>sources</code> list to check if any of the object files are newer than the binary (remember that for each node in the list, its <code>target</code> node parameter is used). The linker command is again supplied by the configuration system, but if we were to hardcode it, it might have looked like this: <code>yield command(['g++', '-o', self['target']] + [s['target'] for s in sources], "Linking %(target)s")</code>. (In practice, such linker commands can grow too long, so the actual <code>linkBinary</code> flow writes the list of object files into a text file and refers to that using the <code>@</code> character on the command line.)</p>
<h3 id="flow-variant">Flow variants</h3>
<p>There is a <strong id="pattern-matching">pattern-matching</strong> system for flows that allows one of several <strong>flow variants</strong> to be selected based on the specified node parameters. For example, there may be one way to compile C files and another to compile C++ files. In most places outside the <code>compileSource</code> flow we don't care, so we'd like the expressions <code>compileSource(source='file1.c')</code> and <code>compileSource(source='file2.cpp')</code> to select the right flow variant automatically. This can be accomplished by providing more than one flow with the same name and specifying some matching patterns as arguments to the <code>@flow</code> decorator:</p>
<pre>@flow(source=util.hasSuffix('.c'))
def compileSource(self, source):
    # Compile a C source file...

@flow(source=util.hasSuffix('.cpp'))
def compileSource(self, source):
    # Compile a C++ source file...</pre>
<p>Here, <code><a href="reference.html#hasSuffix">util.hasSuffix</a></code> is a handy matcher that checks if a string has the specified suffix. A constant string, a compiled regular expression object, or a function returning a boolean-like value can be used as a matcher; see the reference manual for details. The right flow variant will be selected automatically. The order of declaration doesn't matter. No match or more than one match is a runtime error.</p>
<p>In the example above, most of the code in both flow variants would be the same. To avoid duplication, flow variants can be <strong id="chaining">chained</strong>. In the example below, both flow variants set some node parameters on <code>self</code> and chain to the common flow variant containing the shared code, which then uses those parameters.</p>
<pre>@flow(1, source=util.hasSuffix('.c'))
def compileSource(self):
    self['stem'] = util.removeSuffix(source, '.c')
    self['lang'] = 'c'
    yield self

@flow(1, source=util.hasSuffix('.cpp'))
def compileSource(self):
    self['stem'] = util.removeSuffix(source, '.cpp')
    self['lang'] = 'c++'
    yield self

@flow
def compileSource(self, source):
    # Compile a C or C++ source file...
    # using self['stem'] and self['lang'] where necessary</pre>
<p>The first positional argument to <code><a href="reference.html#flow">@flow</a></code> is the <em>priority</em> of the variant; variants with different priorities are allowed to match at the same time, and the highest-priority one is selected. A priority is a signed integer and defaults to 0.</p>
<p>The special <code>yield self</code> statement is a magical instruction to Flower that the execution should continue to a matching flow variant with the next highest priority. The current flow variant never continues beyond <code>yield self</code>. In the example above, the low-priority flow variant (with the default priority of 0) matches every invocation of <code>compileSource</code>. Because the variants matching <code>.c</code> and <code>.cpp</code> files have a higher priority, one of them will be executed, but then will chain to a matching flow variant with the next highest priority, which is the bottom one in the example. It is a runtime error if <code>yield self</code> fails to find a match with a lower priority, or encounters a tie between two or more matching flow variants.</p>
<h3 id="goal">Goals</h3>
<p>A flow can be declared a <strong>goal</strong> that can be invoked from the Flower command line. This is done with the <code><a href="reference.html#goal">@goal</a></code> decorator:</p>
<pre>@goal('all', 'Build the entire product.')
@flow
def buildAll(self):
    yield linkBinary()</pre>
<p>With this declaration, when <code>flower all</code> command is run, Flower will execute the <code>buildAll</code> flow. The first argument of <code>@goal</code> defines the keyword to be specified on the command line to invoke this goal. Flower's command line syntax is self-documenting, and when <code>flower --help</code> is invoked, <code>all</code> will be listed as a valid goal name, and the second argument of <code>@goal</code> will be used as its description. Most flows, however, are internal and not meant to be invoked by the end user; these are not declared as goals, which helps keep the command line syntax clean. When no goal is specified on the command line, <code>config.goal</code> configuration query is used to select the default, which will typically be <code>all</code>.</p>
<p>Goals can declare <strong id="goal-argument">arguments</strong> that will be translated to node parameters (see the <a href="reference.html#goal">reference manual</a> for details):</p>
<pre>@goal('compile', 'Compile a single source file.',
      {'arg': 'source', 'help': 'The source file to compile.'})
@flow
def compileSource(self, source):
    ...</pre>
<h2 id="configuration-subsystem">Configuration subsystem</h2>
<p>This roughly corresponds to variables in GNU make.</p>
<h3 id="queries-and-answers">Queries and answers</h3>
<p>Flower's configuration subsystem provides information used at various stages of the build process. The configuration system is best described as providing answers to questions (<code>queries</code>) at runtime. Examples of such questions are: What compiler flags do we need? Do we want to build with debug information or not? Is the target platform little-endian or big-endian?</p>
<p>A configuration query cannot require significant computations to produce an answer, and cannot depend on flows being run. For example, <em>the list of all source files to compile</em> would not be a valid configuration query because this list is not known before hardcore setup runs. Instead, such information should be obtained from nodes whose flows perform the non-trivial processing. However, configuration queries are allowed to invoke simple commands that take insignificant time to complete, such as <code>pkg-config</code> or <code>gcc --version</code>.</p>
<p>The configuration system uses appropriate Python types for its answers. Strings are never abused to represent structured data; lists, dictionaries, sets and objects are used where appropriate. For primitive values, strings, numbers and booleans are used. <code>None</code> is used to represent the absence of a meaningful primitive value or an object, but not of a structure like a list or dictionary because those can simply be empty.</p>
<h3 id="answer-example">Providing a simple answer</h3>
<p>The configuration subsystem is accessed from flows and other Python code using the <code><a href="reference.html#config">config</a></code> global variable. Read-only properties of this object provide answers to configuration queries. For example, <code>config.debugSymbols</code> yields true if debug information is to be produced, and false otherwise. In the <strong>configuration files</strong>, which are essentially Python source files, answers are provided by declaring functions with the names of configuration queries. For example:</p>
<pre>def debugSymbols():
    return config.debugMode</pre>
<p>This example returns true whenever another configuration query, <code>config.debugMode</code>, returns true. Note that, even though <code>debugSymbols</code> is a function, any code making the query uses the property access syntax (<code>config.debugSymbols</code>) rather than the method call syntax (<code>config.debugSymbols()</code>): the configuration subsystem takes care of calling the function. It may implement some caching of answers in the future, but at the moment, Flower's performance looks decent without any caching, so none was implemented. Anyway, the configuration functions should always be written in such a way that they yield the same result on repeated invocations in the same context (see below). It is illegal for a configuration query to depend on its own answer directly or indirectly; this will cause a stack overflow.</p>
<p>If our answer did not depend on another configuration query and was in fact a constant, we could have used this shorthand form instead of declaring a function:</p>
<pre>debugSymbols = True</pre>
<p>The above is equivalent to declaring a function always returning <code>True</code>.</p>
<p>It's common to use <code><a href="reference.html#runOnce">util.runOnce</a></code> to run utilities producing interesting standard output. The results are cached, so the same command won't be run more than once. For example, <code>util.runOnce(['gcc', '--version'])</code> returns the output of <code>gcc --version</code> or raises <code><a href="reference.html#CommandFailed">errors.CommandFailed</a></code> if the command didn't succeed (return exit code 0). The shell is not used to invoke the command, so nothing should be escaped.</p>
<h3 id="configuration-file">Configuration files</h3>
<p>The order in which the configuration files are read matters: a configuration file overrides anything declared by the files already read. The exact order in which configuration files are read if found is documented in the <a href="reference.html#configuration-file">reference manual</a>.</p>
<p>A configuration function overriding a setting in another configuration file can use the global name <code><a href="reference.html#default">default</a></code> to access the value being overridden:</p>
<pre>def includePaths():
    return default.includePaths + ['/usr/local/include']</pre>
<p>Here, the function takes the value it's overriding, which is a list of include paths, and appends one more item to it. Unfortunately, shorthand syntax like <code>includePaths = default.includePaths + ['/usr/local/include']</code> cannot be used because the computation can depend on the context and needs to be run at flow execution time rather than parse time.</p>
<p>The <code>default</code> global object should only be used to refer to the setting the function is overriding; all other configuration queries should be made using the <code>config</code> global object because they may be overridden by the subsequently read configuration files.</p>
<h3 id="configuration-object">Configuration objects</h3>
<p>Some values returned by configuration queries are <strong>configuration objects</strong> through which further queries can be made by accessing their read-only properties, leading to hierarchical queries like <code>config.targetPlatform.compiler.compileCommand</code>. This is accomplished by declaring classes in configuration files and returning instances of such classes from queries. Here is a real example:</p>
<pre>import sys

def hostPlatform():
    return config.AutoPlatform()

def targetPlatform():
    return config.hostPlatform

class AutoPlatform(object):
    # ...
    def bigendian(self):
        return sys.byteorder == 'big'
    # ...</pre>
<p>The query <code>config.hostPlatform</code> returns a <em>platform</em> configuration object providing information about the platform Flower is running on. This default configuration returns an instance of the <code>AutoPlatform</code> class (where <em>auto</em> refers to auto-detection of platform properties). The platform object is expected to answer a number of queries about the platform, one of which is <code>bigendian</code> (whether or not the platform is big-endian). Queries are defined on the platform object rather than in the global configuration scope if the answers to them can change depending on whether we are cross-compiling. <code>config.targetPlatform</code> defaults to <code>config.hostPlatform</code> (they'll differ when cross-compiling) but can be overridden to return an instance of some other class providing different answers to the same set of queries.</p>
<p>Note how <code>hostPlatform</code> accesses the <code>AutoPlatform</code> class through the <code>config</code> global object: this allows all overrides of the <code>AutoPlatform</code> class to take effect.</p>
<p>The same magic applies to the properties of the configuration objects as to top-level configuration queries: the caller uses the property access syntax, and the configuration subsystem automatically calls methods of the configuration object. Shorthand syntax for constant answers can be used in classes as well.</p>
<p>Note that configuration classes must be new-style Python classes, that is, they must subclass <code>object</code> rather than nothing.</p>
<p>Another prominent example of a configuration object is the <code>compiler</code> property of a platform configuration object. An expression like <code>config.targetPlatform.compiler</code> returns an object describing the compiler that runs on the host platform and produces files for the target platform. By default, <code>AutoPlatform</code> returns instances of the <code>GCC</code> class.</p>
<p>Classes can be overridden in the configuration files, too. This is accomplished by subclassing the class with the same name that you are overriding:</p>
<pre>class AutoPlatform(default.AutoPlatform):
    def compiler(self):
        return config.LLVM()</pre>
<p>This overrides the <code>compiler</code> property of <code>AutoPlatform</code> while leaving all other properties unmodified. If the overriding method needs to refer to the method being overridden, it should use <code>super</code> and the property access syntax:</p>
<pre>class GCC(default.GCC):
    def optimizeFlags(self):
        return super(GCC, self).optimizeFlags + ['-funsafe-math-optimizations']</pre>
<h3 id="context-dependent">Answers depending on the context</h3>
<p>The answer to any configuration query can depend on the parameters of the node whose flow issues the query. That node is called the <strong id="context">context</strong> in which the query is initiated. To use the node parameters, a top-level configuration function or a method of a configuration class should accept formal parameters with names corresponding to the node parameters:</p>
<pre>def optimizeSize(source):
    return not source.startswith('modules/ecmascript/')</pre>
<p>This means that source files under modules/ecmascript should be optimized for speed, while everything else should be optimized for size. This query will cause a runtime error if issued from a flow where the node doesn't have a <code>source</code> parameter; if it's desirable that the query is answerable even then, the function should declare a default value for the argument. A configuration function or method can also use the <code>**kwargs</code> syntax to capture a dictionary of all node parameters in the current context.</p>
<p>Note that even a function that doesn't declare explicit named arguments can end up depending on the context because it can make other configuration queries that do.</p>
<p>Some configuration queries are invoked with an empty context by the system itself, such as <code>config.processQuota</code> that controls how many parallel processes can be run. All such queries are initially defined in <code>platforms/flower/default.py</code>. However, the vast majority of the configuration queries are entirely user-defined and are only used by flows and other configuration queries.</p>
<p>It's possible to ask the configuration subsystem a <em>what-if</em> question by invoking the <code>config</code> global object <a href="reference.html#config-__call__">as a function</a> with one or more keyword arguments. For example, the expression <code>config(source='file1.cpp').optimizeFlags</code> evaluates to what <code>config.optimizeFlags</code> would have returned had the <code>source</code> parameter in the current context been <code>'file1.cpp'</code>. The rest of the node parameters in such an expression are unchanged from the current context.</p>
<h3 id="option">Options</h3>
<p>A top-level configuration function (but not a method of a configuration class) can be declared as a command-line <strong>option</strong> using the <code><a href="reference.html#option">@option</a></code> decorator:</p>
<pre>@option('--debug-symbols', 'Produce debug information.')
def debugSymbols():
    return False</pre>
<p>This declares that <code>--debug-symbols</code> on the command line should override <code>config.debugSymbols</code> with a true value, and supplies the help text to be used for the option in the output of <code>flower --help</code>. The configuration subsystem queries the answer to the query before parsing the command line and documents that as the default setting in the help text; it also uses the type of the default to restrict the values that can be specified. For a boolean option, its negation like <code>--no-debug-symbols</code> will also be documented and recognized unless this behavior is explicitly suppressed. Note that <code>@option</code> cannot be used with the shorthand syntax like <code>debugSymbols = False</code> because of the restrictions of the decorator syntax in Python.</p>
<h2 id="other-design-decisions">Other design decisions</h2>
<p>This section outlines other notable design decisions made when developing Flower.</p>
<h3 id="top-level-origin">The top-level source directory is the origin</h3>
<p>Flower changes into the top-level source directory before doing anything else. All files are referred to by their canonical names relative to that location, such as <code>platform/unix/product/main.cpp</code>. This simplifies references to files in the source tree compared to the <code>unix-build</code> module which refers to files using paths relative to its own location, resulting in the annoying and unreadable use of <code>../..</code> in many paths.</p>
<h3 id="distinct-buildroot">Always distinct buildroot and simple cleaning</h3>
<p>All files produced by the build are always put in a dedicated directory called the <strong id="buildroot">buildroot</strong>. This is mandatory; unlike the <code>unix-build</code> module, Flower does not allow the buildroot to coincide with the top of the source tree. The default buildroot location is <code>build</code> (a subdirectory at the top level of the source tree), but it can be located outside the source tree, too.</p>
<p>All hardcore setup and other scripts run during the build process have been patched to support a buildroot that does not coincide with the top of the source tree.</p>
<p>As a result, Flower doesn't need to keep track of any generated files to clean. The <code>clean</code> goal simply removes the buildroot directory. The only files generated during the build that end up outside the buildroot are <code>.pyc</code> files generated by Python when compiling modules, since the location of these files cannot be controlled. These are not removed by the <code>clean</code> goal and are harmless (cannot disrupt a subsequent build in any way); <code>git clean -fx</code> can be used if removal of the <code>.pyc</code> files is nevertheless desired.</p>
<p>Note that you should never share a buildroot directory between unix-build and Flower. It's best to delete the old directory upon transition to Flower.</p>
<h3 id="logging">Extensible logging</h3>
<p>All output to the console and log files is handled by <strong id="logger"><a href="reference.html#Logger">logger</a></strong> objects. They are essentially listeners that can react to various events such as a command starting, command completing etc. More than one logger can be active at the same time and react to the same events. A logger can ignore some events while reacting to others, and different logging formats and levels of detail can be achieved through add-on logging classes.</p>
<p>The standard output and standard error of each command is captured via pipes by a background thread, which is the only thread other than the main thread that Flower uses. The output of the commands is split into lines. A logger has a chance to react to a command's output on two occasions: first immediately when a line of output is fully read from the pipe (<em>real-time logging</em>), and later when the command eventually completes or fails and the list of all lines it has written to the standard output and standard error is available to the logger as an attribute of the command object.</p>
<p>Flower contains two fully functional logger classes at the moment: a console logger and a text file logger.</p>
<p>An instance of the <strong id="console-logger">console logger</strong> is created to log to the standard output and standard error. The level of detail is controlled by several configuration queries and the corresponding command-line options such as <code>-v</code> and <code>-q</code>. The console logger uses real-time logging to avoid delaying the output of the commands as they run, which can lead to some intermixing of the output when parallel processes are active. This logger uses ANSI control sequences to color different kinds of output such as progress messages, commands' standard output and standard error, etc, unless coloring is disabled or the output is redirected. Coloring was introduced especially so that it becomes the single universally hated feature of Flower, and thus all the other dubious design decisions go unnoticed.</p>
<p>At the same time, a <strong id="text-file-logger">text file logger</strong> is created to log to a file (<code>build.log</code> by default). This logger rotates the log files to keep a configurable number of old log files under names such as <code>build.log.1</code>, <code>build.log.2</code> etc. The text file logger uses a different format from the console logger. In particular, it does not log the commands' output in real time, and instead writes the entire output of a command into the log when the command completes or fails. This leads to a more readable log file where the output of the commands that ran in parallel does not intermix.</p>
<p>Because the output goes to two places (the console and the text log file) by default, the user will seldom need to redirect Flower's output.</p>
<p>No user-defined code such as flows or configuration queries should write to the standard output or standard error. The logging system takes care of progress reporting automatically, and if something goes wrong, user-defined code should raise an exception (which will be reported). Warnings tend to be treated as noise and ignored, so everything should either work or fail. In a future version of Flower, the logging system may provide a way to issue warnings with support for “known issues” that don't need to be reported to everyone building the product.</p>
<h3 id="parallel">Parallel whenever possible</h3>
<p>Flower defaults to running as many parallel commands as the machine has CPU cores. There is seldom any reason to disable that, especially because the log file is always readable even when many parallel processes are run. However, the <code>config.processQuota</code> configuration query can be overridden on any level, including with the command-line option <code>-j</code>.</p>
<p>Various hardcore setup steps are run separately, which allows most of them to be run at the same time (however, some of them depend on others, which introduces some sequencing).</p>
<p>Compilation of each selftest is also run separately, resulting in a massive improvement of the build time because of parallelization. The hardcore step to generate selftests is not used, and the Pike script is invoked directly for every selftest. This script has been modified to allow invocation for an individual selftest.</p>
<h3 id="hardcore-deps">Dependency tracking in hardcore scripts</h3>
<p>Hardcore setup scripts have been patched to accept the new <code>--timestamp</code> option. Running a hardcore script with <code>--timestamp FILE</code> results in creation or touching of an empty <code>FILE</code> (which is touched even if no output files have been updated). In addition, <code>FILE.d</code> is created or overwritten. The latter is a GNU makefile snippet that declares <code>FILE</code> as depending on every file or directory that the script has read or tried to read (for files that are currently absent but whose presence would have affected the output, <code>$(wildcard ...)</code> syntax is used). This means that if one of these dependencies becomes newer than the timestamp <code>FILE</code>, the hardcore step needs to be re-run, but not otherwise. Similar modifications have been made to the selftest compiler.</p>
<p>This can be used in a build system based on GNU make as well. In Flower, the <code><a href="reference.html#readDepFile">util.readDepFile</a></code> function understands just as must of the GNU make syntax as is necessary to read these dependency files (and those generated by <code>gcc -MMD</code>, too). The flows that run hardcore steps read the dependency files to avoid running the hardcore scripts needlessly.</p>
<p>As a result, Flower successfully avoids running any commands unless necessary. When invoked the second time after a complete, successful build, Flower does not run any commands, and only spends an order of a second on a modern developer workstation to detect that everything is up-to-date. (Only 50 ms of that is system time, so there is room for optimization.)</p>
<h3 id="core-and-products">Core and products</h3>
<p>The core delivery, once it hopefully incorporates Flower, will contain flow and configuration files in the <code>module.build</code> directories of the relevant modules such as hardcore.</p>
<p>Some of the configuration files will be indifferent to the order in which they are read, for example because they add items to lists they override, such as the list of include paths. Such configuration files should have normal names like, for example, <code>gcc.conf.py</code> for a file overriding some aspects of the <code>GCC</code> configuration class.</p>
<p>Other configuration files will establish configuration queries and classes that can be overridden by other modules. It's important that these are read before any files overriding them are, therefore such configuration files should go early in the lexicographical order. By convention, names like <code>00-gcc.conf.py</code> should be used in these cases.</p>
<p>Products using the core delivery should override aspects of Flower configuration in their own modules rather than by patching Core. Core should define enough configurables to allow the degree of flexibility required by the products without resorting to patching.</p>
<p>The product is expected to define a default goal specific to the project. For example, in Desktop, the default goal produces operating system packages.</p>
<p>In the rare cases when a product needs to override a particular flow in Core, it should define a flow variant with a priority of 10 or more.</p>
<h3 id="unix-only">Currently UNIX-only</h3>
<p>This is not actually a design goal (doesn't sound like an admirable one, in any case). Technically, little stands in the way of applying Flower to platforms that don't currently use GNU make. However, as it happens, Windows and Mac users prefer the build process to be controlled by the IDE, and their platform-specific scripts generate project files for the IDE rather than running the build directly. While Flower could be used to build Opera on these platforms, it's questionable whether anybody needs this. Therefore, the current development of Flower focuses on providing good support for the platforms currently using GNU make.</p>
<p>Currently, Flower uses very little UNIX-specific code (actually, POSIX-specific, so it will work on MacOS X, too). Porting to Windows would require a few changes in the process scheduler because it uses a POSIX-specific way of waiting for completing child processes and reacting to signals, in the output-capturing background thread.</p>
<p>There are also some areas where, although Flower is not directly incompatible with Windows, it assumes a design philosophy biased towards UNIX. For example, <code>/</code> is always used as the separator of file path components (which is so much simpler to read and write than using something like <code>os.path.join</code> everywhere). The command line syntax is typical of UNIX tools. ANSI control sequences are used to color the console output. The dependency tracking and some aspects of the compiler configuration make assumptions about the compiler that may only be true for GCC and compilers imitating GCC, which most compilers on UNIX do. Some output-handling code may be careless about the line-break conventions.</p>
</body>
</html>
