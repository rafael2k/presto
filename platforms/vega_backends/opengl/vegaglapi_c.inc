/* -*- Mode: c++; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*-
** Auto-generated by scripts/generate_api.py from glapi.txt.
** DO NOT EDIT THIS FILE MANUALLY.
** To update, run the script mentioned above.
**
** Copyright Opera Software ASA. All rights reserved.
** This file is part of the Opera web browser. It may not be distributed
** under any circumstances.
*/

#ifdef OPENGL_REGISTRY

# undef glBlendFunc
# undef glClear
# undef glClearColor
# undef glClearDepth
# undef glClearStencil
# undef glColorMask
# undef glCullFace
# undef glDepthFunc
# undef glDepthMask
# undef glDepthRange
# undef glDisable
# undef glEnable
# undef glFinish
# undef glFlush
# undef glFrontFace
# undef glGetFloatv
# undef glGetIntegerv
# undef glGetString
# undef glHint
# undef glPixelStorei
# undef glReadPixels
# undef glScissor
# undef glStencilFunc
# undef glStencilMask
# undef glStencilOp
# undef glGetTexParameteriv
# undef glTexParameteri
# undef glViewport
# undef glBindTexture
# undef glCopyTexSubImage2D
# undef glDeleteTextures
# undef glDrawArrays
# undef glDrawElements
# undef glGenTextures
# undef glPolygonOffset
# undef glTexImage2D
# undef glTexSubImage2D
# undef glBlendColor
# undef glBlendEquation
# undef glActiveTexture
# undef glBlendFuncSeparate
# undef glBindBuffer
# undef glBufferData
# undef glBufferSubData
# undef glDeleteBuffers
# undef glGenBuffers
# undef glAttachShader
# undef glBindAttribLocation
# undef glBlendEquationSeparate
# undef glCompileShader
# undef glCreateProgram
# undef glCreateShader
# undef glDeleteProgram
# undef glDeleteShader
# undef glDetachShader
# undef glDisableVertexAttribArray
# undef glEnableVertexAttribArray
# undef glGetActiveAttrib
# undef glGetActiveUniform
# undef glGetAttribLocation
# undef glGetProgramInfoLog
# undef glGetProgramiv
# undef glGetShaderInfoLog
# undef glGetShaderiv
# undef glGetUniformLocation
# undef glGetUniformfv
# undef glGetUniformiv
# undef glLinkProgram
# undef glShaderSource
# undef glStencilFuncSeparate
# undef glStencilOpSeparate
# undef glUniform1f
# undef glUniform1fv
# undef glUniform1i
# undef glUniform1iv
# undef glUniform2f
# undef glUniform2fv
# undef glUniform2i
# undef glUniform2iv
# undef glUniform3f
# undef glUniform3fv
# undef glUniform3i
# undef glUniform3iv
# undef glUniform4f
# undef glUniform4fv
# undef glUniform4i
# undef glUniform4iv
# undef glUniformMatrix2fv
# undef glUniformMatrix3fv
# undef glUniformMatrix4fv
# undef glUseProgram
# undef glValidateProgram
# undef glVertexAttrib1f
# undef glVertexAttrib1fv
# undef glVertexAttrib2f
# undef glVertexAttrib2fv
# undef glVertexAttrib3f
# undef glVertexAttrib3fv
# undef glVertexAttrib4f
# undef glVertexAttrib4fv
# undef glVertexAttribPointer
# undef glBindFramebuffer
# undef glBindRenderbuffer
# undef glCheckFramebufferStatus
# undef glDeleteFramebuffers
# undef glDeleteRenderbuffers
# undef glFramebufferRenderbuffer
# undef glFramebufferTexture2D
# undef glGenFramebuffers
# undef glGenRenderbuffers
# undef glGenerateMipmap
# undef glGetRenderbufferParameteriv
# undef glRenderbufferStorage
# undef glBlitFramebuffer
# undef glRenderbufferStorageMultisample
# undef glMapBufferRange
# undef glUnmapBuffer
# undef glFenceSync
# undef glGetSynciv
# undef glDeleteSync
# undef glBindFragDataLocationIndexed
# ifdef VEGA_ENABLE_PERF_EVENTS
#  undef glStringMarkerGREMEDY
# endif // VEGA_ENABLE_PERF_EVENTS
# ifdef VEGA_GL_DEBUG_CONTEXT
#  undef glDebugMessageCallbackARB
# endif // VEGA_GL_DEBUG_CONTEXT

void local_ignore_stringmarkergremedy(GLsizei, const GLvoid*) {};

# ifndef VEGA_OPENGLES
OP_STATUS VEGAGlAPI::Init(VEGAGlDevice * dev)
{
	m_GetString = reinterpret_cast<GetString_t>(dev->getGLFunction("glGetString"));
	if (!m_GetString)
		return OpStatus::ERR;

	int ver_major, ver_minor;
	const char * ver_string = reinterpret_cast<const char*>(m_GetString(GL_VERSION));
	if (!ver_string || op_sscanf(ver_string, "%d.%d", &ver_major, &ver_minor) != 2)
		return OpStatus::ERR;

	bool e_ARB_blend_func_extended = false;
#  ifdef VEGA_GL_DEBUG_CONTEXT
	bool e_ARB_debug_output = false;
#  endif // VEGA_GL_DEBUG_CONTEXT
	bool e_ARB_depth_texture = false;
	bool e_ARB_fragment_shader = false;
	bool e_ARB_framebuffer_object = false;
	bool e_ARB_map_buffer_range = false;
	bool e_ARB_multisample = false;
	bool e_ARB_multitexture = false;
	bool e_ARB_point_sprite = false;
	bool e_ARB_shader_objects = false;
	bool e_ARB_shading_language_100 = false;
	bool e_ARB_sync = false;
	bool e_ARB_texture_cube_map = false;
	bool e_ARB_texture_mirrored_repeat = false;
	bool e_ARB_texture_non_power_of_two = false;
	bool e_ARB_vertex_buffer_object = false;
	bool e_ARB_vertex_program = false;
	bool e_ARB_vertex_shader = false;
	bool e_ATI_fragment_shader = false;
	bool e_ATI_separate_stencil = false;
	bool e_EXT_blend_equation_separate = false;
	bool e_EXT_blend_func_separate = false;
	bool e_EXT_framebuffer_blit = false;
	bool e_EXT_framebuffer_multisample = false;
	bool e_EXT_framebuffer_object = false;
	bool e_EXT_packed_depth_stencil = false;
	bool e_EXT_stencil_wrap = false;
#  ifdef VEGA_ENABLE_PERF_EVENTS
	bool e_GREMEDY_string_marker = false;
#  endif // VEGA_ENABLE_PERF_EVENTS
	bool e_IBM_texture_mirrored_repeat = false;
	bool e_NV_point_sprite = false;
	bool e_NV_vertex_program = false;
	bool e_SGIS_generate_mipmap = false;
	bool e_SGIX_depth_texture = false;

	const char * ext_string = reinterpret_cast<const char*>(m_GetString(GL_EXTENSIONS));
	while (*ext_string)
	{
		size_t len = op_strcspn(ext_string, " ");
		if (len == 26 && op_strncmp(ext_string, "GL_ARB_blend_func_extended", 26) == 0)
			e_ARB_blend_func_extended = true;
#  ifdef VEGA_GL_DEBUG_CONTEXT
		else if (len == 19 && op_strncmp(ext_string, "GL_ARB_debug_output", 19) == 0)
			e_ARB_debug_output = true;
#  endif // VEGA_GL_DEBUG_CONTEXT
		else if (len == 20 && op_strncmp(ext_string, "GL_ARB_depth_texture", 20) == 0)
			e_ARB_depth_texture = true;
		else if (len == 22 && op_strncmp(ext_string, "GL_ARB_fragment_shader", 22) == 0)
			e_ARB_fragment_shader = true;
		else if (len == 25 && op_strncmp(ext_string, "GL_ARB_framebuffer_object", 25) == 0)
			e_ARB_framebuffer_object = true;
		else if (len == 23 && op_strncmp(ext_string, "GL_ARB_map_buffer_range", 23) == 0)
			e_ARB_map_buffer_range = true;
		else if (len == 18 && op_strncmp(ext_string, "GL_ARB_multisample", 18) == 0)
			e_ARB_multisample = true;
		else if (len == 19 && op_strncmp(ext_string, "GL_ARB_multitexture", 19) == 0)
			e_ARB_multitexture = true;
		else if (len == 19 && op_strncmp(ext_string, "GL_ARB_point_sprite", 19) == 0)
			e_ARB_point_sprite = true;
		else if (len == 21 && op_strncmp(ext_string, "GL_ARB_shader_objects", 21) == 0)
			e_ARB_shader_objects = true;
		else if (len == 27 && op_strncmp(ext_string, "GL_ARB_shading_language_100", 27) == 0)
			e_ARB_shading_language_100 = true;
		else if (len == 11 && op_strncmp(ext_string, "GL_ARB_sync", 11) == 0)
			e_ARB_sync = true;
		else if (len == 23 && op_strncmp(ext_string, "GL_ARB_texture_cube_map", 23) == 0)
			e_ARB_texture_cube_map = true;
		else if (len == 30 && op_strncmp(ext_string, "GL_ARB_texture_mirrored_repeat", 30) == 0)
			e_ARB_texture_mirrored_repeat = true;
		else if (len == 31 && op_strncmp(ext_string, "GL_ARB_texture_non_power_of_two", 31) == 0)
			e_ARB_texture_non_power_of_two = true;
		else if (len == 27 && op_strncmp(ext_string, "GL_ARB_vertex_buffer_object", 27) == 0)
			e_ARB_vertex_buffer_object = true;
		else if (len == 21 && op_strncmp(ext_string, "GL_ARB_vertex_program", 21) == 0)
			e_ARB_vertex_program = true;
		else if (len == 20 && op_strncmp(ext_string, "GL_ARB_vertex_shader", 20) == 0)
			e_ARB_vertex_shader = true;
		else if (len == 22 && op_strncmp(ext_string, "GL_ATI_fragment_shader", 22) == 0)
			e_ATI_fragment_shader = true;
		else if (len == 23 && op_strncmp(ext_string, "GL_ATI_separate_stencil", 23) == 0)
			e_ATI_separate_stencil = true;
		else if (len == 30 && op_strncmp(ext_string, "GL_EXT_blend_equation_separate", 30) == 0)
			e_EXT_blend_equation_separate = true;
		else if (len == 26 && op_strncmp(ext_string, "GL_EXT_blend_func_separate", 26) == 0)
			e_EXT_blend_func_separate = true;
		else if (len == 23 && op_strncmp(ext_string, "GL_EXT_framebuffer_blit", 23) == 0)
			e_EXT_framebuffer_blit = true;
		else if (len == 30 && op_strncmp(ext_string, "GL_EXT_framebuffer_multisample", 30) == 0)
			e_EXT_framebuffer_multisample = true;
		else if (len == 25 && op_strncmp(ext_string, "GL_EXT_framebuffer_object", 25) == 0)
			e_EXT_framebuffer_object = true;
		else if (len == 27 && op_strncmp(ext_string, "GL_EXT_packed_depth_stencil", 27) == 0)
			e_EXT_packed_depth_stencil = true;
		else if (len == 19 && op_strncmp(ext_string, "GL_EXT_stencil_wrap", 19) == 0)
			e_EXT_stencil_wrap = true;
#  ifdef VEGA_ENABLE_PERF_EVENTS
		else if (len == 24 && op_strncmp(ext_string, "GL_GREMEDY_string_marker", 24) == 0)
			e_GREMEDY_string_marker = true;
#  endif // VEGA_ENABLE_PERF_EVENTS
		else if (len == 30 && op_strncmp(ext_string, "GL_IBM_texture_mirrored_repeat", 30) == 0)
			e_IBM_texture_mirrored_repeat = true;
		else if (len == 18 && op_strncmp(ext_string, "GL_NV_point_sprite", 18) == 0)
			e_NV_point_sprite = true;
		else if (len == 20 && op_strncmp(ext_string, "GL_NV_vertex_program", 20) == 0)
			e_NV_vertex_program = true;
		else if (len == 23 && op_strncmp(ext_string, "GL_SGIS_generate_mipmap", 23) == 0)
			e_SGIS_generate_mipmap = true;
		else if (len == 21 && op_strncmp(ext_string, "GL_SGIX_depth_texture", 21) == 0)
			e_SGIX_depth_texture = true;
		ext_string += len;
		while (*ext_string == ' ')
			ext_string++;
	}

	if (ver_major < 1 || ver_major == 1 && ver_minor < 2)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if ((ver_major < 1 || ver_major == 1 && ver_minor < 3) && !e_ARB_multisample)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if ((ver_major < 1 || ver_major == 1 && ver_minor < 3) && !e_ARB_texture_cube_map)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if ((ver_major < 1 || ver_major == 1 && ver_minor < 4) && !e_ARB_depth_texture && !e_SGIX_depth_texture)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if ((ver_major < 1 || ver_major == 1 && ver_minor < 4) && !e_ARB_texture_mirrored_repeat && !e_IBM_texture_mirrored_repeat)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if ((ver_major < 1 || ver_major == 1 && ver_minor < 4) && !e_EXT_stencil_wrap)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if ((ver_major < 1 || ver_major == 1 && ver_minor < 4) && !e_SGIS_generate_mipmap)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if ((ver_major < 2 || ver_major == 2 && ver_minor < 0) && !e_ARB_fragment_shader && !e_ATI_fragment_shader)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if ((ver_major < 2 || ver_major == 2 && ver_minor < 0) && !e_ARB_point_sprite && !e_NV_point_sprite)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if ((ver_major < 2 || ver_major == 2 && ver_minor < 0) && !e_ARB_shading_language_100)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if ((ver_major < 2 || ver_major == 2 && ver_minor < 0) && !e_ARB_texture_non_power_of_two)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!e_ARB_framebuffer_object && !e_EXT_packed_depth_stencil)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	m_BlendFunc = reinterpret_cast<BlendFunc_t>(dev->getGLFunction("glBlendFunc"));
	if (!m_BlendFunc)
		return OpStatus::ERR;
	m_Clear = reinterpret_cast<Clear_t>(dev->getGLFunction("glClear"));
	if (!m_Clear)
		return OpStatus::ERR;
	m_ClearColor = reinterpret_cast<ClearColor_t>(dev->getGLFunction("glClearColor"));
	if (!m_ClearColor)
		return OpStatus::ERR;
	m_ClearDepth = reinterpret_cast<ClearDepth_t>(dev->getGLFunction("glClearDepth"));
	if (!m_ClearDepth)
		return OpStatus::ERR;
	m_ClearStencil = reinterpret_cast<ClearStencil_t>(dev->getGLFunction("glClearStencil"));
	if (!m_ClearStencil)
		return OpStatus::ERR;
	m_ColorMask = reinterpret_cast<ColorMask_t>(dev->getGLFunction("glColorMask"));
	if (!m_ColorMask)
		return OpStatus::ERR;
	m_CullFace = reinterpret_cast<CullFace_t>(dev->getGLFunction("glCullFace"));
	if (!m_CullFace)
		return OpStatus::ERR;
	m_DepthFunc = reinterpret_cast<DepthFunc_t>(dev->getGLFunction("glDepthFunc"));
	if (!m_DepthFunc)
		return OpStatus::ERR;
	m_DepthMask = reinterpret_cast<DepthMask_t>(dev->getGLFunction("glDepthMask"));
	if (!m_DepthMask)
		return OpStatus::ERR;
	m_DepthRange = reinterpret_cast<DepthRange_t>(dev->getGLFunction("glDepthRange"));
	if (!m_DepthRange)
		return OpStatus::ERR;
	m_Disable = reinterpret_cast<Disable_t>(dev->getGLFunction("glDisable"));
	if (!m_Disable)
		return OpStatus::ERR;
	m_Enable = reinterpret_cast<Enable_t>(dev->getGLFunction("glEnable"));
	if (!m_Enable)
		return OpStatus::ERR;
	m_Finish = reinterpret_cast<Finish_t>(dev->getGLFunction("glFinish"));
	if (!m_Finish)
		return OpStatus::ERR;
	m_Flush = reinterpret_cast<Flush_t>(dev->getGLFunction("glFlush"));
	if (!m_Flush)
		return OpStatus::ERR;
	m_FrontFace = reinterpret_cast<FrontFace_t>(dev->getGLFunction("glFrontFace"));
	if (!m_FrontFace)
		return OpStatus::ERR;
	m_GetError = reinterpret_cast<GetError_t>(dev->getGLFunction("glGetError"));
	if (!m_GetError)
		return OpStatus::ERR;
	m_GetFloatv = reinterpret_cast<GetFloatv_t>(dev->getGLFunction("glGetFloatv"));
	if (!m_GetFloatv)
		return OpStatus::ERR;
	m_GetIntegerv = reinterpret_cast<GetIntegerv_t>(dev->getGLFunction("glGetIntegerv"));
	if (!m_GetIntegerv)
		return OpStatus::ERR;
	m_Hint = reinterpret_cast<Hint_t>(dev->getGLFunction("glHint"));
	if (!m_Hint)
		return OpStatus::ERR;
	m_PixelStorei = reinterpret_cast<PixelStorei_t>(dev->getGLFunction("glPixelStorei"));
	if (!m_PixelStorei)
		return OpStatus::ERR;
	m_ReadPixels = reinterpret_cast<ReadPixels_t>(dev->getGLFunction("glReadPixels"));
	if (!m_ReadPixels)
		return OpStatus::ERR;
	m_Scissor = reinterpret_cast<Scissor_t>(dev->getGLFunction("glScissor"));
	if (!m_Scissor)
		return OpStatus::ERR;
	m_StencilFunc = reinterpret_cast<StencilFunc_t>(dev->getGLFunction("glStencilFunc"));
	if (!m_StencilFunc)
		return OpStatus::ERR;
	m_StencilMask = reinterpret_cast<StencilMask_t>(dev->getGLFunction("glStencilMask"));
	if (!m_StencilMask)
		return OpStatus::ERR;
	m_StencilOp = reinterpret_cast<StencilOp_t>(dev->getGLFunction("glStencilOp"));
	if (!m_StencilOp)
		return OpStatus::ERR;
	m_GetTexParameteriv = reinterpret_cast<GetTexParameteriv_t>(dev->getGLFunction("glGetTexParameteriv"));
	if (!m_GetTexParameteriv)
		return OpStatus::ERR;
	m_TexParameteri = reinterpret_cast<TexParameteri_t>(dev->getGLFunction("glTexParameteri"));
	if (!m_TexParameteri)
		return OpStatus::ERR;
	m_Viewport = reinterpret_cast<Viewport_t>(dev->getGLFunction("glViewport"));
	if (!m_Viewport)
		return OpStatus::ERR;
	m_BindTexture = reinterpret_cast<BindTexture_t>(dev->getGLFunction("glBindTexture"));
	if (!m_BindTexture)
		return OpStatus::ERR;
	m_CopyTexSubImage2D = reinterpret_cast<CopyTexSubImage2D_t>(dev->getGLFunction("glCopyTexSubImage2D"));
	if (!m_CopyTexSubImage2D)
		return OpStatus::ERR;
	m_DeleteTextures = reinterpret_cast<DeleteTextures_t>(dev->getGLFunction("glDeleteTextures"));
	if (!m_DeleteTextures)
		return OpStatus::ERR;
	m_DrawArrays = reinterpret_cast<DrawArrays_t>(dev->getGLFunction("glDrawArrays"));
	if (!m_DrawArrays)
		return OpStatus::ERR;
	m_DrawElements = reinterpret_cast<DrawElements_t>(dev->getGLFunction("glDrawElements"));
	if (!m_DrawElements)
		return OpStatus::ERR;
	m_GenTextures = reinterpret_cast<GenTextures_t>(dev->getGLFunction("glGenTextures"));
	if (!m_GenTextures)
		return OpStatus::ERR;
	m_PolygonOffset = reinterpret_cast<PolygonOffset_t>(dev->getGLFunction("glPolygonOffset"));
	if (!m_PolygonOffset)
		return OpStatus::ERR;
	m_TexImage2D = reinterpret_cast<TexImage2D_t>(dev->getGLFunction("glTexImage2D"));
	if (!m_TexImage2D)
		return OpStatus::ERR;
	m_TexSubImage2D = reinterpret_cast<TexSubImage2D_t>(dev->getGLFunction("glTexSubImage2D"));
	if (!m_TexSubImage2D)
		return OpStatus::ERR;
	m_BlendColor = reinterpret_cast<BlendColor_t>(dev->getGLFunction("glBlendColor"));
	if (!m_BlendColor)
		return OpStatus::ERR;
	m_BlendEquation = reinterpret_cast<BlendEquation_t>(dev->getGLFunction("glBlendEquation"));
	if (!m_BlendEquation)
		return OpStatus::ERR;
	if (ver_major > 1 || ver_major == 1 && ver_minor >= 3)
		m_ActiveTexture = reinterpret_cast<ActiveTexture_t>(dev->getGLFunction("glActiveTexture"));
	else if (e_ARB_multitexture)
		m_ActiveTexture = reinterpret_cast<ActiveTexture_t>(dev->getGLFunction("glActiveTextureARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_ActiveTexture)
		return OpStatus::ERR;
	if (ver_major > 1 || ver_major == 1 && ver_minor >= 4)
		m_BlendFuncSeparate = reinterpret_cast<BlendFuncSeparate_t>(dev->getGLFunction("glBlendFuncSeparate"));
	else if (e_EXT_blend_func_separate)
		m_BlendFuncSeparate = reinterpret_cast<BlendFuncSeparate_t>(dev->getGLFunction("glBlendFuncSeparateEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_BlendFuncSeparate)
		return OpStatus::ERR;
	if (ver_major > 1 || ver_major == 1 && ver_minor >= 5)
		m_BindBuffer = reinterpret_cast<BindBuffer_t>(dev->getGLFunction("glBindBuffer"));
	else if (e_ARB_vertex_buffer_object)
		m_BindBuffer = reinterpret_cast<BindBuffer_t>(dev->getGLFunction("glBindBufferARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_BindBuffer)
		return OpStatus::ERR;
	if (ver_major > 1 || ver_major == 1 && ver_minor >= 5)
		m_BufferData = reinterpret_cast<BufferData_t>(dev->getGLFunction("glBufferData"));
	else if (e_ARB_vertex_buffer_object)
		m_BufferData = reinterpret_cast<BufferData_t>(dev->getGLFunction("glBufferDataARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_BufferData)
		return OpStatus::ERR;
	if (ver_major > 1 || ver_major == 1 && ver_minor >= 5)
		m_BufferSubData = reinterpret_cast<BufferSubData_t>(dev->getGLFunction("glBufferSubData"));
	else if (e_ARB_vertex_buffer_object)
		m_BufferSubData = reinterpret_cast<BufferSubData_t>(dev->getGLFunction("glBufferSubDataARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_BufferSubData)
		return OpStatus::ERR;
	if (ver_major > 1 || ver_major == 1 && ver_minor >= 5)
		m_DeleteBuffers = reinterpret_cast<DeleteBuffers_t>(dev->getGLFunction("glDeleteBuffers"));
	else if (e_ARB_vertex_buffer_object)
		m_DeleteBuffers = reinterpret_cast<DeleteBuffers_t>(dev->getGLFunction("glDeleteBuffersARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_DeleteBuffers)
		return OpStatus::ERR;
	if (ver_major > 1 || ver_major == 1 && ver_minor >= 5)
		m_GenBuffers = reinterpret_cast<GenBuffers_t>(dev->getGLFunction("glGenBuffers"));
	else if (e_ARB_vertex_buffer_object)
		m_GenBuffers = reinterpret_cast<GenBuffers_t>(dev->getGLFunction("glGenBuffersARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GenBuffers)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_AttachShader = reinterpret_cast<AttachShader_t>(dev->getGLFunction("glAttachShader"));
	else if (e_ARB_shader_objects)
		m_AttachShader = reinterpret_cast<AttachShader_t>(dev->getGLFunction("glAttachObjectARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_AttachShader)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_BindAttribLocation = reinterpret_cast<BindAttribLocation_t>(dev->getGLFunction("glBindAttribLocation"));
	else if (e_ARB_vertex_shader)
		m_BindAttribLocation = reinterpret_cast<BindAttribLocation_t>(dev->getGLFunction("glBindAttribLocationARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_BindAttribLocation)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_BlendEquationSeparate = reinterpret_cast<BlendEquationSeparate_t>(dev->getGLFunction("glBlendEquationSeparate"));
	else if (e_EXT_blend_equation_separate)
		m_BlendEquationSeparate = reinterpret_cast<BlendEquationSeparate_t>(dev->getGLFunction("glBlendEquationSeparateEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_BlendEquationSeparate)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_CompileShader = reinterpret_cast<CompileShader_t>(dev->getGLFunction("glCompileShader"));
	else if (e_ARB_shader_objects)
		m_CompileShader = reinterpret_cast<CompileShader_t>(dev->getGLFunction("glCompileShaderARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_CompileShader)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_CreateProgram = reinterpret_cast<CreateProgram_t>(dev->getGLFunction("glCreateProgram"));
	else if (e_ARB_shader_objects)
		m_CreateProgram = reinterpret_cast<CreateProgram_t>(dev->getGLFunction("glCreateProgramObjectARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_CreateProgram)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_CreateShader = reinterpret_cast<CreateShader_t>(dev->getGLFunction("glCreateShader"));
	else if (e_ARB_shader_objects)
		m_CreateShader = reinterpret_cast<CreateShader_t>(dev->getGLFunction("glCreateShaderObjectARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_CreateShader)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_DeleteProgram = reinterpret_cast<DeleteProgram_t>(dev->getGLFunction("glDeleteProgram"));
	else if (e_ARB_shader_objects)
		m_DeleteProgram = reinterpret_cast<DeleteProgram_t>(dev->getGLFunction("glDeleteObjectARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_DeleteProgram)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_DeleteShader = reinterpret_cast<DeleteShader_t>(dev->getGLFunction("glDeleteShader"));
	else if (e_ARB_shader_objects)
		m_DeleteShader = reinterpret_cast<DeleteShader_t>(dev->getGLFunction("glDeleteObjectARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_DeleteShader)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_DetachShader = reinterpret_cast<DetachShader_t>(dev->getGLFunction("glDetachShader"));
	else if (e_ARB_shader_objects)
		m_DetachShader = reinterpret_cast<DetachShader_t>(dev->getGLFunction("glDetachObjectARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_DetachShader)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_DisableVertexAttribArray = reinterpret_cast<DisableVertexAttribArray_t>(dev->getGLFunction("glDisableVertexAttribArray"));
	else if (e_ARB_vertex_program)
		m_DisableVertexAttribArray = reinterpret_cast<DisableVertexAttribArray_t>(dev->getGLFunction("glDisableVertexAttribArrayARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_DisableVertexAttribArray)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_EnableVertexAttribArray = reinterpret_cast<EnableVertexAttribArray_t>(dev->getGLFunction("glEnableVertexAttribArray"));
	else if (e_ARB_vertex_program)
		m_EnableVertexAttribArray = reinterpret_cast<EnableVertexAttribArray_t>(dev->getGLFunction("glEnableVertexAttribArrayARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_EnableVertexAttribArray)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_GetActiveAttrib = reinterpret_cast<GetActiveAttrib_t>(dev->getGLFunction("glGetActiveAttrib"));
	else if (e_ARB_vertex_shader)
		m_GetActiveAttrib = reinterpret_cast<GetActiveAttrib_t>(dev->getGLFunction("glGetActiveAttribARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetActiveAttrib)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_GetActiveUniform = reinterpret_cast<GetActiveUniform_t>(dev->getGLFunction("glGetActiveUniform"));
	else if (e_ARB_shader_objects)
		m_GetActiveUniform = reinterpret_cast<GetActiveUniform_t>(dev->getGLFunction("glGetActiveUniformARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetActiveUniform)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_GetAttribLocation = reinterpret_cast<GetAttribLocation_t>(dev->getGLFunction("glGetAttribLocation"));
	else if (e_ARB_vertex_shader)
		m_GetAttribLocation = reinterpret_cast<GetAttribLocation_t>(dev->getGLFunction("glGetAttribLocationARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetAttribLocation)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_GetProgramInfoLog = reinterpret_cast<GetProgramInfoLog_t>(dev->getGLFunction("glGetProgramInfoLog"));
	else if (e_ARB_shader_objects)
		m_GetProgramInfoLog = reinterpret_cast<GetProgramInfoLog_t>(dev->getGLFunction("glGetInfoLogARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetProgramInfoLog)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_GetProgramiv = reinterpret_cast<GetProgramiv_t>(dev->getGLFunction("glGetProgramiv"));
	else if (e_ARB_vertex_program)
		m_GetProgramiv = reinterpret_cast<GetProgramiv_t>(dev->getGLFunction("glGetProgramivARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetProgramiv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_GetShaderInfoLog = reinterpret_cast<GetShaderInfoLog_t>(dev->getGLFunction("glGetShaderInfoLog"));
	else if (e_ARB_shader_objects)
		m_GetShaderInfoLog = reinterpret_cast<GetShaderInfoLog_t>(dev->getGLFunction("glGetInfoLogARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetShaderInfoLog)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_GetShaderiv = reinterpret_cast<GetShaderiv_t>(dev->getGLFunction("glGetShaderiv"));
	else if (e_ARB_shader_objects)
		m_GetShaderiv = reinterpret_cast<GetShaderiv_t>(dev->getGLFunction("glGetObjectParameterivARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetShaderiv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_GetUniformLocation = reinterpret_cast<GetUniformLocation_t>(dev->getGLFunction("glGetUniformLocation"));
	else if (e_ARB_shader_objects)
		m_GetUniformLocation = reinterpret_cast<GetUniformLocation_t>(dev->getGLFunction("glGetUniformLocationARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetUniformLocation)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_GetUniformfv = reinterpret_cast<GetUniformfv_t>(dev->getGLFunction("glGetUniformfv"));
	else if (e_ARB_shader_objects)
		m_GetUniformfv = reinterpret_cast<GetUniformfv_t>(dev->getGLFunction("glGetUniformfvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetUniformfv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_GetUniformiv = reinterpret_cast<GetUniformiv_t>(dev->getGLFunction("glGetUniformiv"));
	else if (e_ARB_shader_objects)
		m_GetUniformiv = reinterpret_cast<GetUniformiv_t>(dev->getGLFunction("glGetUniformivARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetUniformiv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_LinkProgram = reinterpret_cast<LinkProgram_t>(dev->getGLFunction("glLinkProgram"));
	else if (e_ARB_shader_objects)
		m_LinkProgram = reinterpret_cast<LinkProgram_t>(dev->getGLFunction("glLinkProgramARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_LinkProgram)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_ShaderSource = reinterpret_cast<ShaderSource_t>(dev->getGLFunction("glShaderSource"));
	else if (e_ARB_shader_objects)
		m_ShaderSource = reinterpret_cast<ShaderSource_t>(dev->getGLFunction("glShaderSourceARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_ShaderSource)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_StencilFuncSeparate = reinterpret_cast<StencilFuncSeparate_t>(dev->getGLFunction("glStencilFuncSeparate"));
	else if (e_ATI_separate_stencil)
		m_StencilFuncSeparate = reinterpret_cast<StencilFuncSeparate_t>(dev->getGLFunction("glStencilFuncSeparateATI"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_StencilFuncSeparate)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_StencilOpSeparate = reinterpret_cast<StencilOpSeparate_t>(dev->getGLFunction("glStencilOpSeparate"));
	else if (e_ATI_separate_stencil)
		m_StencilOpSeparate = reinterpret_cast<StencilOpSeparate_t>(dev->getGLFunction("glStencilOpSeparateATI"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_StencilOpSeparate)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform1f = reinterpret_cast<Uniform1f_t>(dev->getGLFunction("glUniform1f"));
	else if (e_ARB_shader_objects)
		m_Uniform1f = reinterpret_cast<Uniform1f_t>(dev->getGLFunction("glUniform1fARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform1f)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform1fv = reinterpret_cast<Uniform1fv_t>(dev->getGLFunction("glUniform1fv"));
	else if (e_ARB_shader_objects)
		m_Uniform1fv = reinterpret_cast<Uniform1fv_t>(dev->getGLFunction("glUniform1fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform1fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform1i = reinterpret_cast<Uniform1i_t>(dev->getGLFunction("glUniform1i"));
	else if (e_ARB_shader_objects)
		m_Uniform1i = reinterpret_cast<Uniform1i_t>(dev->getGLFunction("glUniform1iARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform1i)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform1iv = reinterpret_cast<Uniform1iv_t>(dev->getGLFunction("glUniform1iv"));
	else if (e_ARB_shader_objects)
		m_Uniform1iv = reinterpret_cast<Uniform1iv_t>(dev->getGLFunction("glUniform1ivARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform1iv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform2f = reinterpret_cast<Uniform2f_t>(dev->getGLFunction("glUniform2f"));
	else if (e_ARB_shader_objects)
		m_Uniform2f = reinterpret_cast<Uniform2f_t>(dev->getGLFunction("glUniform2fARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform2f)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform2fv = reinterpret_cast<Uniform2fv_t>(dev->getGLFunction("glUniform2fv"));
	else if (e_ARB_shader_objects)
		m_Uniform2fv = reinterpret_cast<Uniform2fv_t>(dev->getGLFunction("glUniform2fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform2fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform2i = reinterpret_cast<Uniform2i_t>(dev->getGLFunction("glUniform2i"));
	else if (e_ARB_shader_objects)
		m_Uniform2i = reinterpret_cast<Uniform2i_t>(dev->getGLFunction("glUniform2iARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform2i)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform2iv = reinterpret_cast<Uniform2iv_t>(dev->getGLFunction("glUniform2iv"));
	else if (e_ARB_shader_objects)
		m_Uniform2iv = reinterpret_cast<Uniform2iv_t>(dev->getGLFunction("glUniform2ivARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform2iv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform3f = reinterpret_cast<Uniform3f_t>(dev->getGLFunction("glUniform3f"));
	else if (e_ARB_shader_objects)
		m_Uniform3f = reinterpret_cast<Uniform3f_t>(dev->getGLFunction("glUniform3fARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform3f)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform3fv = reinterpret_cast<Uniform3fv_t>(dev->getGLFunction("glUniform3fv"));
	else if (e_ARB_shader_objects)
		m_Uniform3fv = reinterpret_cast<Uniform3fv_t>(dev->getGLFunction("glUniform3fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform3fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform3i = reinterpret_cast<Uniform3i_t>(dev->getGLFunction("glUniform3i"));
	else if (e_ARB_shader_objects)
		m_Uniform3i = reinterpret_cast<Uniform3i_t>(dev->getGLFunction("glUniform3iARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform3i)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform3iv = reinterpret_cast<Uniform3iv_t>(dev->getGLFunction("glUniform3iv"));
	else if (e_ARB_shader_objects)
		m_Uniform3iv = reinterpret_cast<Uniform3iv_t>(dev->getGLFunction("glUniform3ivARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform3iv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform4f = reinterpret_cast<Uniform4f_t>(dev->getGLFunction("glUniform4f"));
	else if (e_ARB_shader_objects)
		m_Uniform4f = reinterpret_cast<Uniform4f_t>(dev->getGLFunction("glUniform4fARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform4f)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform4fv = reinterpret_cast<Uniform4fv_t>(dev->getGLFunction("glUniform4fv"));
	else if (e_ARB_shader_objects)
		m_Uniform4fv = reinterpret_cast<Uniform4fv_t>(dev->getGLFunction("glUniform4fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform4fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform4i = reinterpret_cast<Uniform4i_t>(dev->getGLFunction("glUniform4i"));
	else if (e_ARB_shader_objects)
		m_Uniform4i = reinterpret_cast<Uniform4i_t>(dev->getGLFunction("glUniform4iARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform4i)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_Uniform4iv = reinterpret_cast<Uniform4iv_t>(dev->getGLFunction("glUniform4iv"));
	else if (e_ARB_shader_objects)
		m_Uniform4iv = reinterpret_cast<Uniform4iv_t>(dev->getGLFunction("glUniform4ivARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_Uniform4iv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_UniformMatrix2fv = reinterpret_cast<UniformMatrix2fv_t>(dev->getGLFunction("glUniformMatrix2fv"));
	else if (e_ARB_shader_objects)
		m_UniformMatrix2fv = reinterpret_cast<UniformMatrix2fv_t>(dev->getGLFunction("glUniformMatrix2fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_UniformMatrix2fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_UniformMatrix3fv = reinterpret_cast<UniformMatrix3fv_t>(dev->getGLFunction("glUniformMatrix3fv"));
	else if (e_ARB_shader_objects)
		m_UniformMatrix3fv = reinterpret_cast<UniformMatrix3fv_t>(dev->getGLFunction("glUniformMatrix3fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_UniformMatrix3fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_UniformMatrix4fv = reinterpret_cast<UniformMatrix4fv_t>(dev->getGLFunction("glUniformMatrix4fv"));
	else if (e_ARB_shader_objects)
		m_UniformMatrix4fv = reinterpret_cast<UniformMatrix4fv_t>(dev->getGLFunction("glUniformMatrix4fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_UniformMatrix4fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_UseProgram = reinterpret_cast<UseProgram_t>(dev->getGLFunction("glUseProgram"));
	else if (e_ARB_shader_objects)
		m_UseProgram = reinterpret_cast<UseProgram_t>(dev->getGLFunction("glUseProgramObjectARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_UseProgram)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_ValidateProgram = reinterpret_cast<ValidateProgram_t>(dev->getGLFunction("glValidateProgram"));
	else if (e_ARB_shader_objects)
		m_ValidateProgram = reinterpret_cast<ValidateProgram_t>(dev->getGLFunction("glValidateProgramARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_ValidateProgram)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_VertexAttrib1f = reinterpret_cast<VertexAttrib1f_t>(dev->getGLFunction("glVertexAttrib1f"));
	else if (e_NV_vertex_program)
		m_VertexAttrib1f = reinterpret_cast<VertexAttrib1f_t>(dev->getGLFunction("glVertexAttrib1fNV"));
	else if (e_ARB_vertex_program)
		m_VertexAttrib1f = reinterpret_cast<VertexAttrib1f_t>(dev->getGLFunction("glVertexAttrib1fARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_VertexAttrib1f)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_VertexAttrib1fv = reinterpret_cast<VertexAttrib1fv_t>(dev->getGLFunction("glVertexAttrib1fv"));
	else if (e_NV_vertex_program)
		m_VertexAttrib1fv = reinterpret_cast<VertexAttrib1fv_t>(dev->getGLFunction("glVertexAttrib1fvNV"));
	else if (e_ARB_vertex_program)
		m_VertexAttrib1fv = reinterpret_cast<VertexAttrib1fv_t>(dev->getGLFunction("glVertexAttrib1fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_VertexAttrib1fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_VertexAttrib2f = reinterpret_cast<VertexAttrib2f_t>(dev->getGLFunction("glVertexAttrib2f"));
	else if (e_NV_vertex_program)
		m_VertexAttrib2f = reinterpret_cast<VertexAttrib2f_t>(dev->getGLFunction("glVertexAttrib2fNV"));
	else if (e_ARB_vertex_program)
		m_VertexAttrib2f = reinterpret_cast<VertexAttrib2f_t>(dev->getGLFunction("glVertexAttrib2fARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_VertexAttrib2f)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_VertexAttrib2fv = reinterpret_cast<VertexAttrib2fv_t>(dev->getGLFunction("glVertexAttrib2fv"));
	else if (e_NV_vertex_program)
		m_VertexAttrib2fv = reinterpret_cast<VertexAttrib2fv_t>(dev->getGLFunction("glVertexAttrib2fvNV"));
	else if (e_ARB_vertex_program)
		m_VertexAttrib2fv = reinterpret_cast<VertexAttrib2fv_t>(dev->getGLFunction("glVertexAttrib2fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_VertexAttrib2fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_VertexAttrib3f = reinterpret_cast<VertexAttrib3f_t>(dev->getGLFunction("glVertexAttrib3f"));
	else if (e_NV_vertex_program)
		m_VertexAttrib3f = reinterpret_cast<VertexAttrib3f_t>(dev->getGLFunction("glVertexAttrib3fNV"));
	else if (e_ARB_vertex_program)
		m_VertexAttrib3f = reinterpret_cast<VertexAttrib3f_t>(dev->getGLFunction("glVertexAttrib3fARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_VertexAttrib3f)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_VertexAttrib3fv = reinterpret_cast<VertexAttrib3fv_t>(dev->getGLFunction("glVertexAttrib3fv"));
	else if (e_NV_vertex_program)
		m_VertexAttrib3fv = reinterpret_cast<VertexAttrib3fv_t>(dev->getGLFunction("glVertexAttrib3fvNV"));
	else if (e_ARB_vertex_program)
		m_VertexAttrib3fv = reinterpret_cast<VertexAttrib3fv_t>(dev->getGLFunction("glVertexAttrib3fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_VertexAttrib3fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_VertexAttrib4f = reinterpret_cast<VertexAttrib4f_t>(dev->getGLFunction("glVertexAttrib4f"));
	else if (e_NV_vertex_program)
		m_VertexAttrib4f = reinterpret_cast<VertexAttrib4f_t>(dev->getGLFunction("glVertexAttrib4fNV"));
	else if (e_ARB_vertex_program)
		m_VertexAttrib4f = reinterpret_cast<VertexAttrib4f_t>(dev->getGLFunction("glVertexAttrib4fARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_VertexAttrib4f)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_VertexAttrib4fv = reinterpret_cast<VertexAttrib4fv_t>(dev->getGLFunction("glVertexAttrib4fv"));
	else if (e_NV_vertex_program)
		m_VertexAttrib4fv = reinterpret_cast<VertexAttrib4fv_t>(dev->getGLFunction("glVertexAttrib4fvNV"));
	else if (e_ARB_vertex_program)
		m_VertexAttrib4fv = reinterpret_cast<VertexAttrib4fv_t>(dev->getGLFunction("glVertexAttrib4fvARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_VertexAttrib4fv)
		return OpStatus::ERR;
	if (ver_major > 2 || ver_major == 2 && ver_minor >= 0)
		m_VertexAttribPointer = reinterpret_cast<VertexAttribPointer_t>(dev->getGLFunction("glVertexAttribPointer"));
	else if (e_ARB_vertex_program)
		m_VertexAttribPointer = reinterpret_cast<VertexAttribPointer_t>(dev->getGLFunction("glVertexAttribPointerARB"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_VertexAttribPointer)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_BindFramebuffer = reinterpret_cast<BindFramebuffer_t>(dev->getGLFunction("glBindFramebuffer"));
	else if (e_EXT_framebuffer_object)
		m_BindFramebuffer = reinterpret_cast<BindFramebuffer_t>(dev->getGLFunction("glBindFramebufferEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_BindFramebuffer)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_BindRenderbuffer = reinterpret_cast<BindRenderbuffer_t>(dev->getGLFunction("glBindRenderbuffer"));
	else if (e_EXT_framebuffer_object)
		m_BindRenderbuffer = reinterpret_cast<BindRenderbuffer_t>(dev->getGLFunction("glBindRenderbufferEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_BindRenderbuffer)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_CheckFramebufferStatus = reinterpret_cast<CheckFramebufferStatus_t>(dev->getGLFunction("glCheckFramebufferStatus"));
	else if (e_EXT_framebuffer_object)
		m_CheckFramebufferStatus = reinterpret_cast<CheckFramebufferStatus_t>(dev->getGLFunction("glCheckFramebufferStatusEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_CheckFramebufferStatus)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_DeleteFramebuffers = reinterpret_cast<DeleteFramebuffers_t>(dev->getGLFunction("glDeleteFramebuffers"));
	else if (e_EXT_framebuffer_object)
		m_DeleteFramebuffers = reinterpret_cast<DeleteFramebuffers_t>(dev->getGLFunction("glDeleteFramebuffersEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_DeleteFramebuffers)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_DeleteRenderbuffers = reinterpret_cast<DeleteRenderbuffers_t>(dev->getGLFunction("glDeleteRenderbuffers"));
	else if (e_EXT_framebuffer_object)
		m_DeleteRenderbuffers = reinterpret_cast<DeleteRenderbuffers_t>(dev->getGLFunction("glDeleteRenderbuffersEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_DeleteRenderbuffers)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_FramebufferRenderbuffer = reinterpret_cast<FramebufferRenderbuffer_t>(dev->getGLFunction("glFramebufferRenderbuffer"));
	else if (e_EXT_framebuffer_object)
		m_FramebufferRenderbuffer = reinterpret_cast<FramebufferRenderbuffer_t>(dev->getGLFunction("glFramebufferRenderbufferEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_FramebufferRenderbuffer)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_FramebufferTexture2D = reinterpret_cast<FramebufferTexture2D_t>(dev->getGLFunction("glFramebufferTexture2D"));
	else if (e_EXT_framebuffer_object)
		m_FramebufferTexture2D = reinterpret_cast<FramebufferTexture2D_t>(dev->getGLFunction("glFramebufferTexture2DEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_FramebufferTexture2D)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_GenFramebuffers = reinterpret_cast<GenFramebuffers_t>(dev->getGLFunction("glGenFramebuffers"));
	else if (e_EXT_framebuffer_object)
		m_GenFramebuffers = reinterpret_cast<GenFramebuffers_t>(dev->getGLFunction("glGenFramebuffersEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GenFramebuffers)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_GenRenderbuffers = reinterpret_cast<GenRenderbuffers_t>(dev->getGLFunction("glGenRenderbuffers"));
	else if (e_EXT_framebuffer_object)
		m_GenRenderbuffers = reinterpret_cast<GenRenderbuffers_t>(dev->getGLFunction("glGenRenderbuffersEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GenRenderbuffers)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_GenerateMipmap = reinterpret_cast<GenerateMipmap_t>(dev->getGLFunction("glGenerateMipmap"));
	else if (e_EXT_framebuffer_object)
		m_GenerateMipmap = reinterpret_cast<GenerateMipmap_t>(dev->getGLFunction("glGenerateMipmapEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GenerateMipmap)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_GetRenderbufferParameteriv = reinterpret_cast<GetRenderbufferParameteriv_t>(dev->getGLFunction("glGetRenderbufferParameteriv"));
	else if (e_EXT_framebuffer_object)
		m_GetRenderbufferParameteriv = reinterpret_cast<GetRenderbufferParameteriv_t>(dev->getGLFunction("glGetRenderbufferParameterivEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_GetRenderbufferParameteriv)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_RenderbufferStorage = reinterpret_cast<RenderbufferStorage_t>(dev->getGLFunction("glRenderbufferStorage"));
	else if (e_EXT_framebuffer_object)
		m_RenderbufferStorage = reinterpret_cast<RenderbufferStorage_t>(dev->getGLFunction("glRenderbufferStorageEXT"));
	else
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}
	if (!m_RenderbufferStorage)
		return OpStatus::ERR;
	if (e_ARB_framebuffer_object)
		m_BlitFramebuffer = reinterpret_cast<BlitFramebuffer_t>(dev->getGLFunction("glBlitFramebuffer"));
	else if (e_EXT_framebuffer_blit)
		m_BlitFramebuffer = reinterpret_cast<BlitFramebuffer_t>(dev->getGLFunction("glBlitFramebufferEXT"));
	else
		m_BlitFramebuffer = 0;
	if (e_ARB_framebuffer_object)
		m_RenderbufferStorageMultisample = reinterpret_cast<RenderbufferStorageMultisample_t>(dev->getGLFunction("glRenderbufferStorageMultisample"));
	else if (e_EXT_framebuffer_multisample)
		m_RenderbufferStorageMultisample = reinterpret_cast<RenderbufferStorageMultisample_t>(dev->getGLFunction("glRenderbufferStorageMultisampleEXT"));
	else
		m_RenderbufferStorageMultisample = 0;
	if (e_ARB_map_buffer_range)
		m_MapBufferRange = reinterpret_cast<MapBufferRange_t>(dev->getGLFunction("glMapBufferRange"));
	else
		m_MapBufferRange = 0;
	if (ver_major > 1 || ver_major == 1 && ver_minor >= 5)
		m_UnmapBuffer = reinterpret_cast<UnmapBuffer_t>(dev->getGLFunction("glUnmapBuffer"));
	else if (e_ARB_vertex_buffer_object)
		m_UnmapBuffer = reinterpret_cast<UnmapBuffer_t>(dev->getGLFunction("glUnmapBufferARB"));
	else
		m_UnmapBuffer = 0;
	if (e_ARB_sync)
		m_FenceSync = reinterpret_cast<FenceSync_t>(dev->getGLFunction("glFenceSync"));
	else
		m_FenceSync = 0;
	if (e_ARB_sync)
		m_GetSynciv = reinterpret_cast<GetSynciv_t>(dev->getGLFunction("glGetSynciv"));
	else
		m_GetSynciv = 0;
	if (e_ARB_sync)
		m_DeleteSync = reinterpret_cast<DeleteSync_t>(dev->getGLFunction("glDeleteSync"));
	else
		m_DeleteSync = 0;
	if (e_ARB_blend_func_extended)
		m_BindFragDataLocationIndexed = reinterpret_cast<BindFragDataLocationIndexed_t>(dev->getGLFunction("glBindFragDataLocationIndexed"));
	else
		m_BindFragDataLocationIndexed = 0;
#  ifdef VEGA_ENABLE_PERF_EVENTS
	if (e_GREMEDY_string_marker)
		m_StringMarkerGREMEDY = reinterpret_cast<StringMarkerGREMEDY_t>(dev->getGLFunction("glStringMarkerGREMEDY"));
	else
		m_StringMarkerGREMEDY = local_ignore_stringmarkergremedy;
#  endif // VEGA_ENABLE_PERF_EVENTS
#  ifdef VEGA_GL_DEBUG_CONTEXT
	if (e_ARB_debug_output)
		m_DebugMessageCallbackARB = reinterpret_cast<DebugMessageCallbackARB_t>(dev->getGLFunction("glDebugMessageCallbackARB"));
	else
		m_DebugMessageCallbackARB = 0;
#  endif // VEGA_GL_DEBUG_CONTEXT

	int shader_ver_major, shader_ver_minor;
	const char * shader_ver_string = reinterpret_cast<const char*>(m_GetString(GL_SHADING_LANGUAGE_VERSION));
	if (!shader_ver_string || op_sscanf(shader_ver_string, "%d.%d", &shader_ver_major, &shader_ver_minor) != 2)
		return OpStatus::ERR;
	if (shader_ver_major < 1 || shader_ver_major == 1 && shader_ver_minor < 20)
	{
#  ifdef VEGA_BACKENDS_USE_BLOCKLIST
		g_vega_backends_module.SetCreationStatus(UNI_L("Unsupported backend version"));
#  endif // VEGA_BACKENDS_USE_BLOCKLIST
		return OpStatus::ERR;
	}

	return OpStatus::OK;
}
# endif // VEGA_OPENGLES

# ifdef VEGA_GL_DEBUG

OpString8 VEGAGlAPI::FormatGLenum(GLenum value)
{
	OpString8 res;
	switch (value)
	{
	case 0:
		res.Set("0");
		break;
	case 1:
		res.Set("1");
		break;
	case GL_LINE_LOOP:
		res.Set("GL_LINE_LOOP");
		break;
	case GL_LINE_STRIP:
		res.Set("GL_LINE_STRIP");
		break;
	case GL_TRIANGLES:
		res.Set("GL_TRIANGLES");
		break;
	case GL_TRIANGLE_STRIP:
		res.Set("GL_TRIANGLE_STRIP");
		break;
	case GL_TRIANGLE_FAN:
		res.Set("GL_TRIANGLE_FAN");
		break;
	case GL_NEVER:
		res.Set("GL_NEVER");
		break;
	case GL_LESS:
		res.Set("GL_LESS");
		break;
	case GL_EQUAL:
		res.Set("GL_EQUAL");
		break;
	case GL_LEQUAL:
		res.Set("GL_LEQUAL");
		break;
	case GL_GREATER:
		res.Set("GL_GREATER");
		break;
	case GL_NOTEQUAL:
		res.Set("GL_NOTEQUAL");
		break;
	case GL_GEQUAL:
		res.Set("GL_GEQUAL");
		break;
	case GL_ALWAYS:
		res.Set("GL_ALWAYS");
		break;
	case GL_SRC_COLOR:
		res.Set("GL_SRC_COLOR");
		break;
	case GL_ONE_MINUS_SRC_COLOR:
		res.Set("GL_ONE_MINUS_SRC_COLOR");
		break;
	case GL_SRC_ALPHA:
		res.Set("GL_SRC_ALPHA");
		break;
	case GL_ONE_MINUS_SRC_ALPHA:
		res.Set("GL_ONE_MINUS_SRC_ALPHA");
		break;
	case GL_DST_ALPHA:
		res.Set("GL_DST_ALPHA");
		break;
	case GL_ONE_MINUS_DST_ALPHA:
		res.Set("GL_ONE_MINUS_DST_ALPHA");
		break;
	case GL_DST_COLOR:
		res.Set("GL_DST_COLOR");
		break;
	case GL_ONE_MINUS_DST_COLOR:
		res.Set("GL_ONE_MINUS_DST_COLOR");
		break;
	case GL_SRC_ALPHA_SATURATE:
		res.Set("GL_SRC_ALPHA_SATURATE");
		break;
	case GL_FRONT:
		res.Set("GL_FRONT");
		break;
	case GL_BACK:
		res.Set("GL_BACK");
		break;
	case GL_FRONT_AND_BACK:
		res.Set("GL_FRONT_AND_BACK");
		break;
	case GL_INVALID_ENUM:
		res.Set("GL_INVALID_ENUM");
		break;
	case GL_INVALID_VALUE:
		res.Set("GL_INVALID_VALUE");
		break;
	case GL_INVALID_OPERATION:
		res.Set("GL_INVALID_OPERATION");
		break;
	case GL_OUT_OF_MEMORY:
		res.Set("GL_OUT_OF_MEMORY");
		break;
	case GL_INVALID_FRAMEBUFFER_OPERATION:
		res.Set("GL_INVALID_FRAMEBUFFER_OPERATION");
		break;
	case GL_CW:
		res.Set("GL_CW");
		break;
	case GL_CCW:
		res.Set("GL_CCW");
		break;
	case GL_LINE_WIDTH:
		res.Set("GL_LINE_WIDTH");
		break;
	case GL_CULL_FACE:
		res.Set("GL_CULL_FACE");
		break;
	case GL_CULL_FACE_MODE:
		res.Set("GL_CULL_FACE_MODE");
		break;
	case GL_FRONT_FACE:
		res.Set("GL_FRONT_FACE");
		break;
	case GL_DEPTH_RANGE:
		res.Set("GL_DEPTH_RANGE");
		break;
	case GL_DEPTH_TEST:
		res.Set("GL_DEPTH_TEST");
		break;
	case GL_DEPTH_WRITEMASK:
		res.Set("GL_DEPTH_WRITEMASK");
		break;
	case GL_DEPTH_CLEAR_VALUE:
		res.Set("GL_DEPTH_CLEAR_VALUE");
		break;
	case GL_DEPTH_FUNC:
		res.Set("GL_DEPTH_FUNC");
		break;
	case GL_STENCIL_TEST:
		res.Set("GL_STENCIL_TEST");
		break;
	case GL_STENCIL_CLEAR_VALUE:
		res.Set("GL_STENCIL_CLEAR_VALUE");
		break;
	case GL_STENCIL_FUNC:
		res.Set("GL_STENCIL_FUNC");
		break;
	case GL_STENCIL_VALUE_MASK:
		res.Set("GL_STENCIL_VALUE_MASK");
		break;
	case GL_STENCIL_FAIL:
		res.Set("GL_STENCIL_FAIL");
		break;
	case GL_STENCIL_PASS_DEPTH_FAIL:
		res.Set("GL_STENCIL_PASS_DEPTH_FAIL");
		break;
	case GL_STENCIL_PASS_DEPTH_PASS:
		res.Set("GL_STENCIL_PASS_DEPTH_PASS");
		break;
	case GL_STENCIL_REF:
		res.Set("GL_STENCIL_REF");
		break;
	case GL_STENCIL_WRITEMASK:
		res.Set("GL_STENCIL_WRITEMASK");
		break;
	case GL_VIEWPORT:
		res.Set("GL_VIEWPORT");
		break;
	case GL_DITHER:
		res.Set("GL_DITHER");
		break;
	case GL_BLEND:
		res.Set("GL_BLEND");
		break;
	case GL_SCISSOR_BOX:
		res.Set("GL_SCISSOR_BOX");
		break;
	case GL_SCISSOR_TEST:
		res.Set("GL_SCISSOR_TEST");
		break;
	case GL_COLOR_CLEAR_VALUE:
		res.Set("GL_COLOR_CLEAR_VALUE");
		break;
	case GL_COLOR_WRITEMASK:
		res.Set("GL_COLOR_WRITEMASK");
		break;
	case GL_UNPACK_ALIGNMENT:
		res.Set("GL_UNPACK_ALIGNMENT");
		break;
	case GL_PACK_ALIGNMENT:
		res.Set("GL_PACK_ALIGNMENT");
		break;
	case GL_MAX_TEXTURE_SIZE:
		res.Set("GL_MAX_TEXTURE_SIZE");
		break;
	case GL_MAX_VIEWPORT_DIMS:
		res.Set("GL_MAX_VIEWPORT_DIMS");
		break;
	case GL_TEXTURE_2D:
		res.Set("GL_TEXTURE_2D");
		break;
	case GL_POLYGON_OFFSET_UNITS:
		res.Set("GL_POLYGON_OFFSET_UNITS");
		break;
	case GL_POLYGON_OFFSET_FILL:
		res.Set("GL_POLYGON_OFFSET_FILL");
		break;
	case GL_POLYGON_OFFSET_FACTOR:
		res.Set("GL_POLYGON_OFFSET_FACTOR");
		break;
	case GL_TEXTURE_BINDING_2D:
		res.Set("GL_TEXTURE_BINDING_2D");
		break;
	case GL_DONT_CARE:
		res.Set("GL_DONT_CARE");
		break;
	case GL_FASTEST:
		res.Set("GL_FASTEST");
		break;
	case GL_NICEST:
		res.Set("GL_NICEST");
		break;
	case GL_BYTE:
		res.Set("GL_BYTE");
		break;
	case GL_UNSIGNED_BYTE:
		res.Set("GL_UNSIGNED_BYTE");
		break;
	case GL_SHORT:
		res.Set("GL_SHORT");
		break;
	case GL_UNSIGNED_SHORT:
		res.Set("GL_UNSIGNED_SHORT");
		break;
	case GL_INT:
		res.Set("GL_INT");
		break;
	case GL_UNSIGNED_INT:
		res.Set("GL_UNSIGNED_INT");
		break;
	case GL_FLOAT:
		res.Set("GL_FLOAT");
		break;
	case GL_INVERT:
		res.Set("GL_INVERT");
		break;
	case GL_TEXTURE:
		res.Set("GL_TEXTURE");
		break;
	case GL_STENCIL_INDEX:
		res.Set("GL_STENCIL_INDEX");
		break;
	case GL_DEPTH_COMPONENT:
		res.Set("GL_DEPTH_COMPONENT");
		break;
	case GL_ALPHA:
		res.Set("GL_ALPHA");
		break;
	case GL_RGB:
		res.Set("GL_RGB");
		break;
	case GL_RGBA:
		res.Set("GL_RGBA");
		break;
	case GL_LUMINANCE:
		res.Set("GL_LUMINANCE");
		break;
	case GL_LUMINANCE_ALPHA:
		res.Set("GL_LUMINANCE_ALPHA");
		break;
	case GL_KEEP:
		res.Set("GL_KEEP");
		break;
	case GL_REPLACE:
		res.Set("GL_REPLACE");
		break;
	case GL_INCR:
		res.Set("GL_INCR");
		break;
	case GL_DECR:
		res.Set("GL_DECR");
		break;
	case GL_VENDOR:
		res.Set("GL_VENDOR");
		break;
	case GL_RENDERER:
		res.Set("GL_RENDERER");
		break;
	case GL_VERSION:
		res.Set("GL_VERSION");
		break;
	case GL_EXTENSIONS:
		res.Set("GL_EXTENSIONS");
		break;
	case GL_NEAREST:
		res.Set("GL_NEAREST");
		break;
	case GL_LINEAR:
		res.Set("GL_LINEAR");
		break;
	case GL_NEAREST_MIPMAP_NEAREST:
		res.Set("GL_NEAREST_MIPMAP_NEAREST");
		break;
	case GL_LINEAR_MIPMAP_NEAREST:
		res.Set("GL_LINEAR_MIPMAP_NEAREST");
		break;
	case GL_NEAREST_MIPMAP_LINEAR:
		res.Set("GL_NEAREST_MIPMAP_LINEAR");
		break;
	case GL_LINEAR_MIPMAP_LINEAR:
		res.Set("GL_LINEAR_MIPMAP_LINEAR");
		break;
	case GL_TEXTURE_MAG_FILTER:
		res.Set("GL_TEXTURE_MAG_FILTER");
		break;
	case GL_TEXTURE_MIN_FILTER:
		res.Set("GL_TEXTURE_MIN_FILTER");
		break;
	case GL_TEXTURE_WRAP_S:
		res.Set("GL_TEXTURE_WRAP_S");
		break;
	case GL_TEXTURE_WRAP_T:
		res.Set("GL_TEXTURE_WRAP_T");
		break;
	case GL_REPEAT:
		res.Set("GL_REPEAT");
		break;
	case GL_RGBA4:
		res.Set("GL_RGBA4");
		break;
	case GL_RGB5_A1:
		res.Set("GL_RGB5_A1");
		break;
	case GL_CONSTANT_COLOR:
		res.Set("GL_CONSTANT_COLOR");
		break;
	case GL_ONE_MINUS_CONSTANT_COLOR:
		res.Set("GL_ONE_MINUS_CONSTANT_COLOR");
		break;
	case GL_CONSTANT_ALPHA:
		res.Set("GL_CONSTANT_ALPHA");
		break;
	case GL_ONE_MINUS_CONSTANT_ALPHA:
		res.Set("GL_ONE_MINUS_CONSTANT_ALPHA");
		break;
	case GL_BLEND_COLOR:
		res.Set("GL_BLEND_COLOR");
		break;
	case GL_FUNC_ADD:
		res.Set("GL_FUNC_ADD");
		break;
	case GL_BLEND_EQUATION:
		res.Set("GL_BLEND_EQUATION");
		break;
	case GL_FUNC_SUBTRACT:
		res.Set("GL_FUNC_SUBTRACT");
		break;
	case GL_FUNC_REVERSE_SUBTRACT:
		res.Set("GL_FUNC_REVERSE_SUBTRACT");
		break;
	case GL_UNSIGNED_SHORT_4_4_4_4:
		res.Set("GL_UNSIGNED_SHORT_4_4_4_4");
		break;
	case GL_UNSIGNED_SHORT_5_5_5_1:
		res.Set("GL_UNSIGNED_SHORT_5_5_5_1");
		break;
	case GL_UNSIGNED_SHORT_5_6_5:
		res.Set("GL_UNSIGNED_SHORT_5_6_5");
		break;
	case GL_SAMPLE_ALPHA_TO_COVERAGE:
		res.Set("GL_SAMPLE_ALPHA_TO_COVERAGE");
		break;
	case GL_SAMPLE_COVERAGE:
		res.Set("GL_SAMPLE_COVERAGE");
		break;
	case GL_SAMPLE_BUFFERS:
		res.Set("GL_SAMPLE_BUFFERS");
		break;
	case GL_SAMPLES:
		res.Set("GL_SAMPLES");
		break;
	case GL_SAMPLE_COVERAGE_VALUE:
		res.Set("GL_SAMPLE_COVERAGE_VALUE");
		break;
	case GL_SAMPLE_COVERAGE_INVERT:
		res.Set("GL_SAMPLE_COVERAGE_INVERT");
		break;
	case GL_BLEND_DST_RGB:
		res.Set("GL_BLEND_DST_RGB");
		break;
	case GL_BLEND_SRC_RGB:
		res.Set("GL_BLEND_SRC_RGB");
		break;
	case GL_BLEND_DST_ALPHA:
		res.Set("GL_BLEND_DST_ALPHA");
		break;
	case GL_BLEND_SRC_ALPHA:
		res.Set("GL_BLEND_SRC_ALPHA");
		break;
#  ifndef VEGA_OPENGLES
	case non_gles_GL_BGRA:
		res.Set("GL_BGRA");
		break;
#  endif // !VEGA_OPENGLES
	case GL_CLAMP_TO_EDGE:
		res.Set("GL_CLAMP_TO_EDGE");
		break;
	case GL_GENERATE_MIPMAP_HINT:
		res.Set("GL_GENERATE_MIPMAP_HINT");
		break;
	case GL_DEPTH_COMPONENT16:
		res.Set("GL_DEPTH_COMPONENT16");
		break;
#  ifndef VEGA_OPENGLES
	case non_gles_GL_DEPTH_COMPONENT24:
		res.Set("GL_DEPTH_COMPONENT24");
		break;
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
	case non_gles_GL_DEPTH_STENCIL_ATTACHMENT:
		res.Set("GL_DEPTH_STENCIL_ATTACHMENT");
		break;
#  endif // !VEGA_OPENGLES
	case GL_MIRRORED_REPEAT:
		res.Set("GL_MIRRORED_REPEAT");
		break;
	case GL_ALIASED_POINT_SIZE_RANGE:
		res.Set("GL_ALIASED_POINT_SIZE_RANGE");
		break;
	case GL_ALIASED_LINE_WIDTH_RANGE:
		res.Set("GL_ALIASED_LINE_WIDTH_RANGE");
		break;
	case GL_TEXTURE0:
		res.Set("GL_TEXTURE0");
		break;
	case GL_TEXTURE1:
		res.Set("GL_TEXTURE1");
		break;
	case GL_TEXTURE2:
		res.Set("GL_TEXTURE2");
		break;
	case GL_TEXTURE3:
		res.Set("GL_TEXTURE3");
		break;
	case GL_TEXTURE4:
		res.Set("GL_TEXTURE4");
		break;
	case GL_TEXTURE5:
		res.Set("GL_TEXTURE5");
		break;
	case GL_TEXTURE6:
		res.Set("GL_TEXTURE6");
		break;
	case GL_TEXTURE7:
		res.Set("GL_TEXTURE7");
		break;
	case GL_TEXTURE8:
		res.Set("GL_TEXTURE8");
		break;
	case GL_TEXTURE9:
		res.Set("GL_TEXTURE9");
		break;
	case GL_TEXTURE10:
		res.Set("GL_TEXTURE10");
		break;
	case GL_TEXTURE11:
		res.Set("GL_TEXTURE11");
		break;
	case GL_TEXTURE12:
		res.Set("GL_TEXTURE12");
		break;
	case GL_TEXTURE13:
		res.Set("GL_TEXTURE13");
		break;
	case GL_TEXTURE14:
		res.Set("GL_TEXTURE14");
		break;
	case GL_TEXTURE15:
		res.Set("GL_TEXTURE15");
		break;
	case GL_TEXTURE16:
		res.Set("GL_TEXTURE16");
		break;
	case GL_TEXTURE17:
		res.Set("GL_TEXTURE17");
		break;
	case GL_TEXTURE18:
		res.Set("GL_TEXTURE18");
		break;
	case GL_TEXTURE19:
		res.Set("GL_TEXTURE19");
		break;
	case GL_TEXTURE20:
		res.Set("GL_TEXTURE20");
		break;
	case GL_TEXTURE21:
		res.Set("GL_TEXTURE21");
		break;
	case GL_TEXTURE22:
		res.Set("GL_TEXTURE22");
		break;
	case GL_TEXTURE23:
		res.Set("GL_TEXTURE23");
		break;
	case GL_TEXTURE24:
		res.Set("GL_TEXTURE24");
		break;
	case GL_TEXTURE25:
		res.Set("GL_TEXTURE25");
		break;
	case GL_TEXTURE26:
		res.Set("GL_TEXTURE26");
		break;
	case GL_TEXTURE27:
		res.Set("GL_TEXTURE27");
		break;
	case GL_TEXTURE28:
		res.Set("GL_TEXTURE28");
		break;
	case GL_TEXTURE29:
		res.Set("GL_TEXTURE29");
		break;
	case GL_TEXTURE30:
		res.Set("GL_TEXTURE30");
		break;
	case GL_TEXTURE31:
		res.Set("GL_TEXTURE31");
		break;
	case GL_ACTIVE_TEXTURE:
		res.Set("GL_ACTIVE_TEXTURE");
		break;
	case GL_MAX_RENDERBUFFER_SIZE:
		res.Set("GL_MAX_RENDERBUFFER_SIZE");
		break;
	case GL_INCR_WRAP:
		res.Set("GL_INCR_WRAP");
		break;
	case GL_DECR_WRAP:
		res.Set("GL_DECR_WRAP");
		break;
	case GL_TEXTURE_CUBE_MAP:
		res.Set("GL_TEXTURE_CUBE_MAP");
		break;
	case GL_TEXTURE_BINDING_CUBE_MAP:
		res.Set("GL_TEXTURE_BINDING_CUBE_MAP");
		break;
	case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
		res.Set("GL_TEXTURE_CUBE_MAP_POSITIVE_X");
		break;
	case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
		res.Set("GL_TEXTURE_CUBE_MAP_NEGATIVE_X");
		break;
	case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
		res.Set("GL_TEXTURE_CUBE_MAP_POSITIVE_Y");
		break;
	case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
		res.Set("GL_TEXTURE_CUBE_MAP_NEGATIVE_Y");
		break;
	case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
		res.Set("GL_TEXTURE_CUBE_MAP_POSITIVE_Z");
		break;
	case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
		res.Set("GL_TEXTURE_CUBE_MAP_NEGATIVE_Z");
		break;
	case GL_MAX_CUBE_MAP_TEXTURE_SIZE:
		res.Set("GL_MAX_CUBE_MAP_TEXTURE_SIZE");
		break;
#  ifndef VEGA_OPENGLES
	case non_gles_GL_SRC1_ALPHA:
		res.Set("GL_SRC1_ALPHA");
		break;
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
	case non_gles_GL_VERTEX_PROGRAM_POINT_SIZE:
		res.Set("GL_VERTEX_PROGRAM_POINT_SIZE");
		break;
#  endif // !VEGA_OPENGLES
	case GL_VERTEX_ATTRIB_ARRAY_ENABLED:
		res.Set("GL_VERTEX_ATTRIB_ARRAY_ENABLED");
		break;
	case GL_VERTEX_ATTRIB_ARRAY_SIZE:
		res.Set("GL_VERTEX_ATTRIB_ARRAY_SIZE");
		break;
	case GL_VERTEX_ATTRIB_ARRAY_STRIDE:
		res.Set("GL_VERTEX_ATTRIB_ARRAY_STRIDE");
		break;
	case GL_VERTEX_ATTRIB_ARRAY_TYPE:
		res.Set("GL_VERTEX_ATTRIB_ARRAY_TYPE");
		break;
	case GL_CURRENT_VERTEX_ATTRIB:
		res.Set("GL_CURRENT_VERTEX_ATTRIB");
		break;
	case GL_VERTEX_ATTRIB_ARRAY_POINTER:
		res.Set("GL_VERTEX_ATTRIB_ARRAY_POINTER");
		break;
	case GL_BUFFER_SIZE:
		res.Set("GL_BUFFER_SIZE");
		break;
	case GL_BUFFER_USAGE:
		res.Set("GL_BUFFER_USAGE");
		break;
	case GL_VERTEX_SHADER:
		res.Set("GL_VERTEX_SHADER");
		break;
	case GL_STENCIL_BACK_FUNC:
		res.Set("GL_STENCIL_BACK_FUNC");
		break;
	case GL_STENCIL_BACK_FAIL:
		res.Set("GL_STENCIL_BACK_FAIL");
		break;
	case GL_STENCIL_BACK_PASS_DEPTH_FAIL:
		res.Set("GL_STENCIL_BACK_PASS_DEPTH_FAIL");
		break;
	case GL_STENCIL_BACK_PASS_DEPTH_PASS:
		res.Set("GL_STENCIL_BACK_PASS_DEPTH_PASS");
		break;
	case GL_BLEND_EQUATION_ALPHA:
		res.Set("GL_BLEND_EQUATION_ALPHA");
		break;
#  ifndef VEGA_OPENGLES
	case non_gles_GL_POINT_SPRITE:
		res.Set("GL_POINT_SPRITE");
		break;
#  endif // !VEGA_OPENGLES
	case GL_MAX_VERTEX_ATTRIBS:
		res.Set("GL_MAX_VERTEX_ATTRIBS");
		break;
	case GL_VERTEX_ATTRIB_ARRAY_NORMALIZED:
		res.Set("GL_VERTEX_ATTRIB_ARRAY_NORMALIZED");
		break;
	case GL_MAX_TEXTURE_IMAGE_UNITS:
		res.Set("GL_MAX_TEXTURE_IMAGE_UNITS");
		break;
	case GL_ARRAY_BUFFER:
		res.Set("GL_ARRAY_BUFFER");
		break;
	case GL_ELEMENT_ARRAY_BUFFER:
		res.Set("GL_ELEMENT_ARRAY_BUFFER");
		break;
	case GL_ARRAY_BUFFER_BINDING:
		res.Set("GL_ARRAY_BUFFER_BINDING");
		break;
	case GL_ELEMENT_ARRAY_BUFFER_BINDING:
		res.Set("GL_ELEMENT_ARRAY_BUFFER_BINDING");
		break;
	case GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING:
		res.Set("GL_VERTEX_ATTRIB_ARRAY_BUFFER_BINDING");
		break;
	case GL_STREAM_DRAW:
		res.Set("GL_STREAM_DRAW");
		break;
	case GL_STATIC_DRAW:
		res.Set("GL_STATIC_DRAW");
		break;
	case GL_DYNAMIC_DRAW:
		res.Set("GL_DYNAMIC_DRAW");
		break;
#  ifndef VEGA_OPENGLES
	case non_gles_GL_DEPTH24_STENCIL8:
		res.Set("GL_DEPTH24_STENCIL8");
		break;
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
	case non_gles_GL_SRC1_COLOR:
		res.Set("GL_SRC1_COLOR");
		break;
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
	case non_gles_GL_ONE_MINUS_SRC1_COLOR:
		res.Set("GL_ONE_MINUS_SRC1_COLOR");
		break;
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
	case non_gles_GL_ONE_MINUS_SRC1_ALPHA:
		res.Set("GL_ONE_MINUS_SRC1_ALPHA");
		break;
#  endif // !VEGA_OPENGLES
	case GL_FRAGMENT_SHADER:
		res.Set("GL_FRAGMENT_SHADER");
		break;
#  ifndef VEGA_OPENGLES
	case non_gles_GL_MAX_FRAGMENT_UNIFORM_COMPONENTS:
		res.Set("GL_MAX_FRAGMENT_UNIFORM_COMPONENTS");
		break;
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
	case non_gles_GL_MAX_VERTEX_UNIFORM_COMPONENTS:
		res.Set("GL_MAX_VERTEX_UNIFORM_COMPONENTS");
		break;
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
	case non_gles_GL_MAX_VARYING_FLOATS:
		res.Set("GL_MAX_VARYING_FLOATS");
		break;
#  endif // !VEGA_OPENGLES
	case GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS:
		res.Set("GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS");
		break;
	case GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS:
		res.Set("GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS");
		break;
	case GL_FLOAT_VEC2:
		res.Set("GL_FLOAT_VEC2");
		break;
	case GL_FLOAT_VEC3:
		res.Set("GL_FLOAT_VEC3");
		break;
	case GL_FLOAT_VEC4:
		res.Set("GL_FLOAT_VEC4");
		break;
	case GL_INT_VEC2:
		res.Set("GL_INT_VEC2");
		break;
	case GL_INT_VEC3:
		res.Set("GL_INT_VEC3");
		break;
	case GL_INT_VEC4:
		res.Set("GL_INT_VEC4");
		break;
	case GL_BOOL:
		res.Set("GL_BOOL");
		break;
	case GL_BOOL_VEC2:
		res.Set("GL_BOOL_VEC2");
		break;
	case GL_BOOL_VEC3:
		res.Set("GL_BOOL_VEC3");
		break;
	case GL_BOOL_VEC4:
		res.Set("GL_BOOL_VEC4");
		break;
	case GL_FLOAT_MAT2:
		res.Set("GL_FLOAT_MAT2");
		break;
	case GL_FLOAT_MAT3:
		res.Set("GL_FLOAT_MAT3");
		break;
	case GL_FLOAT_MAT4:
		res.Set("GL_FLOAT_MAT4");
		break;
	case GL_SAMPLER_2D:
		res.Set("GL_SAMPLER_2D");
		break;
	case GL_SAMPLER_CUBE:
		res.Set("GL_SAMPLER_CUBE");
		break;
	case GL_DELETE_STATUS:
		res.Set("GL_DELETE_STATUS");
		break;
	case GL_COMPILE_STATUS:
		res.Set("GL_COMPILE_STATUS");
		break;
	case GL_LINK_STATUS:
		res.Set("GL_LINK_STATUS");
		break;
	case GL_VALIDATE_STATUS:
		res.Set("GL_VALIDATE_STATUS");
		break;
	case GL_INFO_LOG_LENGTH:
		res.Set("GL_INFO_LOG_LENGTH");
		break;
	case GL_ACTIVE_UNIFORMS:
		res.Set("GL_ACTIVE_UNIFORMS");
		break;
	case GL_ACTIVE_UNIFORM_MAX_LENGTH:
		res.Set("GL_ACTIVE_UNIFORM_MAX_LENGTH");
		break;
	case GL_SHADER_SOURCE_LENGTH:
		res.Set("GL_SHADER_SOURCE_LENGTH");
		break;
	case GL_ACTIVE_ATTRIBUTES:
		res.Set("GL_ACTIVE_ATTRIBUTES");
		break;
	case GL_ACTIVE_ATTRIBUTE_MAX_LENGTH:
		res.Set("GL_ACTIVE_ATTRIBUTE_MAX_LENGTH");
		break;
	case GL_SHADING_LANGUAGE_VERSION:
		res.Set("GL_SHADING_LANGUAGE_VERSION");
		break;
	case GL_FRAMEBUFFER_BINDING:
		res.Set("GL_FRAMEBUFFER_BINDING");
		break;
	case GL_RENDERBUFFER_BINDING:
		res.Set("GL_RENDERBUFFER_BINDING");
		break;
#  ifndef VEGA_OPENGLES
	case non_gles_GL_DRAW_FRAMEBUFFER:
		res.Set("GL_DRAW_FRAMEBUFFER");
		break;
#  endif // !VEGA_OPENGLES
	case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE:
		res.Set("GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE");
		break;
	case GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME:
		res.Set("GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME");
		break;
	case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL:
		res.Set("GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL");
		break;
	case GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE:
		res.Set("GL_FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE");
		break;
	case GL_FRAMEBUFFER_COMPLETE:
		res.Set("GL_FRAMEBUFFER_COMPLETE");
		break;
	case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
		res.Set("GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT");
		break;
	case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
		res.Set("GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT");
		break;
	case GL_FRAMEBUFFER_UNSUPPORTED:
		res.Set("GL_FRAMEBUFFER_UNSUPPORTED");
		break;
	case GL_COLOR_ATTACHMENT0:
		res.Set("GL_COLOR_ATTACHMENT0");
		break;
	case GL_DEPTH_ATTACHMENT:
		res.Set("GL_DEPTH_ATTACHMENT");
		break;
	case GL_STENCIL_ATTACHMENT:
		res.Set("GL_STENCIL_ATTACHMENT");
		break;
	case GL_FRAMEBUFFER:
		res.Set("GL_FRAMEBUFFER");
		break;
	case GL_RENDERBUFFER:
		res.Set("GL_RENDERBUFFER");
		break;
	case GL_RENDERBUFFER_WIDTH:
		res.Set("GL_RENDERBUFFER_WIDTH");
		break;
	case GL_RENDERBUFFER_HEIGHT:
		res.Set("GL_RENDERBUFFER_HEIGHT");
		break;
	case GL_RENDERBUFFER_INTERNAL_FORMAT:
		res.Set("GL_RENDERBUFFER_INTERNAL_FORMAT");
		break;
	case GL_STENCIL_INDEX8:
		res.Set("GL_STENCIL_INDEX8");
		break;
	case GL_RENDERBUFFER_RED_SIZE:
		res.Set("GL_RENDERBUFFER_RED_SIZE");
		break;
	case GL_RENDERBUFFER_GREEN_SIZE:
		res.Set("GL_RENDERBUFFER_GREEN_SIZE");
		break;
	case GL_RENDERBUFFER_BLUE_SIZE:
		res.Set("GL_RENDERBUFFER_BLUE_SIZE");
		break;
	case GL_RENDERBUFFER_ALPHA_SIZE:
		res.Set("GL_RENDERBUFFER_ALPHA_SIZE");
		break;
	case GL_RENDERBUFFER_DEPTH_SIZE:
		res.Set("GL_RENDERBUFFER_DEPTH_SIZE");
		break;
	case GL_RENDERBUFFER_STENCIL_SIZE:
		res.Set("GL_RENDERBUFFER_STENCIL_SIZE");
		break;
#  ifndef VEGA_OPENGLES
	case non_gles_GL_MAX_SAMPLES:
		res.Set("GL_MAX_SAMPLES");
		break;
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
	case non_gles_GL_SYNC_STATUS:
		res.Set("GL_SYNC_STATUS");
		break;
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
	case non_gles_GL_SYNC_GPU_COMMANDS_COMPLETE:
		res.Set("GL_SYNC_GPU_COMMANDS_COMPLETE");
		break;
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
	case non_gles_GL_SIGNALED:
		res.Set("GL_SIGNALED");
		break;
#  endif // !VEGA_OPENGLES
	default:
		res.AppendFormat("0x%04x", value);
	}
	return res;
}

void VEGAGlAPI::debug_BlendFunc(GLenum sfactor, GLenum dfactor)
{
	OP_NEW_DBG("glBlendFunc", "opengl");
	VEGA_GLREALSYM(BlendFunc) (sfactor, dfactor);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s) -> error %s", FormatGLenum(sfactor).CStr(), FormatGLenum(dfactor).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBlendFunc");
	}
	else
		OP_DBG(("(%s, %s)", FormatGLenum(sfactor).CStr(), FormatGLenum(dfactor).CStr()));
}
void VEGAGlAPI::debug_Clear(GLbitfield mask)
{
	OP_NEW_DBG("glClear", "opengl");
	VEGA_GLREALSYM(Clear) (mask);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%08x) -> error %s", mask, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glClear");
	}
	else
		OP_DBG(("(%08x)", mask));
}
void VEGAGlAPI::debug_ClearColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	OP_NEW_DBG("glClearColor", "opengl");
	OP_ASSERT(red >= 0. && red <= 1.);
	OP_ASSERT(green >= 0. && green <= 1.);
	OP_ASSERT(blue >= 0. && blue <= 1.);
	OP_ASSERT(alpha >= 0. && alpha <= 1.);
	VEGA_GLREALSYM(ClearColor) (red, green, blue, alpha);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%g, %g, %g, %g) -> error %s", double(red), double(green), double(blue), double(alpha), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glClearColor");
	}
	else
		OP_DBG(("(%g, %g, %g, %g)", double(red), double(green), double(blue), double(alpha)));
}
#  ifndef VEGA_OPENGLES
void VEGAGlAPI::debug_ClearDepth(GLclampd depth)
{
	OP_NEW_DBG("glClearDepth", "opengl");
	OP_ASSERT(depth >= 0. && depth <= 1.);
	VEGA_GLREALSYM(ClearDepth) (depth);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%g) -> error %s", depth, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glClearDepth");
	}
	else
		OP_DBG(("(%g)", depth));
}
#  endif // !VEGA_OPENGLES
#  ifdef VEGA_OPENGLES
void VEGAGlAPI::debug_ClearDepthf(GLclampf depth)
{
	OP_NEW_DBG("glClearDepthf", "opengl");
	OP_ASSERT(depth >= 0. && depth <= 1.);
	VEGA_GLREALSYM(ClearDepthf) (depth);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%g) -> error %s", depth, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glClearDepthf");
	}
	else
		OP_DBG(("(%g)", depth));
}
#  endif // VEGA_OPENGLES
void VEGAGlAPI::debug_ClearStencil(GLint s)
{
	OP_NEW_DBG("glClearStencil", "opengl");
	VEGA_GLREALSYM(ClearStencil) (s);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d) -> error %s", s, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glClearStencil");
	}
	else
		OP_DBG(("(%d)", s));
}
void VEGAGlAPI::debug_ColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha)
{
	OP_NEW_DBG("glColorMask", "opengl");
	VEGA_GLREALSYM(ColorMask) (red, green, blue, alpha);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, %s, %s) -> error %s", red ? "GL_TRUE" : "GL_FALSE", green ? "GL_TRUE" : "GL_FALSE", blue ? "GL_TRUE" : "GL_FALSE", alpha ? "GL_TRUE" : "GL_FALSE", FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glColorMask");
	}
	else
		OP_DBG(("(%s, %s, %s, %s)", red ? "GL_TRUE" : "GL_FALSE", green ? "GL_TRUE" : "GL_FALSE", blue ? "GL_TRUE" : "GL_FALSE", alpha ? "GL_TRUE" : "GL_FALSE"));
}
void VEGAGlAPI::debug_CullFace(GLenum mode)
{
	OP_NEW_DBG("glCullFace", "opengl");
	VEGA_GLREALSYM(CullFace) (mode);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(mode).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glCullFace");
	}
	else
		OP_DBG(("(%s)", FormatGLenum(mode).CStr()));
}
void VEGAGlAPI::debug_DepthFunc(GLenum func)
{
	OP_NEW_DBG("glDepthFunc", "opengl");
	VEGA_GLREALSYM(DepthFunc) (func);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(func).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDepthFunc");
	}
	else
		OP_DBG(("(%s)", FormatGLenum(func).CStr()));
}
void VEGAGlAPI::debug_DepthMask(GLboolean flag)
{
	OP_NEW_DBG("glDepthMask", "opengl");
	VEGA_GLREALSYM(DepthMask) (flag);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", flag ? "GL_TRUE" : "GL_FALSE", FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDepthMask");
	}
	else
		OP_DBG(("(%s)", flag ? "GL_TRUE" : "GL_FALSE"));
}
#  ifndef VEGA_OPENGLES
void VEGAGlAPI::debug_DepthRange(GLclampd near_val, GLclampd far_val)
{
	OP_NEW_DBG("glDepthRange", "opengl");
	OP_ASSERT(near_val >= 0. && near_val <= 1.);
	OP_ASSERT(far_val >= 0. && far_val <= 1.);
	VEGA_GLREALSYM(DepthRange) (near_val, far_val);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%g, %g) -> error %s", near_val, far_val, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDepthRange");
	}
	else
		OP_DBG(("(%g, %g)", near_val, far_val));
}
#  endif // !VEGA_OPENGLES
#  ifdef VEGA_OPENGLES
void VEGAGlAPI::debug_DepthRangef(GLclampf near_val, GLclampf far_val)
{
	OP_NEW_DBG("glDepthRangef", "opengl");
	OP_ASSERT(near_val >= 0. && near_val <= 1.);
	OP_ASSERT(far_val >= 0. && far_val <= 1.);
	VEGA_GLREALSYM(DepthRangef) (near_val, far_val);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%g, %g) -> error %s", near_val, far_val, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDepthRangef");
	}
	else
		OP_DBG(("(%g, %g)", near_val, far_val));
}
#  endif // VEGA_OPENGLES
void VEGAGlAPI::debug_Disable(GLenum cap)
{
	OP_NEW_DBG("glDisable", "opengl");
	VEGA_GLREALSYM(Disable) (cap);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(cap).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDisable");
	}
	else
		OP_DBG(("(%s)", FormatGLenum(cap).CStr()));
}
void VEGAGlAPI::debug_Enable(GLenum cap)
{
	OP_NEW_DBG("glEnable", "opengl");
	VEGA_GLREALSYM(Enable) (cap);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(cap).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glEnable");
	}
	else
		OP_DBG(("(%s)", FormatGLenum(cap).CStr()));
}
void VEGAGlAPI::debug_Finish()
{
	OP_NEW_DBG("glFinish", "opengl");
	VEGA_GLREALSYM(Finish) ();
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("() -> error %s", FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glFinish");
	}
	else
		OP_DBG(("()"));
}
void VEGAGlAPI::debug_Flush()
{
	OP_NEW_DBG("glFlush", "opengl");
	VEGA_GLREALSYM(Flush) ();
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("() -> error %s", FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glFlush");
	}
	else
		OP_DBG(("()"));
}
void VEGAGlAPI::debug_FrontFace(GLenum mode)
{
	OP_NEW_DBG("glFrontFace", "opengl");
	VEGA_GLREALSYM(FrontFace) (mode);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(mode).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glFrontFace");
	}
	else
		OP_DBG(("(%s)", FormatGLenum(mode).CStr()));
}
void VEGAGlAPI::debug_GetFloatv(GLenum pname, GLfloat * params)
{
	OP_NEW_DBG("glGetFloatv", "opengl");
	VEGA_GLREALSYM(GetFloatv) (pname, params);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, ?) -> error %s", FormatGLenum(pname).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetFloatv");
	}
	else
		OP_DBG(("(%s, ?)", FormatGLenum(pname).CStr()));
}
void VEGAGlAPI::debug_GetIntegerv(GLenum pname, GLint * params)
{
	OP_NEW_DBG("glGetIntegerv", "opengl");
	VEGA_GLREALSYM(GetIntegerv) (pname, params);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, ?) -> error %s", FormatGLenum(pname).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetIntegerv");
	}
	else
		OP_DBG(("(%s, ?)", FormatGLenum(pname).CStr()));
}
const GLubyte * VEGAGlAPI::debug_GetString(GLenum name)
{
	OP_NEW_DBG("glGetString", "opengl");
	const GLubyte * _return = VEGA_GLREALSYM(GetString) (name);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(name).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetString");
	}
	else
		OP_DBG(("(%s) = %p", FormatGLenum(name).CStr(), _return));
	return _return;
}
void VEGAGlAPI::debug_Hint(GLenum target, GLenum mode)
{
	OP_NEW_DBG("glHint", "opengl");
	VEGA_GLREALSYM(Hint) (target, mode);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s) -> error %s", FormatGLenum(target).CStr(), FormatGLenum(mode).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glHint");
	}
	else
		OP_DBG(("(%s, %s)", FormatGLenum(target).CStr(), FormatGLenum(mode).CStr()));
}
void VEGAGlAPI::debug_PixelStorei(GLenum pname, GLint param)
{
	OP_NEW_DBG("glPixelStorei", "opengl");
	VEGA_GLREALSYM(PixelStorei) (pname, param);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %d) -> error %s", FormatGLenum(pname).CStr(), param, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glPixelStorei");
	}
	else
		OP_DBG(("(%s, %d)", FormatGLenum(pname).CStr(), param));
}
void VEGAGlAPI::debug_ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid * pixels)
{
	OP_NEW_DBG("glReadPixels", "opengl");
	VEGA_GLREALSYM(ReadPixels) (x, y, width, height, format, type, pixels);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, %d, %d, %s, %s, %p) -> error %s", x, y, width, height, FormatGLenum(format).CStr(), FormatGLenum(type).CStr(), pixels, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glReadPixels");
	}
	else
		OP_DBG(("(%d, %d, %d, %d, %s, %s, %p)", x, y, width, height, FormatGLenum(format).CStr(), FormatGLenum(type).CStr(), pixels));
}
void VEGAGlAPI::debug_Scissor(GLint x, GLint y, GLsizei width, GLsizei height)
{
	OP_NEW_DBG("glScissor", "opengl");
	VEGA_GLREALSYM(Scissor) (x, y, width, height);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, %d, %d) -> error %s", x, y, width, height, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glScissor");
	}
	else
		OP_DBG(("(%d, %d, %d, %d)", x, y, width, height));
}
void VEGAGlAPI::debug_StencilFunc(GLenum func, GLint ref, GLuint mask)
{
	OP_NEW_DBG("glStencilFunc", "opengl");
	VEGA_GLREALSYM(StencilFunc) (func, ref, mask);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %d, %u) -> error %s", FormatGLenum(func).CStr(), ref, mask, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glStencilFunc");
	}
	else
		OP_DBG(("(%s, %d, %u)", FormatGLenum(func).CStr(), ref, mask));
}
void VEGAGlAPI::debug_StencilMask(GLuint mask)
{
	OP_NEW_DBG("glStencilMask", "opengl");
	VEGA_GLREALSYM(StencilMask) (mask);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u) -> error %s", mask, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glStencilMask");
	}
	else
		OP_DBG(("(%u)", mask));
}
void VEGAGlAPI::debug_StencilOp(GLenum fail, GLenum zfail, GLenum zpass)
{
	OP_NEW_DBG("glStencilOp", "opengl");
	VEGA_GLREALSYM(StencilOp) (fail, zfail, zpass);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, %s) -> error %s", FormatGLenum(fail).CStr(), FormatGLenum(zfail).CStr(), FormatGLenum(zpass).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glStencilOp");
	}
	else
		OP_DBG(("(%s, %s, %s)", FormatGLenum(fail).CStr(), FormatGLenum(zfail).CStr(), FormatGLenum(zpass).CStr()));
}
void VEGAGlAPI::debug_GetTexParameteriv(GLenum target, GLenum pname, GLint * params)
{
	OP_NEW_DBG("glGetTexParameteriv", "opengl");
	VEGA_GLREALSYM(GetTexParameteriv) (target, pname, params);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, ?) -> error %s", FormatGLenum(target).CStr(), FormatGLenum(pname).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetTexParameteriv");
	}
	else
		OP_DBG(("(%s, %s, ?)", FormatGLenum(target).CStr(), FormatGLenum(pname).CStr()));
}
void VEGAGlAPI::debug_TexParameteri(GLenum target, GLenum pname, GLint param)
{
	OP_NEW_DBG("glTexParameteri", "opengl");
	VEGA_GLREALSYM(TexParameteri) (target, pname, param);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, %d) -> error %s", FormatGLenum(target).CStr(), FormatGLenum(pname).CStr(), param, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glTexParameteri");
	}
	else
		OP_DBG(("(%s, %s, %d)", FormatGLenum(target).CStr(), FormatGLenum(pname).CStr(), param));
}
void VEGAGlAPI::debug_Viewport(GLint x, GLint y, GLsizei width, GLsizei height)
{
	OP_NEW_DBG("glViewport", "opengl");
	VEGA_GLREALSYM(Viewport) (x, y, width, height);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, %d, %d) -> error %s", x, y, width, height, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glViewport");
	}
	else
		OP_DBG(("(%d, %d, %d, %d)", x, y, width, height));
}
void VEGAGlAPI::debug_BindTexture(GLenum target, GLuint texture)
{
	OP_NEW_DBG("glBindTexture", "opengl");
	VEGA_GLREALSYM(BindTexture) (target, texture);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %u) -> error %s", FormatGLenum(target).CStr(), texture, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBindTexture");
	}
	else
		OP_DBG(("(%s, %u)", FormatGLenum(target).CStr(), texture));
}
void VEGAGlAPI::debug_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height)
{
	OP_NEW_DBG("glCopyTexSubImage2D", "opengl");
	VEGA_GLREALSYM(CopyTexSubImage2D) (target, level, xoffset, yoffset, x, y, width, height);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %d, %d, %d, %d, %d, %d, %d) -> error %s", FormatGLenum(target).CStr(), level, xoffset, yoffset, x, y, width, height, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glCopyTexSubImage2D");
	}
	else
		OP_DBG(("(%s, %d, %d, %d, %d, %d, %d, %d)", FormatGLenum(target).CStr(), level, xoffset, yoffset, x, y, width, height));
}
void VEGAGlAPI::debug_DeleteTextures(GLsizei n, const GLuint * textures)
{
	OP_NEW_DBG("glDeleteTextures", "opengl");
	VEGA_GLREALSYM(DeleteTextures) (n, textures);
	GLenum _error = glGetError();
	char _str_textures[50];
	_str_textures[0] = 0;
	if (textures)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < n && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_textures + _snoffs, 50 - _snoffs, " %u", textures[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, [%s]) -> error %s", n, _str_textures, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDeleteTextures");
	}
	else
		OP_DBG(("(%d, [%s])", n, _str_textures));
}
void VEGAGlAPI::debug_DrawArrays(GLenum mode, GLint first, GLsizei count)
{
	OP_NEW_DBG("glDrawArrays", "opengl");
	VEGA_GLREALSYM(DrawArrays) (mode, first, count);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %d, %d) -> error %s", FormatGLenum(mode).CStr(), first, count, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDrawArrays");
	}
	else
		OP_DBG(("(%s, %d, %d)", FormatGLenum(mode).CStr(), first, count));
}
void VEGAGlAPI::debug_DrawElements(GLenum mode, GLsizei count, GLenum type, const GLvoid * indices)
{
	OP_NEW_DBG("glDrawElements", "opengl");
	VEGA_GLREALSYM(DrawElements) (mode, count, type, indices);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %d, %s, %p) -> error %s", FormatGLenum(mode).CStr(), count, FormatGLenum(type).CStr(), indices, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDrawElements");
	}
	else
		OP_DBG(("(%s, %d, %s, %p)", FormatGLenum(mode).CStr(), count, FormatGLenum(type).CStr(), indices));
}
void VEGAGlAPI::debug_GenTextures(GLsizei n, GLuint * textures)
{
	OP_NEW_DBG("glGenTextures", "opengl");
	VEGA_GLREALSYM(GenTextures) (n, textures);
	GLenum _error = glGetError();
	char _str_textures[50];
	_str_textures[0] = 0;
	if (textures)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < n && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_textures + _snoffs, 50 - _snoffs, " %u", textures[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, [%s]) -> error %s", n, _str_textures, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGenTextures");
	}
	else
		OP_DBG(("(%d, [%s])", n, _str_textures));
}
void VEGAGlAPI::debug_PolygonOffset(GLfloat factor, GLfloat units)
{
	OP_NEW_DBG("glPolygonOffset", "opengl");
	VEGA_GLREALSYM(PolygonOffset) (factor, units);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%g, %g) -> error %s", double(factor), double(units), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glPolygonOffset");
	}
	else
		OP_DBG(("(%g, %g)", double(factor), double(units)));
}
void VEGAGlAPI::debug_TexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid * pixels)
{
	OP_NEW_DBG("glTexImage2D", "opengl");
	VEGA_GLREALSYM(TexImage2D) (target, level, internalformat, width, height, border, format, type, pixels);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %d, %d, %d, %d, %d, %s, %s, %p) -> error %s", FormatGLenum(target).CStr(), level, internalformat, width, height, border, FormatGLenum(format).CStr(), FormatGLenum(type).CStr(), pixels, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glTexImage2D");
	}
	else
		OP_DBG(("(%s, %d, %d, %d, %d, %d, %s, %s, %p)", FormatGLenum(target).CStr(), level, internalformat, width, height, border, FormatGLenum(format).CStr(), FormatGLenum(type).CStr(), pixels));
}
void VEGAGlAPI::debug_TexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid * pixels)
{
	OP_NEW_DBG("glTexSubImage2D", "opengl");
	VEGA_GLREALSYM(TexSubImage2D) (target, level, xoffset, yoffset, width, height, format, type, pixels);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %d, %d, %d, %d, %d, %s, %s, %p) -> error %s", FormatGLenum(target).CStr(), level, xoffset, yoffset, width, height, FormatGLenum(format).CStr(), FormatGLenum(type).CStr(), pixels, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glTexSubImage2D");
	}
	else
		OP_DBG(("(%s, %d, %d, %d, %d, %d, %s, %s, %p)", FormatGLenum(target).CStr(), level, xoffset, yoffset, width, height, FormatGLenum(format).CStr(), FormatGLenum(type).CStr(), pixels));
}
void VEGAGlAPI::debug_BlendColor(GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha)
{
	OP_NEW_DBG("glBlendColor", "opengl");
	OP_ASSERT(red >= 0. && red <= 1.);
	OP_ASSERT(green >= 0. && green <= 1.);
	OP_ASSERT(blue >= 0. && blue <= 1.);
	OP_ASSERT(alpha >= 0. && alpha <= 1.);
	VEGA_GLREALSYM(BlendColor) (red, green, blue, alpha);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%g, %g, %g, %g) -> error %s", double(red), double(green), double(blue), double(alpha), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBlendColor");
	}
	else
		OP_DBG(("(%g, %g, %g, %g)", double(red), double(green), double(blue), double(alpha)));
}
void VEGAGlAPI::debug_BlendEquation(GLenum mode)
{
	OP_NEW_DBG("glBlendEquation", "opengl");
	VEGA_GLREALSYM(BlendEquation) (mode);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(mode).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBlendEquation");
	}
	else
		OP_DBG(("(%s)", FormatGLenum(mode).CStr()));
}
void VEGAGlAPI::debug_ActiveTexture(GLenum texture)
{
	OP_NEW_DBG("glActiveTexture", "opengl");
	VEGA_GLREALSYM(ActiveTexture) (texture);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(texture).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glActiveTexture");
	}
	else
		OP_DBG(("(%s)", FormatGLenum(texture).CStr()));
}
void VEGAGlAPI::debug_BlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha)
{
	OP_NEW_DBG("glBlendFuncSeparate", "opengl");
	VEGA_GLREALSYM(BlendFuncSeparate) (sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, %s, %s) -> error %s", FormatGLenum(sfactorRGB).CStr(), FormatGLenum(dfactorRGB).CStr(), FormatGLenum(sfactorAlpha).CStr(), FormatGLenum(dfactorAlpha).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBlendFuncSeparate");
	}
	else
		OP_DBG(("(%s, %s, %s, %s)", FormatGLenum(sfactorRGB).CStr(), FormatGLenum(dfactorRGB).CStr(), FormatGLenum(sfactorAlpha).CStr(), FormatGLenum(dfactorAlpha).CStr()));
}
void VEGAGlAPI::debug_BindBuffer(GLenum target, GLuint buffer)
{
	OP_NEW_DBG("glBindBuffer", "opengl");
	VEGA_GLREALSYM(BindBuffer) (target, buffer);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %u) -> error %s", FormatGLenum(target).CStr(), buffer, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBindBuffer");
	}
	else
		OP_DBG(("(%s, %u)", FormatGLenum(target).CStr(), buffer));
}
void VEGAGlAPI::debug_BufferData(GLenum target, GLsizeiptr size, const GLvoid * data, GLenum usage)
{
	OP_NEW_DBG("glBufferData", "opengl");
	VEGA_GLREALSYM(BufferData) (target, size, data, usage);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %ld, %p, %s) -> error %s", FormatGLenum(target).CStr(), long(size), data, FormatGLenum(usage).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBufferData");
	}
	else
		OP_DBG(("(%s, %ld, %p, %s)", FormatGLenum(target).CStr(), long(size), data, FormatGLenum(usage).CStr()));
}
void VEGAGlAPI::debug_BufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid * data)
{
	OP_NEW_DBG("glBufferSubData", "opengl");
	VEGA_GLREALSYM(BufferSubData) (target, offset, size, data);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %ld, %ld, %p) -> error %s", FormatGLenum(target).CStr(), long(offset), long(size), data, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBufferSubData");
	}
	else
		OP_DBG(("(%s, %ld, %ld, %p)", FormatGLenum(target).CStr(), long(offset), long(size), data));
}
void VEGAGlAPI::debug_DeleteBuffers(GLsizei n, const GLuint * buffers)
{
	OP_NEW_DBG("glDeleteBuffers", "opengl");
	VEGA_GLREALSYM(DeleteBuffers) (n, buffers);
	GLenum _error = glGetError();
	char _str_buffers[50];
	_str_buffers[0] = 0;
	if (buffers)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < n && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_buffers + _snoffs, 50 - _snoffs, " %u", buffers[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, [%s]) -> error %s", n, _str_buffers, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDeleteBuffers");
	}
	else
		OP_DBG(("(%d, [%s])", n, _str_buffers));
}
void VEGAGlAPI::debug_GenBuffers(GLsizei n, GLuint * buffers)
{
	OP_NEW_DBG("glGenBuffers", "opengl");
	VEGA_GLREALSYM(GenBuffers) (n, buffers);
	GLenum _error = glGetError();
	char _str_buffers[50];
	_str_buffers[0] = 0;
	if (buffers)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < n && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_buffers + _snoffs, 50 - _snoffs, " %u", buffers[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, [%s]) -> error %s", n, _str_buffers, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGenBuffers");
	}
	else
		OP_DBG(("(%d, [%s])", n, _str_buffers));
}
void VEGAGlAPI::debug_AttachShader(GLuint program, GLuint shader)
{
	OP_NEW_DBG("glAttachShader", "opengl");
	VEGA_GLREALSYM(AttachShader) (program, shader);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %u) -> error %s", program, shader, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glAttachShader");
	}
	else
		OP_DBG(("(%u, %u)", program, shader));
}
void VEGAGlAPI::debug_BindAttribLocation(GLuint program, GLuint index, const GLchar * name)
{
	OP_NEW_DBG("glBindAttribLocation", "opengl");
	VEGA_GLREALSYM(BindAttribLocation) (program, index, name);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %u, ?) -> error %s", program, index, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBindAttribLocation");
	}
	else
		OP_DBG(("(%u, %u, ?)", program, index));
}
void VEGAGlAPI::debug_BlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha)
{
	OP_NEW_DBG("glBlendEquationSeparate", "opengl");
	VEGA_GLREALSYM(BlendEquationSeparate) (modeRGB, modeAlpha);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s) -> error %s", FormatGLenum(modeRGB).CStr(), FormatGLenum(modeAlpha).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBlendEquationSeparate");
	}
	else
		OP_DBG(("(%s, %s)", FormatGLenum(modeRGB).CStr(), FormatGLenum(modeAlpha).CStr()));
}
void VEGAGlAPI::debug_CompileShader(GLuint shader)
{
	OP_NEW_DBG("glCompileShader", "opengl");
	VEGA_GLREALSYM(CompileShader) (shader);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u) -> error %s", shader, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glCompileShader");
	}
	else
		OP_DBG(("(%u)", shader));
}
GLuint VEGAGlAPI::debug_CreateProgram()
{
	OP_NEW_DBG("glCreateProgram", "opengl");
	GLuint _return = VEGA_GLREALSYM(CreateProgram) ();
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("() -> error %s", FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glCreateProgram");
	}
	else
		OP_DBG(("() = %u", _return));
	return _return;
}
GLuint VEGAGlAPI::debug_CreateShader(GLenum type)
{
	OP_NEW_DBG("glCreateShader", "opengl");
	GLuint _return = VEGA_GLREALSYM(CreateShader) (type);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(type).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glCreateShader");
	}
	else
		OP_DBG(("(%s) = %u", FormatGLenum(type).CStr(), _return));
	return _return;
}
void VEGAGlAPI::debug_DeleteProgram(GLuint program)
{
	OP_NEW_DBG("glDeleteProgram", "opengl");
	VEGA_GLREALSYM(DeleteProgram) (program);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u) -> error %s", program, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDeleteProgram");
	}
	else
		OP_DBG(("(%u)", program));
}
void VEGAGlAPI::debug_DeleteShader(GLuint shader)
{
	OP_NEW_DBG("glDeleteShader", "opengl");
	VEGA_GLREALSYM(DeleteShader) (shader);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u) -> error %s", shader, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDeleteShader");
	}
	else
		OP_DBG(("(%u)", shader));
}
void VEGAGlAPI::debug_DetachShader(GLuint program, GLuint shader)
{
	OP_NEW_DBG("glDetachShader", "opengl");
	VEGA_GLREALSYM(DetachShader) (program, shader);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %u) -> error %s", program, shader, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDetachShader");
	}
	else
		OP_DBG(("(%u, %u)", program, shader));
}
void VEGAGlAPI::debug_DisableVertexAttribArray(GLuint index)
{
	OP_NEW_DBG("glDisableVertexAttribArray", "opengl");
	VEGA_GLREALSYM(DisableVertexAttribArray) (index);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u) -> error %s", index, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDisableVertexAttribArray");
	}
	else
		OP_DBG(("(%u)", index));
}
void VEGAGlAPI::debug_EnableVertexAttribArray(GLuint index)
{
	OP_NEW_DBG("glEnableVertexAttribArray", "opengl");
	VEGA_GLREALSYM(EnableVertexAttribArray) (index);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u) -> error %s", index, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glEnableVertexAttribArray");
	}
	else
		OP_DBG(("(%u)", index));
}
void VEGAGlAPI::debug_GetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
{
	OP_NEW_DBG("glGetActiveAttrib", "opengl");
	VEGA_GLREALSYM(GetActiveAttrib) (program, index, bufSize, length, size, type, name);
	GLenum _error = glGetError();
	char _str_length[50];
	_str_length[0] = 0;
	if (length)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_length + _snoffs, 50 - _snoffs, " %d", length[_i]);
	}
	char _str_size[50];
	_str_size[0] = 0;
	if (size)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_size + _snoffs, 50 - _snoffs, " %d", size[_i]);
	}
	char _str_type[50];
	_str_type[0] = 0;
	if (type)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_type + _snoffs, 50 - _snoffs, " %s", FormatGLenum(type[_i]).CStr());
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %u, %d, [%s], [%s], [%s], ?) -> error %s", program, index, bufSize, _str_length, _str_size, _str_type, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetActiveAttrib");
	}
	else
		OP_DBG(("(%u, %u, %d, [%s], [%s], [%s], ?)", program, index, bufSize, _str_length, _str_size, _str_type));
}
void VEGAGlAPI::debug_GetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLint * size, GLenum * type, GLchar * name)
{
	OP_NEW_DBG("glGetActiveUniform", "opengl");
	VEGA_GLREALSYM(GetActiveUniform) (program, index, bufSize, length, size, type, name);
	GLenum _error = glGetError();
	char _str_length[50];
	_str_length[0] = 0;
	if (length)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_length + _snoffs, 50 - _snoffs, " %d", length[_i]);
	}
	char _str_size[50];
	_str_size[0] = 0;
	if (size)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_size + _snoffs, 50 - _snoffs, " %d", size[_i]);
	}
	char _str_type[50];
	_str_type[0] = 0;
	if (type)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_type + _snoffs, 50 - _snoffs, " %s", FormatGLenum(type[_i]).CStr());
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %u, %d, [%s], [%s], [%s], ?) -> error %s", program, index, bufSize, _str_length, _str_size, _str_type, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetActiveUniform");
	}
	else
		OP_DBG(("(%u, %u, %d, [%s], [%s], [%s], ?)", program, index, bufSize, _str_length, _str_size, _str_type));
}
GLint VEGAGlAPI::debug_GetAttribLocation(GLuint program, const GLchar * name)
{
	OP_NEW_DBG("glGetAttribLocation", "opengl");
	GLint _return = VEGA_GLREALSYM(GetAttribLocation) (program, name);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, ?) -> error %s", program, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetAttribLocation");
	}
	else
		OP_DBG(("(%u, ?) = %d", program, _return));
	return _return;
}
void VEGAGlAPI::debug_GetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
	OP_NEW_DBG("glGetProgramInfoLog", "opengl");
	VEGA_GLREALSYM(GetProgramInfoLog) (program, bufSize, length, infoLog);
	GLenum _error = glGetError();
	char _str_length[50];
	_str_length[0] = 0;
	if (length)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_length + _snoffs, 50 - _snoffs, " %d", length[_i]);
	}
	char _str_infoLog[50];
	_str_infoLog[0] = 0;
	if (!length)
	{
		_str_infoLog[0] = '?';
		_str_infoLog[1] = 0;
	}
	else if (infoLog)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < *length && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_infoLog + _snoffs, 50 - _snoffs, " '%c'", infoLog[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %d, [%s], [%s]) -> error %s", program, bufSize, _str_length, _str_infoLog, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetProgramInfoLog");
	}
	else
		OP_DBG(("(%u, %d, [%s], [%s])", program, bufSize, _str_length, _str_infoLog));
}
void VEGAGlAPI::debug_GetProgramiv(GLuint program, GLenum pname, GLint * params)
{
	OP_NEW_DBG("glGetProgramiv", "opengl");
	VEGA_GLREALSYM(GetProgramiv) (program, pname, params);
	GLenum _error = glGetError();
	char _str_params[50];
	_str_params[0] = 0;
	if (params)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < pname && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_params + _snoffs, 50 - _snoffs, " %d", params[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %s, [%s]) -> error %s", program, FormatGLenum(pname).CStr(), _str_params, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetProgramiv");
	}
	else
		OP_DBG(("(%u, %s, [%s])", program, FormatGLenum(pname).CStr(), _str_params));
}
void VEGAGlAPI::debug_GetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei * length, GLchar * infoLog)
{
	OP_NEW_DBG("glGetShaderInfoLog", "opengl");
	VEGA_GLREALSYM(GetShaderInfoLog) (shader, bufSize, length, infoLog);
	GLenum _error = glGetError();
	char _str_length[50];
	_str_length[0] = 0;
	if (length)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_length + _snoffs, 50 - _snoffs, " %d", length[_i]);
	}
	char _str_infoLog[50];
	_str_infoLog[0] = 0;
	if (!length)
	{
		_str_infoLog[0] = '?';
		_str_infoLog[1] = 0;
	}
	else if (infoLog)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < *length && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_infoLog + _snoffs, 50 - _snoffs, " '%c'", infoLog[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %d, [%s], [%s]) -> error %s", shader, bufSize, _str_length, _str_infoLog, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetShaderInfoLog");
	}
	else
		OP_DBG(("(%u, %d, [%s], [%s])", shader, bufSize, _str_length, _str_infoLog));
}
void VEGAGlAPI::debug_GetShaderiv(GLuint shader, GLenum pname, GLint * params)
{
	OP_NEW_DBG("glGetShaderiv", "opengl");
	VEGA_GLREALSYM(GetShaderiv) (shader, pname, params);
	GLenum _error = glGetError();
	char _str_params[50];
	_str_params[0] = 0;
	if (params)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < pname && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_params + _snoffs, 50 - _snoffs, " %d", params[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %s, [%s]) -> error %s", shader, FormatGLenum(pname).CStr(), _str_params, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetShaderiv");
	}
	else
		OP_DBG(("(%u, %s, [%s])", shader, FormatGLenum(pname).CStr(), _str_params));
}
GLint VEGAGlAPI::debug_GetUniformLocation(GLuint program, const GLchar * name)
{
	OP_NEW_DBG("glGetUniformLocation", "opengl");
	GLint _return = VEGA_GLREALSYM(GetUniformLocation) (program, name);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, ?) -> error %s", program, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetUniformLocation");
	}
	else
		OP_DBG(("(%u, ?) = %d", program, _return));
	return _return;
}
void VEGAGlAPI::debug_GetUniformfv(GLuint program, GLint location, GLfloat * params)
{
	OP_NEW_DBG("glGetUniformfv", "opengl");
	VEGA_GLREALSYM(GetUniformfv) (program, location, params);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %d, ?) -> error %s", program, location, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetUniformfv");
	}
	else
		OP_DBG(("(%u, %d, ?)", program, location));
}
void VEGAGlAPI::debug_GetUniformiv(GLuint program, GLint location, GLint * params)
{
	OP_NEW_DBG("glGetUniformiv", "opengl");
	VEGA_GLREALSYM(GetUniformiv) (program, location, params);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %d, ?) -> error %s", program, location, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetUniformiv");
	}
	else
		OP_DBG(("(%u, %d, ?)", program, location));
}
void VEGAGlAPI::debug_LinkProgram(GLuint program)
{
	OP_NEW_DBG("glLinkProgram", "opengl");
	VEGA_GLREALSYM(LinkProgram) (program);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u) -> error %s", program, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glLinkProgram");
	}
	else
		OP_DBG(("(%u)", program));
}
void VEGAGlAPI::debug_ShaderSource(GLuint shader, GLsizei count, const GLchar* * string, const GLint * length)
{
	OP_NEW_DBG("glShaderSource", "opengl");
	VEGA_GLREALSYM(ShaderSource) (shader, count, string, length);
	GLenum _error = glGetError();
	char _str_string[50];
	_str_string[0] = 0;
	if (string)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_string + _snoffs, 50 - _snoffs, " \"%s\"", string[_i]);
	}
	char _str_length[50];
	_str_length[0] = 0;
	if (length)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_length + _snoffs, 50 - _snoffs, " %d", length[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %d, [%s], [%s]) -> error %s", shader, count, _str_string, _str_length, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glShaderSource");
	}
	else
		OP_DBG(("(%u, %d, [%s], [%s])", shader, count, _str_string, _str_length));
}
void VEGAGlAPI::debug_StencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask)
{
	OP_NEW_DBG("glStencilFuncSeparate", "opengl");
	VEGA_GLREALSYM(StencilFuncSeparate) (face, func, ref, mask);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, %d, %u) -> error %s", FormatGLenum(face).CStr(), FormatGLenum(func).CStr(), ref, mask, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glStencilFuncSeparate");
	}
	else
		OP_DBG(("(%s, %s, %d, %u)", FormatGLenum(face).CStr(), FormatGLenum(func).CStr(), ref, mask));
}
void VEGAGlAPI::debug_StencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass)
{
	OP_NEW_DBG("glStencilOpSeparate", "opengl");
	VEGA_GLREALSYM(StencilOpSeparate) (face, sfail, dpfail, dppass);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, %s, %s) -> error %s", FormatGLenum(face).CStr(), FormatGLenum(sfail).CStr(), FormatGLenum(dpfail).CStr(), FormatGLenum(dppass).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glStencilOpSeparate");
	}
	else
		OP_DBG(("(%s, %s, %s, %s)", FormatGLenum(face).CStr(), FormatGLenum(sfail).CStr(), FormatGLenum(dpfail).CStr(), FormatGLenum(dppass).CStr()));
}
void VEGAGlAPI::debug_Uniform1f(GLint location, GLfloat v0)
{
	OP_NEW_DBG("glUniform1f", "opengl");
	VEGA_GLREALSYM(Uniform1f) (location, v0);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %g) -> error %s", location, double(v0), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform1f");
	}
	else
		OP_DBG(("(%d, %g)", location, double(v0)));
}
void VEGAGlAPI::debug_Uniform1fv(GLint location, GLsizei count, const GLfloat * value)
{
	OP_NEW_DBG("glUniform1fv", "opengl");
	VEGA_GLREALSYM(Uniform1fv) (location, count, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %g", double(value[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, [%s]) -> error %s", location, count, _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform1fv");
	}
	else
		OP_DBG(("(%d, %d, [%s])", location, count, _str_value));
}
void VEGAGlAPI::debug_Uniform1i(GLint location, GLint v0)
{
	OP_NEW_DBG("glUniform1i", "opengl");
	VEGA_GLREALSYM(Uniform1i) (location, v0);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d) -> error %s", location, v0, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform1i");
	}
	else
		OP_DBG(("(%d, %d)", location, v0));
}
void VEGAGlAPI::debug_Uniform1iv(GLint location, GLsizei count, const GLint * value)
{
	OP_NEW_DBG("glUniform1iv", "opengl");
	VEGA_GLREALSYM(Uniform1iv) (location, count, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %d", value[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, [%s]) -> error %s", location, count, _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform1iv");
	}
	else
		OP_DBG(("(%d, %d, [%s])", location, count, _str_value));
}
void VEGAGlAPI::debug_Uniform2f(GLint location, GLfloat v0, GLfloat v1)
{
	OP_NEW_DBG("glUniform2f", "opengl");
	VEGA_GLREALSYM(Uniform2f) (location, v0, v1);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %g, %g) -> error %s", location, double(v0), double(v1), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform2f");
	}
	else
		OP_DBG(("(%d, %g, %g)", location, double(v0), double(v1)));
}
void VEGAGlAPI::debug_Uniform2fv(GLint location, GLsizei count, const GLfloat * value)
{
	OP_NEW_DBG("glUniform2fv", "opengl");
	VEGA_GLREALSYM(Uniform2fv) (location, count, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %g", double(value[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, [%s]) -> error %s", location, count, _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform2fv");
	}
	else
		OP_DBG(("(%d, %d, [%s])", location, count, _str_value));
}
void VEGAGlAPI::debug_Uniform2i(GLint location, GLint v0, GLint v1)
{
	OP_NEW_DBG("glUniform2i", "opengl");
	VEGA_GLREALSYM(Uniform2i) (location, v0, v1);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, %d) -> error %s", location, v0, v1, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform2i");
	}
	else
		OP_DBG(("(%d, %d, %d)", location, v0, v1));
}
void VEGAGlAPI::debug_Uniform2iv(GLint location, GLsizei count, const GLint * value)
{
	OP_NEW_DBG("glUniform2iv", "opengl");
	VEGA_GLREALSYM(Uniform2iv) (location, count, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %d", value[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, [%s]) -> error %s", location, count, _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform2iv");
	}
	else
		OP_DBG(("(%d, %d, [%s])", location, count, _str_value));
}
void VEGAGlAPI::debug_Uniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2)
{
	OP_NEW_DBG("glUniform3f", "opengl");
	VEGA_GLREALSYM(Uniform3f) (location, v0, v1, v2);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %g, %g, %g) -> error %s", location, double(v0), double(v1), double(v2), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform3f");
	}
	else
		OP_DBG(("(%d, %g, %g, %g)", location, double(v0), double(v1), double(v2)));
}
void VEGAGlAPI::debug_Uniform3fv(GLint location, GLsizei count, const GLfloat * value)
{
	OP_NEW_DBG("glUniform3fv", "opengl");
	VEGA_GLREALSYM(Uniform3fv) (location, count, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %g", double(value[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, [%s]) -> error %s", location, count, _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform3fv");
	}
	else
		OP_DBG(("(%d, %d, [%s])", location, count, _str_value));
}
void VEGAGlAPI::debug_Uniform3i(GLint location, GLint v0, GLint v1, GLint v2)
{
	OP_NEW_DBG("glUniform3i", "opengl");
	VEGA_GLREALSYM(Uniform3i) (location, v0, v1, v2);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, %d, %d) -> error %s", location, v0, v1, v2, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform3i");
	}
	else
		OP_DBG(("(%d, %d, %d, %d)", location, v0, v1, v2));
}
void VEGAGlAPI::debug_Uniform3iv(GLint location, GLsizei count, const GLint * value)
{
	OP_NEW_DBG("glUniform3iv", "opengl");
	VEGA_GLREALSYM(Uniform3iv) (location, count, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %d", value[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, [%s]) -> error %s", location, count, _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform3iv");
	}
	else
		OP_DBG(("(%d, %d, [%s])", location, count, _str_value));
}
void VEGAGlAPI::debug_Uniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)
{
	OP_NEW_DBG("glUniform4f", "opengl");
	VEGA_GLREALSYM(Uniform4f) (location, v0, v1, v2, v3);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %g, %g, %g, %g) -> error %s", location, double(v0), double(v1), double(v2), double(v3), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform4f");
	}
	else
		OP_DBG(("(%d, %g, %g, %g, %g)", location, double(v0), double(v1), double(v2), double(v3)));
}
void VEGAGlAPI::debug_Uniform4fv(GLint location, GLsizei count, const GLfloat * value)
{
	OP_NEW_DBG("glUniform4fv", "opengl");
	VEGA_GLREALSYM(Uniform4fv) (location, count, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %g", double(value[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, [%s]) -> error %s", location, count, _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform4fv");
	}
	else
		OP_DBG(("(%d, %d, [%s])", location, count, _str_value));
}
void VEGAGlAPI::debug_Uniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3)
{
	OP_NEW_DBG("glUniform4i", "opengl");
	VEGA_GLREALSYM(Uniform4i) (location, v0, v1, v2, v3);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, %d, %d, %d) -> error %s", location, v0, v1, v2, v3, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform4i");
	}
	else
		OP_DBG(("(%d, %d, %d, %d, %d)", location, v0, v1, v2, v3));
}
void VEGAGlAPI::debug_Uniform4iv(GLint location, GLsizei count, const GLint * value)
{
	OP_NEW_DBG("glUniform4iv", "opengl");
	VEGA_GLREALSYM(Uniform4iv) (location, count, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %d", value[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, [%s]) -> error %s", location, count, _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniform4iv");
	}
	else
		OP_DBG(("(%d, %d, [%s])", location, count, _str_value));
}
void VEGAGlAPI::debug_UniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	OP_NEW_DBG("glUniformMatrix2fv", "opengl");
	VEGA_GLREALSYM(UniformMatrix2fv) (location, count, transpose, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %g", double(value[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, %s, [%s]) -> error %s", location, count, transpose ? "GL_TRUE" : "GL_FALSE", _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniformMatrix2fv");
	}
	else
		OP_DBG(("(%d, %d, %s, [%s])", location, count, transpose ? "GL_TRUE" : "GL_FALSE", _str_value));
}
void VEGAGlAPI::debug_UniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	OP_NEW_DBG("glUniformMatrix3fv", "opengl");
	VEGA_GLREALSYM(UniformMatrix3fv) (location, count, transpose, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %g", double(value[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, %s, [%s]) -> error %s", location, count, transpose ? "GL_TRUE" : "GL_FALSE", _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniformMatrix3fv");
	}
	else
		OP_DBG(("(%d, %d, %s, [%s])", location, count, transpose ? "GL_TRUE" : "GL_FALSE", _str_value));
}
void VEGAGlAPI::debug_UniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat * value)
{
	OP_NEW_DBG("glUniformMatrix4fv", "opengl");
	VEGA_GLREALSYM(UniformMatrix4fv) (location, count, transpose, value);
	GLenum _error = glGetError();
	char _str_value[50];
	_str_value[0] = 0;
	if (value)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < count && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_value + _snoffs, 50 - _snoffs, " %g", double(value[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, %s, [%s]) -> error %s", location, count, transpose ? "GL_TRUE" : "GL_FALSE", _str_value, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUniformMatrix4fv");
	}
	else
		OP_DBG(("(%d, %d, %s, [%s])", location, count, transpose ? "GL_TRUE" : "GL_FALSE", _str_value));
}
void VEGAGlAPI::debug_UseProgram(GLuint program)
{
	OP_NEW_DBG("glUseProgram", "opengl");
	VEGA_GLREALSYM(UseProgram) (program);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u) -> error %s", program, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUseProgram");
	}
	else
		OP_DBG(("(%u)", program));
}
void VEGAGlAPI::debug_ValidateProgram(GLuint program)
{
	OP_NEW_DBG("glValidateProgram", "opengl");
	VEGA_GLREALSYM(ValidateProgram) (program);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u) -> error %s", program, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glValidateProgram");
	}
	else
		OP_DBG(("(%u)", program));
}
void VEGAGlAPI::debug_VertexAttrib1f(GLuint index, GLfloat x)
{
	OP_NEW_DBG("glVertexAttrib1f", "opengl");
	VEGA_GLREALSYM(VertexAttrib1f) (index, x);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %g) -> error %s", index, double(x), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glVertexAttrib1f");
	}
	else
		OP_DBG(("(%u, %g)", index, double(x)));
}
void VEGAGlAPI::debug_VertexAttrib1fv(GLuint index, const GLfloat * v)
{
	OP_NEW_DBG("glVertexAttrib1fv", "opengl");
	VEGA_GLREALSYM(VertexAttrib1fv) (index, v);
	GLenum _error = glGetError();
	char _str_v[50];
	_str_v[0] = 0;
	if (v)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_v + _snoffs, 50 - _snoffs, " %g", double(v[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, [%s]) -> error %s", index, _str_v, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glVertexAttrib1fv");
	}
	else
		OP_DBG(("(%u, [%s])", index, _str_v));
}
void VEGAGlAPI::debug_VertexAttrib2f(GLuint index, GLfloat x, GLfloat y)
{
	OP_NEW_DBG("glVertexAttrib2f", "opengl");
	VEGA_GLREALSYM(VertexAttrib2f) (index, x, y);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %g, %g) -> error %s", index, double(x), double(y), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glVertexAttrib2f");
	}
	else
		OP_DBG(("(%u, %g, %g)", index, double(x), double(y)));
}
void VEGAGlAPI::debug_VertexAttrib2fv(GLuint index, const GLfloat * v)
{
	OP_NEW_DBG("glVertexAttrib2fv", "opengl");
	VEGA_GLREALSYM(VertexAttrib2fv) (index, v);
	GLenum _error = glGetError();
	char _str_v[50];
	_str_v[0] = 0;
	if (v)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 2 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_v + _snoffs, 50 - _snoffs, " %g", double(v[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, [%s]) -> error %s", index, _str_v, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glVertexAttrib2fv");
	}
	else
		OP_DBG(("(%u, [%s])", index, _str_v));
}
void VEGAGlAPI::debug_VertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z)
{
	OP_NEW_DBG("glVertexAttrib3f", "opengl");
	VEGA_GLREALSYM(VertexAttrib3f) (index, x, y, z);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %g, %g, %g) -> error %s", index, double(x), double(y), double(z), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glVertexAttrib3f");
	}
	else
		OP_DBG(("(%u, %g, %g, %g)", index, double(x), double(y), double(z)));
}
void VEGAGlAPI::debug_VertexAttrib3fv(GLuint index, const GLfloat * v)
{
	OP_NEW_DBG("glVertexAttrib3fv", "opengl");
	VEGA_GLREALSYM(VertexAttrib3fv) (index, v);
	GLenum _error = glGetError();
	char _str_v[50];
	_str_v[0] = 0;
	if (v)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 3 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_v + _snoffs, 50 - _snoffs, " %g", double(v[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, [%s]) -> error %s", index, _str_v, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glVertexAttrib3fv");
	}
	else
		OP_DBG(("(%u, [%s])", index, _str_v));
}
void VEGAGlAPI::debug_VertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w)
{
	OP_NEW_DBG("glVertexAttrib4f", "opengl");
	VEGA_GLREALSYM(VertexAttrib4f) (index, x, y, z, w);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %g, %g, %g, %g) -> error %s", index, double(x), double(y), double(z), double(w), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glVertexAttrib4f");
	}
	else
		OP_DBG(("(%u, %g, %g, %g, %g)", index, double(x), double(y), double(z), double(w)));
}
void VEGAGlAPI::debug_VertexAttrib4fv(GLuint index, const GLfloat * v)
{
	OP_NEW_DBG("glVertexAttrib4fv", "opengl");
	VEGA_GLREALSYM(VertexAttrib4fv) (index, v);
	GLenum _error = glGetError();
	char _str_v[50];
	_str_v[0] = 0;
	if (v)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 4 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_v + _snoffs, 50 - _snoffs, " %g", double(v[_i]));
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, [%s]) -> error %s", index, _str_v, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glVertexAttrib4fv");
	}
	else
		OP_DBG(("(%u, [%s])", index, _str_v));
}
void VEGAGlAPI::debug_VertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid * pointer)
{
	OP_NEW_DBG("glVertexAttribPointer", "opengl");
	VEGA_GLREALSYM(VertexAttribPointer) (index, size, type, normalized, stride, pointer);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %d, %s, %s, %d, %p) -> error %s", index, size, FormatGLenum(type).CStr(), normalized ? "GL_TRUE" : "GL_FALSE", stride, pointer, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glVertexAttribPointer");
	}
	else
		OP_DBG(("(%u, %d, %s, %s, %d, %p)", index, size, FormatGLenum(type).CStr(), normalized ? "GL_TRUE" : "GL_FALSE", stride, pointer));
}
void VEGAGlAPI::debug_BindFramebuffer(GLenum target, GLuint framebuffer)
{
	OP_NEW_DBG("glBindFramebuffer", "opengl");
	VEGA_GLREALSYM(BindFramebuffer) (target, framebuffer);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %u) -> error %s", FormatGLenum(target).CStr(), framebuffer, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBindFramebuffer");
	}
	else
		OP_DBG(("(%s, %u)", FormatGLenum(target).CStr(), framebuffer));
}
void VEGAGlAPI::debug_BindRenderbuffer(GLenum target, GLuint renderbuffer)
{
	OP_NEW_DBG("glBindRenderbuffer", "opengl");
	VEGA_GLREALSYM(BindRenderbuffer) (target, renderbuffer);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %u) -> error %s", FormatGLenum(target).CStr(), renderbuffer, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBindRenderbuffer");
	}
	else
		OP_DBG(("(%s, %u)", FormatGLenum(target).CStr(), renderbuffer));
}
GLenum VEGAGlAPI::debug_CheckFramebufferStatus(GLenum target)
{
	OP_NEW_DBG("glCheckFramebufferStatus", "opengl");
	GLenum _return = VEGA_GLREALSYM(CheckFramebufferStatus) (target);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(target).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glCheckFramebufferStatus");
	}
	else
		OP_DBG(("(%s) = %s", FormatGLenum(target).CStr(), FormatGLenum(_return).CStr()));
	return _return;
}
void VEGAGlAPI::debug_DeleteFramebuffers(GLsizei n, const GLuint * framebuffers)
{
	OP_NEW_DBG("glDeleteFramebuffers", "opengl");
	VEGA_GLREALSYM(DeleteFramebuffers) (n, framebuffers);
	GLenum _error = glGetError();
	char _str_framebuffers[50];
	_str_framebuffers[0] = 0;
	if (framebuffers)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < n && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_framebuffers + _snoffs, 50 - _snoffs, " %u", framebuffers[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, [%s]) -> error %s", n, _str_framebuffers, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDeleteFramebuffers");
	}
	else
		OP_DBG(("(%d, [%s])", n, _str_framebuffers));
}
void VEGAGlAPI::debug_DeleteRenderbuffers(GLsizei n, const GLuint * renderbuffers)
{
	OP_NEW_DBG("glDeleteRenderbuffers", "opengl");
	VEGA_GLREALSYM(DeleteRenderbuffers) (n, renderbuffers);
	GLenum _error = glGetError();
	char _str_renderbuffers[50];
	_str_renderbuffers[0] = 0;
	if (renderbuffers)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < n && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_renderbuffers + _snoffs, 50 - _snoffs, " %u", renderbuffers[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, [%s]) -> error %s", n, _str_renderbuffers, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDeleteRenderbuffers");
	}
	else
		OP_DBG(("(%d, [%s])", n, _str_renderbuffers));
}
void VEGAGlAPI::debug_FramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer)
{
	OP_NEW_DBG("glFramebufferRenderbuffer", "opengl");
	VEGA_GLREALSYM(FramebufferRenderbuffer) (target, attachment, renderbuffertarget, renderbuffer);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, %s, %u) -> error %s", FormatGLenum(target).CStr(), FormatGLenum(attachment).CStr(), FormatGLenum(renderbuffertarget).CStr(), renderbuffer, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glFramebufferRenderbuffer");
	}
	else
		OP_DBG(("(%s, %s, %s, %u)", FormatGLenum(target).CStr(), FormatGLenum(attachment).CStr(), FormatGLenum(renderbuffertarget).CStr(), renderbuffer));
}
void VEGAGlAPI::debug_FramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level)
{
	OP_NEW_DBG("glFramebufferTexture2D", "opengl");
	VEGA_GLREALSYM(FramebufferTexture2D) (target, attachment, textarget, texture, level);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, %s, %u, %d) -> error %s", FormatGLenum(target).CStr(), FormatGLenum(attachment).CStr(), FormatGLenum(textarget).CStr(), texture, level, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glFramebufferTexture2D");
	}
	else
		OP_DBG(("(%s, %s, %s, %u, %d)", FormatGLenum(target).CStr(), FormatGLenum(attachment).CStr(), FormatGLenum(textarget).CStr(), texture, level));
}
void VEGAGlAPI::debug_GenFramebuffers(GLsizei n, GLuint * framebuffers)
{
	OP_NEW_DBG("glGenFramebuffers", "opengl");
	VEGA_GLREALSYM(GenFramebuffers) (n, framebuffers);
	GLenum _error = glGetError();
	char _str_framebuffers[50];
	_str_framebuffers[0] = 0;
	if (framebuffers)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < n && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_framebuffers + _snoffs, 50 - _snoffs, " %u", framebuffers[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, [%s]) -> error %s", n, _str_framebuffers, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGenFramebuffers");
	}
	else
		OP_DBG(("(%d, [%s])", n, _str_framebuffers));
}
void VEGAGlAPI::debug_GenRenderbuffers(GLsizei n, GLuint * renderbuffers)
{
	OP_NEW_DBG("glGenRenderbuffers", "opengl");
	VEGA_GLREALSYM(GenRenderbuffers) (n, renderbuffers);
	GLenum _error = glGetError();
	char _str_renderbuffers[50];
	_str_renderbuffers[0] = 0;
	if (renderbuffers)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < n && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_renderbuffers + _snoffs, 50 - _snoffs, " %u", renderbuffers[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, [%s]) -> error %s", n, _str_renderbuffers, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGenRenderbuffers");
	}
	else
		OP_DBG(("(%d, [%s])", n, _str_renderbuffers));
}
void VEGAGlAPI::debug_GenerateMipmap(GLenum target)
{
	OP_NEW_DBG("glGenerateMipmap", "opengl");
	VEGA_GLREALSYM(GenerateMipmap) (target);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(target).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGenerateMipmap");
	}
	else
		OP_DBG(("(%s)", FormatGLenum(target).CStr()));
}
void VEGAGlAPI::debug_GetRenderbufferParameteriv(GLenum target, GLenum pname, GLint * params)
{
	OP_NEW_DBG("glGetRenderbufferParameteriv", "opengl");
	VEGA_GLREALSYM(GetRenderbufferParameteriv) (target, pname, params);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, ?) -> error %s", FormatGLenum(target).CStr(), FormatGLenum(pname).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetRenderbufferParameteriv");
	}
	else
		OP_DBG(("(%s, %s, ?)", FormatGLenum(target).CStr(), FormatGLenum(pname).CStr()));
}
void VEGAGlAPI::debug_RenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height)
{
	OP_NEW_DBG("glRenderbufferStorage", "opengl");
	VEGA_GLREALSYM(RenderbufferStorage) (target, internalformat, width, height);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %s, %d, %d) -> error %s", FormatGLenum(target).CStr(), FormatGLenum(internalformat).CStr(), width, height, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glRenderbufferStorage");
	}
	else
		OP_DBG(("(%s, %s, %d, %d)", FormatGLenum(target).CStr(), FormatGLenum(internalformat).CStr(), width, height));
}
#  ifndef VEGA_OPENGLES
void VEGAGlAPI::debug_BlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter)
{
	OP_NEW_DBG("glBlitFramebuffer", "opengl");
	VEGA_GLREALSYM(BlitFramebuffer) (srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, %d, %d, %d, %d, %d, %d, %d, %08x, %s) -> error %s", srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, FormatGLenum(filter).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBlitFramebuffer");
	}
	else
		OP_DBG(("(%d, %d, %d, %d, %d, %d, %d, %d, %08x, %s)", srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, FormatGLenum(filter).CStr()));
}
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
void VEGAGlAPI::debug_RenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height)
{
	OP_NEW_DBG("glRenderbufferStorageMultisample", "opengl");
	VEGA_GLREALSYM(RenderbufferStorageMultisample) (target, samples, internalformat, width, height);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %d, %s, %d, %d) -> error %s", FormatGLenum(target).CStr(), samples, FormatGLenum(internalformat).CStr(), width, height, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glRenderbufferStorageMultisample");
	}
	else
		OP_DBG(("(%s, %d, %s, %d, %d)", FormatGLenum(target).CStr(), samples, FormatGLenum(internalformat).CStr(), width, height));
}
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
GLvoid* VEGAGlAPI::debug_MapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access)
{
	OP_NEW_DBG("glMapBufferRange", "opengl");
	GLvoid* _return = VEGA_GLREALSYM(MapBufferRange) (target, offset, length, access);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %ld, %ld, %08x) -> error %s", FormatGLenum(target).CStr(), long(offset), long(length), access, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glMapBufferRange");
	}
	else
		OP_DBG(("(%s, %ld, %ld, %08x) = %p", FormatGLenum(target).CStr(), long(offset), long(length), access, _return));
	return _return;
}
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
GLboolean VEGAGlAPI::debug_UnmapBuffer(GLenum target)
{
	OP_NEW_DBG("glUnmapBuffer", "opengl");
	GLboolean _return = VEGA_GLREALSYM(UnmapBuffer) (target);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s) -> error %s", FormatGLenum(target).CStr(), FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glUnmapBuffer");
	}
	else
		OP_DBG(("(%s) = %s", FormatGLenum(target).CStr(), _return ? "GL_TRUE" : "GL_FALSE"));
	return _return;
}
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
GLsync VEGAGlAPI::debug_FenceSync(GLenum condition, GLbitfield flags)
{
	OP_NEW_DBG("glFenceSync", "opengl");
	GLsync _return = VEGA_GLREALSYM(FenceSync) (condition, flags);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%s, %08x) -> error %s", FormatGLenum(condition).CStr(), flags, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glFenceSync");
	}
	else
		OP_DBG(("(%s, %08x) = %p", FormatGLenum(condition).CStr(), flags, _return));
	return _return;
}
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
void VEGAGlAPI::debug_GetSynciv(GLsync sync, GLenum pname, GLsizei bufSize, GLsizei * length, GLint * values)
{
	OP_NEW_DBG("glGetSynciv", "opengl");
	VEGA_GLREALSYM(GetSynciv) (sync, pname, bufSize, length, values);
	GLenum _error = glGetError();
	char _str_length[50];
	_str_length[0] = 0;
	if (length)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < 1 && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_length + _snoffs, 50 - _snoffs, " %d", length[_i]);
	}
	char _str_values[50];
	_str_values[0] = 0;
	if (!length)
	{
		_str_values[0] = '?';
		_str_values[1] = 0;
	}
	else if (values)
	{
		size_t _snoffs = 0;
		for (int _i = 0; _i < *length && _snoffs < 50; _i++)
			_snoffs += op_snprintf(_str_values + _snoffs, 50 - _snoffs, " %d", values[_i]);
	}
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%p, %s, %d, [%s], [%s]) -> error %s", sync, FormatGLenum(pname).CStr(), bufSize, _str_length, _str_values, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glGetSynciv");
	}
	else
		OP_DBG(("(%p, %s, %d, [%s], [%s])", sync, FormatGLenum(pname).CStr(), bufSize, _str_length, _str_values));
}
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
void VEGAGlAPI::debug_DeleteSync(GLsync sync)
{
	OP_NEW_DBG("glDeleteSync", "opengl");
	VEGA_GLREALSYM(DeleteSync) (sync);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%p) -> error %s", sync, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDeleteSync");
	}
	else
		OP_DBG(("(%p)", sync));
}
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
void VEGAGlAPI::debug_BindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar * name)
{
	OP_NEW_DBG("glBindFragDataLocationIndexed", "opengl");
	VEGA_GLREALSYM(BindFragDataLocationIndexed) (program, colorNumber, index, name);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%u, %u, %u, ?) -> error %s", program, colorNumber, index, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glBindFragDataLocationIndexed");
	}
	else
		OP_DBG(("(%u, %u, %u, ?)", program, colorNumber, index));
}
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
#   ifdef VEGA_ENABLE_PERF_EVENTS
void VEGAGlAPI::debug_StringMarkerGREMEDY(GLsizei len, const GLvoid * string)
{
	OP_NEW_DBG("glStringMarkerGREMEDY", "opengl");
	VEGA_GLREALSYM(StringMarkerGREMEDY) (len, string);
	GLenum _error = glGetError();
	int _strlen_string = len;
	if (_strlen_string == 0) _strlen_string = op_strlen((char*)string);
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%d, '%.*s') -> error %s", len, _strlen_string, string, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glStringMarkerGREMEDY");
	}
	else
		OP_DBG(("(%d, '%.*s')", len, _strlen_string, string));
}
#   endif // VEGA_ENABLE_PERF_EVENTS
#  endif // !VEGA_OPENGLES
#  ifndef VEGA_OPENGLES
#   ifdef VEGA_GL_DEBUG_CONTEXT
void VEGAGlAPI::debug_DebugMessageCallbackARB(GLDEBUGPROCARB callback, const GLvoid * userParam)
{
	OP_NEW_DBG("glDebugMessageCallbackARB", "opengl");
	VEGA_GLREALSYM(DebugMessageCallbackARB) (callback, userParam);
	GLenum _error = glGetError();
	if (_error != GL_NO_ERROR)
	{
		OP_DBG(("(%08x, %p) -> error %s", callback, userParam, FormatGLenum(_error).CStr()));
		OP_ASSERT(!"OpenGL error in glDebugMessageCallbackARB");
	}
	else
		OP_DBG(("(%08x, %p)", callback, userParam));
}
#   endif // VEGA_GL_DEBUG_CONTEXT
#  endif // !VEGA_OPENGLES

# endif // VEGA_GL_DEBUG

#endif // OPENGL_REGISTRY
