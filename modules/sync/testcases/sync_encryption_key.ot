/* -*- Mode: c++; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4; -*-
 *
 * Copyright (C) 2010 Opera Software AS.  All rights reserved.
 *
 * This file is part of the Opera web browser.
 * It may not be distributed under any circumstances.
 */

group "sync.encryption_key";
require SUPPORT_DATA_SYNC;
require SYNC_ENCRYPTION_KEY_SUPPORT;

include "modules/sync/sync_encryption_key.h";
include "modules/sync/sync_coordinator.h";
include "modules/sync/testcases/sync_ST_factory.h";
include "modules/sync/testcases/sync_ST_transport.h";

test("SetEncryptedEncryptionKey")
{
	/* Tests that SyncEncryptionKey::SetEncryptedEncryptionKey() sets the
	 * encryption-key and GetEncryptedEncryptionKey() returns the same value. */
	const uni_char* test_key = UNI_L("0102030405060708090A0B0C0D0E0F10");
	SyncEncryptionKey sync_encryption_key;
	verify(sync_encryption_key.IsEmpty());
	verify_success(sync_encryption_key.SetEncryptedEncryptionKey(test_key));
	OpString key;
	verify(!sync_encryption_key.IsEmpty());
	verify_success(sync_encryption_key.GetEncryptedEncryptionKey(key));
	verify_string(key, test_key);
}

table table_encrypted_key(const char* test_name, const uni_char* encrypted_key, const uni_char* username, const uni_char* password, const uni_char key, OP_STATUS decrypt_status)
{
	{ "simple", // test_name
		UNI_L("+dYkZO4EYZvkQge/0fE1saPh4e9zNjud0g4Z4ai1H5HxpDriuNNFSupNpR+wXRVoL5a7q3WoVyDP+FGiTMXc+qX+sUlYtRPQ6v4vC6R0YFyHdeEy/+/a5A=="),
		UNI_L("zog"), UNI_L("zap"), // username, password
		UNI_L("000102030405060708090A0B0C0D0E0F"), // decrypted key
		OpStatus::OK // expected status on Decrypt()
	},
	{ "wrong credentials",
		UNI_L("+dYkZO4EYZvkQge/0fE1saPh4e9zNjud0g4Z4ai1H5HxpDriuNNFSupNpR+wXRVoL5a7q3WoVyDP+FGiTMXc+qX+sUlYtRPQ6v4vC6R0YFyHdeEy/+/a5A=="),
		UNI_L("zog"), UNI_L("foo"), // username, password
		UNI_L("000102030405060708090A0B0C0D0E0F"), // decrypted key
		OpStatus::ERR_NO_ACCESS // Decrypt() cannot decrypt this
	},
		/* Note: the following tests have an invalid encryption-key, but
		 * SyncEncryptionKey::SetEncryptedEncryptionKey() cannot validate the
		 * content of the encrypted key. The content is validated on calling
		 * SyncEncryptionKey::Decrypt(). */
	{ "empty", // test_name
		UNI_L("k0fkJVfZzH9nhrMcebxxyXZYZz2OJaoTTq6yjrlfcN6QxcOFDO5/hYXb6NXmt3wdXaMHpLfMxHw="),
		UNI_L("zog"), UNI_L("zap"), // username, password
		UNI_L(""), // decrypted key
		OpStatus::ERR_OUT_OF_RANGE // expected status on Decrypt()
	},
	{ "too short", // test_name
		UNI_L("pmMUasIQKLBuNH+eSDStWeoWbFkEQQo0SFu1txI3z3+BrjA5RJ5x2Fwa6wVlhQOPE92tZKTFa2vJwEPxkOgolOjBPBjvsrrL06hsEHoj88ZmbtP5uj30nA=="),
		UNI_L("zog"), UNI_L("zap"), // username, password
		UNI_L("000102030405060708090A0B0C0D0E0"), // decrypted key
		OpStatus::ERR_OUT_OF_RANGE // expected status on Decrypt()
	},
	{ "too long", // test_name
		UNI_L("liRcxnTFGKuok1TG7cZQtLz6/SafP9QIszSX9QR1/mv5hEY0pMkcqGzKoTVY+HFFbdCwJsOZQEjfR0jhIy1n1Isudkf3HqGv1F2pMZMkkQ/PJ9CKYloX5A=="),
		UNI_L("zog"), UNI_L("zap"), // username, password
		UNI_L("000102030405060708090A0B0C0D0E0F1"), // decrypted key
		OpStatus::ERR_OUT_OF_RANGE // expected status on Decrypt()
	},
	{ "invalid key", // test_name
		UNI_L("7Gg5uDjhmlUI6OJNpNAZ3Sd8aaMc6+/58dBLubgzO39KtLP23xeDpOdsg8fb/2KwiRLOPQHX9hBOEIDMW2zZU0zJz9QYYdtPkiMEHLaUFdxQ8hGZug9KbQ=="),
		UNI_L("zog"), UNI_L("zap"), // username, password
		UNI_L("000102030405060708090A0B0C0D0E0G"), // decrypted key
		OpStatus::ERR_OUT_OF_RANGE // expected status on Decrypt()
	}
}


/* This test can be enabled to display the encrypted encryption-key for the
 * encryption-key (as hex-string), username and password as specified in
 * table_encrypted_key. */
// foreach (test_name, ignore_encrypted_key, username, password, key, ignore_status) from table_encrypted_key
// {
// 	test("encrypt key: " test_name)
// 	{
// 		SyncEncryptionKey sync_encryption_key;
// 		sync_encryption_key.SetEncryptionKey(key, username, password);
// 		OpString encrypted;
// 		sync_encryption_key.GetEncryptedEncryptionKey(encrypted);
// 		output("encrypted key is UNI_L(\"%s\")", ST_down(encrypted.CStr()));
// 	}
// }

foreach (test_name, encrypted_key, username, password, expected_key, expected_decrypt_status) from table_encrypted_key
{
	test("SetEncryptedEncryptionKey key: " test_name)
	{
		SyncEncryptionKey sync_encryption_key;
		verify_success(sync_encryption_key.SetEncryptedEncryptionKey(encrypted_key));
		OpString get_encrypted_key;
		verify_success(sync_encryption_key.GetEncryptedEncryptionKey(get_encrypted_key));
		verify_string(get_encrypted_key, encrypted_key);
		OpString key_hex;
		UINT8 key_bin[16];
		OP_STATUS decrypt_status = sync_encryption_key.Decrypt(key_hex, key_bin, username, password);
		verify_status(expected_decrypt_status, decrypt_status);
		if (OpStatus::IsSuccess(decrypt_status))
			verify_string(key_hex, expected_key);
	}
}

test("Clear")
require success "SetEncryptedEncryptionKey";
{
	/* Tests that SyncEncryptionKey::Clear() resets the encryption-key. */
	const uni_char* test_key = UNI_L("0102030405060708090A0B0C0D0E0F10");
	SyncEncryptionKey sync_encryption_key;
	verify_success(sync_encryption_key.SetEncryptedEncryptionKey(test_key));
	verify(!sync_encryption_key.IsEmpty());
	sync_encryption_key.Clear();
	verify(sync_encryption_key.IsEmpty());
	OpString key;
	verify_success(sync_encryption_key.GetEncryptedEncryptionKey(key));
	verify_string(key, "");
}

table test_encryption(const char* test_name, const uni_char* username, const uni_char* password, const char* expected_hash)
{
	/* Note: the expected_hash was calculated with the little python program:
	 * @code
	 * import hashlib
	 * username="some rather long username"
	 * password="and some even longer password"
	 * print hashlib.sha256(username+":"+password).hexdigest()
	 * @endcode
	 */
	{ "simple", UNI_L("foo"), UNI_L("bar"), "a765a8beaa9d561d4c5cbed29d8f4e30870297fdfa9cb7d6e9848a95fec9f937" },
	{ "empty password", UNI_L("foo"), UNI_L(""), "c5fe91c8e8d22d268ae087fcf5968412e7ac08807f26e643c3068f294c4e7fbb" },
	{ "empty username,password", UNI_L(""), UNI_L(""), "e7ac0786668e0ff0f02b62bd04f45ff636fd82db63b1104601c975dc005f3a67" },
	{ "long username,password", UNI_L("some rather long username"), UNI_L("and some even longer password"), "276631838b03659726d6eebd4e29d76d8395fdfdc2b37da191846ae68e406a6d" },
}

foreach (test_name, username, password, ignore_me) from test_encryption
{
	test("SetEncryptionKey: " test_name)
	{
		const uni_char* test_key = UNI_L("0102030405060708090A0B0C0D0E0F10");
		SyncEncryptionKey sync_encryption_key;
		verify_success(sync_encryption_key.SetEncryptionKey(test_key, username, password));
		OpString key;
		verify_success(sync_encryption_key.Decrypt(key, username, password));
		verify_string(key, test_key);
	}
}

foreach (test_name, username, password, expected_hash) from test_encryption
{
	test("GetHash: " test_name)
	{
		SyncEncryptionKey sync_encryption_key;
		SyncEncryptionKey::SelftestHelper helper(&sync_encryption_key);
		UINT8* hash = 0;
		size_t hash_size = 0;
		verify_success(helper.GetHash(&hash, &hash_size, username, password));
		OpString8 hash_str;
		for (unsigned int i=0; i<hash_size; i++)
			verify_success(hash_str.AppendFormat("%02x", hash[i]));
		verify_string(hash_str, expected_hash);
	}
	finally
	{
		if (hash) OP_DELETEA(hash);
	}
}

test("Decrypt() wrong key")
{
	/* Test that a wrong <username,password> pair fails to decrypt the
	 * encryption key: */
	const uni_char* test_key = UNI_L("0102030405060708090A0B0C0D0E0F10");
	SyncEncryptionKey sync_encryption_key;
	verify_success(sync_encryption_key.SetEncryptionKey(test_key, UNI_L("username"), UNI_L("password")));
	OpString key;
	verify_status(OpStatus::ERR_NO_ACCESS, sync_encryption_key.Decrypt(key, UNI_L("username"), UNI_L("wrong password")));
}

table test_key(const char* test_name, const uni_char* hex_key, UINT8 expected_bin_key[16], OPSTATUS expected_status)
{
	{ "low", UNI_L("000102030405060708090a0b0c0d0e0f"), {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}, OpStatus::OK },
	{ "up", UNI_L("F0E1D2C3B4A5968778695a4b3c2d1e0f"), {0xF0, 0xE1, 0xD2, 0xC3, 0xB4, 0xA5, 0x96, 0x87, 0x78, 0x69, 0x5a, 0x4b, 0x3c, 0x2d, 0x1e, 0x0f}, OpStatus::OK },
	{ "invalid chars", UNI_L("This is not a hex string3c2d1e0f"), {}, OpStatus::ERR_OUT_OF_RANGE },
}

foreach (test_name, hex_key, expected_bin_key, expected_status) from test_key
{
	test("Decrypt key: " test_name)
	{
		/* verifies that SyncEncryptionKey::Decrypt() successfully converts a
		 * the encryption-key from a hex-string to a byte array. */
		SyncEncryptionKey sync_encryption_key;
		const uni_char* username = UNI_L("zog");
		const uni_char* password = UNI_L("zap");
		verify_success(sync_encryption_key.SetEncryptionKey(hex_key, username, password));
		UINT8 bin_key[16];
		op_memset(bin_key, 0xef, 16);
		OP_STATUS decrypt_status = sync_encryption_key.Decrypt(bin_key, username, password);
		verify_status(expected_status, decrypt_status);
		if (OpStatus::IsSuccess(decrypt_status))
		{
			/* only test the expected result if the status is ok. */
			const UINT8 expected[16] = expected_bin_key;
			for (unsigned int i=0; i<16; i++)
				verify(bin_key[i] == expected[i]);
		}
	}
}

// ==================== "sync.encryption_key_manager"

group "sync.encryption_key_manager";
require SUPPORT_DATA_SYNC;
require SYNC_ENCRYPTION_KEY_SUPPORT;

global
{
	/**
	 * This class can be used to verify that the OpSyncUIListener is called
	 * correctly. To use this class create a local instance and call
	 * OpSyncCoordinator::SetSyncUIListener():
	 * @code
	 * ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	 * OpSyncCoordinator coordinator;
	 * ST_SyncUIListener ui_listener;
	 * verify(factory);
	 * verify_success(coordinator.Init(factory, FALSE));
	 * verify_success(coordinator.SetSyncUIListener(&ui_listener));
	 * @endcode
	 *
	 * Use the method HasReencryptContext() to verify that
	 * OnSyncReencryptEncryptionKeyFailed() has been called and an
	 * OpSyncUIListener::ReencryptEncryptionKeyContext has been set.
	 *
	 * If HasReencryptContext() is true, you may call
	 * ReencryptDecryptWithPassword() or ReencryptCreateNewEncryptionKey().
	 *
	 * GetLastError() returns the last OpSyncError that was set via a call to
	 * OpSyncError() - and resets the error to SYNC_OK.
	 */
	class ST_SyncUIListener : public OpSyncUIListener
	{
		OpSyncError m_last_error;
		OpSyncUIListener::ReencryptEncryptionKeyContext* m_context;
	public:
		ST_SyncUIListener() : m_last_error(SYNC_OK), m_context(0) {}
		virtual ~ST_SyncUIListener() {}

		/**
		 * @name Implementation of OpSyncUIListener
		 * @{
		 */
		virtual void OnSyncStarted(BOOL items_sending) {}
		virtual void OnSyncError(OpSyncError error, const OpStringC& error_message) {
			m_last_error = error;
		}
		virtual void OnSyncFinished(OpSyncState& sync_state) {}
		virtual void OnSyncReencryptEncryptionKeyFailed(OpSyncUIListener::ReencryptEncryptionKeyContext* context) {
			m_context = context;
		}
		virtual void OnSyncReencryptEncryptionKeyCancel(ReencryptEncryptionKeyContext* context) {
			if (m_context == context) m_context = 0;
		}
		/** @} */ // Implementation of OpSyncUIListener

		void ReencryptDecryptWithPassword(const OpStringC& password) {
			OpSyncUIListener::ReencryptEncryptionKeyContext* context = m_context;
			m_context = 0;
			context->DecryptWithPassword(password);
		}

		void ReencryptCreateNewEncryptionKey() {
			OpSyncUIListener::ReencryptEncryptionKeyContext* context = m_context;
			m_context = 0;
			context->CreateNewEncryptionKey();
		}
		bool HasReencryptContext() const { return m_context != 0; }
		OpSyncError GetLastError() {
			OpSyncError err = m_last_error;
			m_last_error = SYNC_OK;
			return err;
		}
	};

	class ST_EncryptionKeyListener
		: public SyncEncryptionKeyManager::EncryptionKeyListener
	{
		SyncEncryptionKeyManager* m_manager;
		unsigned int m_count;
		unsigned int m_count_deleted;

	public:
		ST_EncryptionKeyListener(SyncEncryptionKeyManager* manager)
			: m_manager(manager)
			, m_count(0)
			, m_count_deleted(0)
			{
				m_manager->AddEncryptionKeyListener(this);
			}
		virtual ~ST_EncryptionKeyListener()
			{
				m_manager->RemoveEncryptionKeyListener(this);
			}

		/** @name Implementation of SyncEncryptionKeyManager::EncryptionKeyListener
		 * @{ */
		virtual void OnEncryptionKey(const SyncEncryptionKey& key) { m_count++; }
		virtual void OnEncryptionKeyDeleted() { m_count_deleted++; }
		/** @} */

		unsigned int Count() const { return m_count; }
		unsigned int CountDeleted() const { return m_count_deleted; }
	};

	const uni_char* simple_encrypted_key;
	const uni_char* simple_decrypted_key;
}

setup
{
	simple_encrypted_key = UNI_L("+dYkZO4EYZvkQge/0fE1saPh4e9zNjud0g4Z4ai1H5HxpDriuNNFSupNpR+wXRVoL5a7q3WoVyDP+FGiTMXc+qX+sUlYtRPQ6v4vC6R0YFyHdeEy/+/a5A==");
	simple_decrypted_key = UNI_L("000102030405060708090A0B0C0D0E0F");
}

test("SyncEncryptionKeyManager")
require init;
require PREFS_WRITE;
{
	/* sync_used must be enabled to let the OpSyncCoordinator inform all its
	 * listeners about the supports type being enabled or disabled: */
	OP_STATUS status;
	const int sync_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncUsed);
	if (!sync_used)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, 1));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	verify(factory);
	OpSyncCoordinator coordinator;
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0;
	SyncEncryptionKeyManager encryption_key_manager;
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify(!encryption_key_manager.HasEncryptionKey());
	/* The encryption-key support is expected to be enabled if password-manager
	 * support is enabled: */
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (sync_passwords)
		verify(encryption_key_manager.IsSupportEnabled());
	else
		verify(!encryption_key_manager.IsSupportEnabled());
}
finally
{
	if (!sync_used)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, sync_used));
	OP_DELETE(factory);
}

test("enable support")
require init;
require PREFS_WRITE;
require success "SyncEncryptionKeyManager";
{
	OP_STATUS status;
	/* sync_used must be enabled to let the OpSyncCoordinator inform all its
	 * listeners about the supports type being enabled or disabled: */
	const int sync_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncUsed);
	if (!sync_used)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, 1));

	/* If password sync is enabled, we need to disable it to be able to receive
	 * the notification when it is enabled: */
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 0));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	verify(factory);
	OpSyncCoordinator coordinator;
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...
	SyncEncryptionKeyManager encryption_key_manager;
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify(!encryption_key_manager.HasEncryptionKey());
	/* The encryption-key support is expected to be disabled (because we
	 * disabled password-manager support: */
	verify(!encryption_key_manager.IsSupportEnabled());
	// Now enable password-manager support:
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	// Now encryption-key should be supported:
	verify(encryption_key_manager.IsSupportEnabled());
}
finally
{
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, sync_used));
}

test("IsWaitingForEncryptionKey")
require init;
require PREFS_WRITE;
require success "SyncEncryptionKeyManager";
{
	OP_STATUS status;
	/* sync_used must be enabled to let the OpSyncCoordinator inform all its
	 * listeners about the supports type being enabled or disabled: */
	const int sync_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncUsed);
	if (!sync_used)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, 1));
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 0));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	verify(factory);
	OpSyncCoordinator coordinator;
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...
	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper helper(&encryption_key_manager);
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify(!encryption_key_manager.HasEncryptionKey());
	verify(!helper.IsWaitingForEncryptionKey());
	verify(!encryption_key_manager.IsSupportEnabled());
	// Now enable password-manager support:
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	/* the encryption_key_manager should now wait for the encryption-key, which
	 * may be sent from the Link-Server: */
	verify(helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
}
finally
{
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, sync_used));
}

test("IsWaitingForEncryptionKey enable while sync in progress")
require init;
require PREFS_WRITE;
require success "IsWaitingForEncryptionKey";
{
	/* This test verifies that the SyncEncryptionKeyManager does not start to
	 * wait for the encryption-key (IsWaitingForEncryptionKey()) if the support
	 * for password syncing is enabled while a sync is in progress. Instead the
	 * SyncEncryptionKeyManager starts waiting when the sync connection is
	 * completed (OpSyncCoordinator::OnSyncCompleted(). */
	OP_STATUS status;
	/* sync_used must be enabled to let the OpSyncCoordinator inform all its
	 * listeners about the supports type being enabled or disabled: */
	const int sync_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncUsed);
	if (!sync_used)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, 1));
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 0));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...
	verify(!coordinator.UseDiskQueue());
	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper helper(&encryption_key_manager);
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify(!encryption_key_manager.HasEncryptionKey());
	verify(!helper.IsWaitingForEncryptionKey());
	verify(!encryption_key_manager.IsSupportEnabled());

	// emulate sync being in progress:
	sync_helper.SetSyncInProgress(TRUE);
	verify(coordinator.IsSyncInProgress());

	// Now enable password-manager support:
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	// the encryption_key_manager shall not yet be notified:
	verify(!helper.IsWaitingForEncryptionKey());
	verify(!encryption_key_manager.IsSupportEnabled());

	// emulate stopping the sync progress:
	OpSyncCollection new_items;
	OpSyncState sync_state;
	OpSyncServerInformation server_info;
	coordinator.OnSyncCompleted(&new_items, sync_state, server_info);

	/* The encryption_key_manager shall not have generated the encryption-key,
	 * but it shall now wait for the encryption-key, which
	 * may be sent from the Link-Server: */
	verify(!encryption_key_manager.HasEncryptionKey());
	verify(helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(coordinator.UseDiskQueue());
}
finally
{
	coordinator.SetUseDiskQueue(FALSE);
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, sync_used));
}

subtest CreateEncryptionSyncItem(OpSyncCoordinator& coordinator, OpSyncItem** sync_item, enum OpSyncDataItem::DataItemType type, const uni_char* content)
{
	verify(sync_item);
	verify_success(coordinator.GetSyncItem(sync_item, type, OpSyncItem::SYNC_KEY_ID, UNI_L("0")));
	verify(*sync_item);
	if (content)
	{
		verify_success((*sync_item)->SetData(OpSyncItem::SYNC_KEY_NONE, content));
		verify_success((*sync_item)->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED));
	}
	else
	{
		verify_success((*sync_item)->SetStatus(OpSyncDataItem::DATAITEM_ACTION_DELETED));
	}
}

subtest CreateEncryptionKeyItem(OpSyncCoordinator& coordinator, OpSyncItem** sync_item, const uni_char* encryption_type)
{
	verify(CreateEncryptionSyncItem(coordinator, sync_item, OpSyncDataItem::DATAITEM_ENCRYPTION_KEY, encryption_type));
}

table received_encryption_key(const char* test_name, const uni_char* encrypted_key, const uni_char* decrypted_key, const uni_char* expected_decrypted_key)
{
	{ "simple", // test_name
		simple_encrypted_key,
		simple_decrypted_key, // decrypted_key
		simple_decrypted_key // expected_decrypted_key
	},
	{ "empty", // test_name
		UNI_L("k0fkJVfZzH9nhrMcebxxyXZYZz2OJaoTTq6yjrlfcN6QxcOFDO5/hYXb6NXmt3wdXaMHpLfMxHw="),
		UNI_L(""),
		0 // expected_decrypted_key
	},
	{ "too short", // test_name
		UNI_L("pmMUasIQKLBuNH+eSDStWeoWbFkEQQo0SFu1txI3z3+BrjA5RJ5x2Fwa6wVlhQOPE92tZKTFa2vJwEPxkOgolOjBPBjvsrrL06hsEHoj88ZmbtP5uj30nA=="),
		UNI_L("000102030405060708090A0B0C0D0E0"), // decrypted_key
		0 // expected_decrypted_key
	},
	{ "too long", // test_name
		UNI_L("liRcxnTFGKuok1TG7cZQtLz6/SafP9QIszSX9QR1/mv5hEY0pMkcqGzKoTVY+HFFbdCwJsOZQEjfR0jhIy1n1Isudkf3HqGv1F2pMZMkkQ/PJ9CKYloX5A=="),
		UNI_L("000102030405060708090A0B0C0D0E0F1"), // decrypted_key
		0 // expected_decrypted_key
	},
	{ "invalid key", // test_name
		UNI_L("7Gg5uDjhmlUI6OJNpNAZ3Sd8aaMc6+/58dBLubgzO39KtLP23xeDpOdsg8fb/2KwiRLOPQHX9hBOEIDMW2zZU0zJz9QYYdtPkiMEHLaUFdxQ8hGZug9KbQ=="),
		UNI_L("000102030405060708090A0B0C0D0E0G"), // decrypted_key
		0 // expected_decrypted_key
	}
}

foreach (test_name, encrypted_key, ignore_decrypted_key, expected_decrypted_key) from received_encryption_key
{
	test("Receive " test_name " encryption-key from server")
	require init;
	require PREFS_WRITE;
	require WAND_SUPPORT;
	require success "IsWaitingForEncryptionKey";
	{
		/* This test emulates a response from the Link server sending an
		 * encryption-key. If the expected_decrypted_key is set, then it is
		 * expected that the encrypted encryption-key is successfully decrypted
		 * and stored in the SyncEncryptionKeyManager instance and in wand
		 * (emulated by the SelftestHelper class).
		 * If the expected_decrypted_key is 0, then it is expected that the
		 * encrypted encryption-key cannot be decrypted. */
		OP_STATUS status;
		const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
		const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
		if (!sync_passwords)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
		if (!sync_enabled)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

		const OpStringC username(UNI_L("zog"));
		const OpStringC password(UNI_L("zap"));

		ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
		OpSyncCollection* new_items = OP_NEW(OpSyncCollection, ());
		OpSyncItem* sync_item = 0;
		OpSyncCoordinator coordinator;
		verify(factory);
		verify(new_items);
		verify_success(coordinator.Init(factory, FALSE));
		factory = 0; // now the coordinator owns the factory ...
		SyncEncryptionKeyManager encryption_key_manager;
		SyncEncryptionKeyManager::SelftestHelper helper(&encryption_key_manager);
		TRAP(status, encryption_key_manager.InitL(&coordinator));
		verify_success(status);
		verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));
		verify(helper.IsWaitingForEncryptionKey());
		verify(encryption_key_manager.IsSupportEnabled());
		verify(!encryption_key_manager.HasEncryptionKey());

		/* Create a sync item that contains an encryption-key */
		verify(CreateEncryptionKeyItem(coordinator, &sync_item, encrypted_key));
		new_items->AddItem(sync_item);

		/* tell the SyncEncryptionKeyManager that data has arrived: */
		OpSyncDataError data_error = SYNC_DATAERROR_NONE;
		verify_success(encryption_key_manager.SyncDataAvailable(new_items, data_error));

		if (expected_decrypted_key)
		{	/* If we expect that the received sync-item contains a valid key, we
			 * no longer wait for it: */
			verify(!helper.IsWaitingForEncryptionKey());
			verify(encryption_key_manager.IsSupportEnabled());
			verify(encryption_key_manager.HasEncryptionKey());

			/* The encrypted key is stored in the SyncEncryptionKeyManager: */
			OpString key;
			verify_success(encryption_key_manager.GetEncryptionKey().GetEncryptedEncryptionKey(key));
			verify_string(key, encrypted_key);

			/* and the decrypted key is stored in the wand emulation of the
			 * selftest: */
			verify_string(helper.WandPassword(), OpStringC(expected_decrypted_key));
		}
		else
		{	/* If we expect that the received sync-item does not contain a
			 * valid key, we expect to continue to wait for the encryption-key,
			 * i.e. we create a new one when OnSyncFinished() was called. */
			verify(helper.IsWaitingForEncryptionKey());
			verify(encryption_key_manager.IsSupportEnabled());
			verify(!encryption_key_manager.HasEncryptionKey());
		}
	}
	finally
	{
		if (sync_item)
		{
			new_items->Remove(sync_item);
			sync_item->SetDataSyncItem(0);
			OP_DELETE(sync_item);
			sync_item = 0;
		}
		OP_DELETE(new_items);
		OP_DELETE(factory);
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	}
}

test("encryption-key deleted on server")
require init;
require PREFS_WRITE;
require WAND_SUPPORT;
require success "Receive simple encryption-key from server";
{
	/* This test verifies that when the server sends an encryption-key with
	 * status "deleted", it is cleared in the SyncEncryptionKeyManager and
	 * removed from the wand emulation. */
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zap"));
	const OpStringC encrypted_key(simple_encrypted_key);
	const OpStringC decrypted_key(simple_decrypted_key);

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCollection* new_items = OP_NEW(OpSyncCollection, ());
	OpSyncItem* sync_item = 0;
	OpSyncCoordinator coordinator;
	verify(factory);
	verify(new_items);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...
	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper helper(&encryption_key_manager);
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));
	/* Store the encryption key in the SyncEncryptionKeyManager and the
	 * helper's wand emulation: */
	verify_success(helper.SetEncryptionKey(encrypted_key, decrypted_key, username));

	/* Create a sync item that contains an encryption-deleted status: */
	verify(CreateEncryptionKeyItem(coordinator, &sync_item, 0));
	new_items->AddItem(sync_item);

	/* Tell the SyncEncryptionKeyManager that data has arrived: */
	OpSyncDataError data_error = SYNC_DATAERROR_NONE;
	verify_success(encryption_key_manager.SyncDataAvailable(new_items, data_error));
	/* And now the encryption-key is deleted: */
	verify(!encryption_key_manager.HasEncryptionKey());
	/* And the encrypted key is also removed from the wand emulation: */
	verify(helper.WandPassword().IsEmpty());
}
finally
{
	if (sync_item)
	{
		new_items->Remove(sync_item);
		sync_item->SetDataSyncItem(0);
		OP_DELETE(sync_item);
		sync_item = 0;
	}
	OP_DELETE(new_items);
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

/**
 * This subtest verifies that the specified OpSyncCoordinator has an
 * OpSyncDataItem with the current encrypted encryption-key in the active
 * OpSyncDataCollection.
 * @param coordinator is the OpSyncCoordinator to test.
 * @param encrypted_key is the expected encrypted encryption-key.
 */
subtest SyncCoordinatorHasEncryptionKeySyncDataItem(OpSyncCoordinator* coordinator, const OpStringC& encrypted_key)
{
	OpSyncCoordinator::SelftestHelper sync_helper(coordinator);
	OpSyncDataQueue* data_queue = sync_helper.GetSyncDataQueue();
	verify(data_queue);
	OpSyncDataCollection* collection = data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_ACTIVE);
	verify(collection);
	OpSyncDataItem* data_item = 0;
	unsigned int count_encryption_key_items = 0;
	for (OpSyncDataItemIterator item(collection->First()); *item; ++item)
	{
		if (item->GetType() == OpSyncDataItem::DATAITEM_ENCRYPTION_KEY)
		{
			count_encryption_key_items++;
			data_item = *item;
		}
	}
	verify(count_encryption_key_items == 1);
	verify(data_item);
	verify(data_item->GetStatus() == OpSyncDataItem::DATAITEM_ACTION_ADDED);
	verify_string(data_item->m_key, "id");
	verify_string(data_item->m_data, "0");
	verify(data_item->HasChildren());
	OpSyncDataItem* child = data_item->FindChildById(UNI_L(""));
	verify_string(child->m_data, encrypted_key);
}

test("Generate new encryption key")
require init;
require PREFS_WRITE;
require WAND_SUPPORT;
require success "IsWaitingForEncryptionKey";
{
	/* This test verifies that the initial workflow: if no encryption-key is on
	 * the server and no encryption-key is stored in wand, then the
	 * SyncEncryptionKeyManager generates a new random encryption-key.
	 * The generated encryption-key shall also be prepared to be sent to the
	 * Link server on the next connection. */
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zap"));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...
	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

	/* Now we emulate the end of the first sync connection. So we expect the
	 * SyncEncryptionKeyManager to find that there is no encryption-key in the
	 * wand emulation and thus generate a new key: */
	OpSyncState sync_state;
	encryption_key_manager.OnSyncFinished(sync_state);
	verify(encryption_key_manager.HasEncryptionKey());
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(key_helper.WandPassword().HasContent());

	/* verify that we have a valid encryption-key: */
	UINT8 bin_key[16];
	OpString encryption_key;
	verify_success(encryption_key_manager.GetEncryptionKey().Decrypt(encryption_key, username, password));
	verify_string(encryption_key, key_helper.WandPassword());
	/* the encryption-key is expected to be a hex-string with 32 characters,
	 * which can be converted to 16 bytes: */
	verify(encryption_key.Length() == 32);
	verify_success(encryption_key_manager.GetEncryptionKey().Decrypt(bin_key, username, password));

	/* verify that the coordinator now has a sync-item */
	/* Note: as we don't re-encrypt the encryption-key when storing the
	 * encrypted encryption-key in the sync-item, the blob shall be the same: */
	OpString encrypted_key;
	verify_success(encryption_key_manager.GetEncryptionKey().GetEncryptedEncryptionKey(encrypted_key));
	verify(SyncCoordinatorHasEncryptionKeySyncDataItem(&coordinator, encrypted_key));
}
finally
{
	/* TODO: clean-up the created sync-items from the coordinator */
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

test("Generate new encryption key resets pm sync-state")
require init;
require PREFS_WRITE;
require WAND_SUPPORT;
require success "Generate new encryption key";
{
	/* This test verifies that on generating a new encryption-key the sync-state
	 * for the SYNC_SUPPORTS_PASSWORD_MANAGER is reset. So in the next sync
	 * connection we request a backlog_since="0" for the password manager: */
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	const OpStringC sync_state_pm(g_pcsync->GetStringPref(PrefsCollectionSync::SyncClientStatePasswordManager));
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));
	if (sync_state_pm == "0")
		TRAP(status, g_pcsync->WriteStringL(PrefsCollectionSync::SyncClientStatePasswordManager, UNI_L("123")));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zap"));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...
	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

	/* Now we emulate the end of the first sync connection. So we expect the
	 * SyncEncryptionKeyManager to find that there is no encryption-key in the
	 * wand emulation and thus generate a new key: */
	OpSyncState sync_state;
	encryption_key_manager.OnSyncFinished(sync_state);
	verify(encryption_key_manager.HasEncryptionKey());
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(key_helper.WandPassword().HasContent());
	verify(sync_helper.GetSyncState().IsDefaultValue(SYNC_SUPPORTS_PASSWORD_MANAGER));
}
finally
{
	/* TODO: clean-up the created sync-items from the coordinator */
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	TRAP(status, g_pcsync->WriteStringL(PrefsCollectionSync::SyncClientStatePasswordManager, sync_state_pm));
}

foreach (test_name, encrypted_key, decrypted_key, expected_decrypted_key) from received_encryption_key
{
	test("Load " test_name " encryption-key from wand")
	require init;
	require PREFS_WRITE;
	require WAND_SUPPORT;
	require success "IsWaitingForEncryptionKey";
	{
		/* This test verifies that the initial workflow, where we don't receive
		 * an encryption-key from the server, but there is an encryption-key
		 * entry in wand:
		 * - test_name == "simple" tests that we can load a valid encryption-key
		 *   from wand, which is then stored in the OpSyncCoordinator and
		 *   a corresponding sync-item is prepared to be sent to Link.
		 * - The other tests verify the case where wand has an entry for the
		 *   encryption-key which has an invalid content. I.e. the content is
		 *   not a hex-string of length 32. In this case the wand-entry is
		 *   deleted and we continue to wait for an encryption-key from Link
		 *   (and there is not item to send to Link).
		 *   Note (this step is not tested here): Waiting means that after the
		 *   next connection (where again we don't receive an encryption-key) we
		 *   no longer have a wand-entry for the encryption-key (it was
		 *   deleted), so a new key is generated.
		 */
		OP_STATUS status;
		const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
		const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
		if (!sync_passwords)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
		if (!sync_enabled)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

		const OpStringC username(UNI_L("zog"));
		const OpStringC password(UNI_L("zap"));

		ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
		OpSyncCoordinator coordinator;
		verify(factory);
		verify_success(coordinator.Init(factory, FALSE));
		factory = 0; // now the coordinator owns the factory ...
		SyncEncryptionKeyManager encryption_key_manager;
		SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
		TRAP(status, encryption_key_manager.InitL(&coordinator));
		verify_success(status);
		verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

		/* Now we store the decrypted encryption-key in the wand emulation (but
		 * not in the SyncEncryptionKeyManager) such that the
		 * SyncEncryptionKeyManager can find it in wand: */
		verify_success(key_helper.StoreLoginWithoutWindow(UNI_L("opera:encryption-key"), username, decrypted_key));
		if (decrypted_key && *decrypted_key)
			verify(key_helper.WandPassword().HasContent());
		verify(!encryption_key_manager.HasEncryptionKey());

		/* Now we can emulate the end of the sync connection. The
		 * SyncEncryptionKeyManager did not receive an encryption-key, so it
		 * will try to get it from wand: */
		OpSyncState sync_state;
		encryption_key_manager.OnSyncFinished(sync_state);
		if (expected_decrypted_key)
		{	/* if we expect success, we can verify that we have it: */
			verify(encryption_key_manager.HasEncryptionKey());
			verify(!key_helper.IsWaitingForEncryptionKey());
			verify(key_helper.WandPassword().HasContent());

			/* verify that we have the same encryption-key: */
			OpString encryption_key;
			UINT8 encryption_key_bin[16]; // ARRAY OK 2011-02-15 markuso
			verify_success(encryption_key_manager.GetEncryptionKey().Decrypt(encryption_key, encryption_key_bin, username, password));
			verify_string(encryption_key, key_helper.WandPassword());
			verify_string(encryption_key, decrypted_key);

			/* verify that the coordinator now has a sync-item */
			/* Note: as we don't re-encrypt the encryption-key when storing the
			 * encrypted encryption-key in the sync-item, the blob shall be the
			 * same as the one in the current encryption_key_manager, but it may
			 * be different to the encrypted_key from the table: */
			OpString encrypted_encryption_key;
			verify_success(encryption_key_manager.GetEncryptionKey().GetEncryptedEncryptionKey(encrypted_encryption_key));
			verify(SyncCoordinatorHasEncryptionKeySyncDataItem(&coordinator, encrypted_encryption_key));
		}
		else
		{	/* The encryption-key in wand was invalid, so it shall have been
			 * deleted from wand: */
			verify(!encryption_key_manager.HasEncryptionKey());
			verify(key_helper.IsWaitingForEncryptionKey());
			verify(!key_helper.WandPassword().HasContent());
		}
	}
	finally
	{
		/* TODO: clean-up the created sync-items from the coordinator */
		OP_DELETE(factory);
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	}
}

foreach (test_name, encrypted_key, decrypted_key, expected_decrypted_key) from received_encryption_key
{
	test("Load " test_name " encryption key from wand delayed")
	require init;
	require PREFS_WRITE;
	require WAND_SUPPORT;
	require success "IsWaitingForEncryptionKey";
	{
		/* This test verifies that the initial workflow, where we don't receive
		 * an encryption-key from the server, but there is an encryption-key
		 * entry in wand and (in contrast to the test("Load <test_name>
		 * encryption key from wand")) the WandLoginCallback is delayed, i.e. it
		 * is called after OnSyncFinished() has returned to the caller:
		 * - test_name == "simple" tests that we can load a valid encryption-key
		 *   from wand, which is then stored in the OpSyncCoordinator and
		 *   a corresponding sync-item is prepared to be sent to Link.
		 * - The other tests verify the case where wand has an entry for the
		 *   encryption-key which has an invalid content. I.e. the content is
		 *   not a hex-string of length 32. In this case the wand-entry is
		 *   deleted and we continue to wait for an encryption-key from Link
		 *   (and there is not item to send to Link).
		 *   Note (this step is not tested here): Waiting means that after the
		 *   next connection (where again we don't receive an encryption-key) we
		 *   no longer have a wand-entry for the encryption-key (it was
		 *   deleted), so a new key is generated.
		 */
		OP_STATUS status;
		const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
		const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
		if (!sync_passwords)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
		if (!sync_enabled)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

		const OpStringC username(UNI_L("zog"));
		const OpStringC password(UNI_L("zap"));

		ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
		OpSyncCoordinator coordinator;
		verify(factory);
		verify_success(coordinator.Init(factory, FALSE));
		factory = 0; // now the coordinator owns the factory ...
		SyncEncryptionKeyManager encryption_key_manager;
		SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
		TRAP(status, encryption_key_manager.InitL(&coordinator));
		verify_success(status);
		verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

		/* Now we store the decrypted encryption-key in the wand emulation (but
		 * not in the SyncEncryptionKeyManager) such that the
		 * SyncEncryptionKeyManager can find it in wand: */
		verify_success(key_helper.StoreLoginWithoutWindow(UNI_L("opera:encryption-key"), username, decrypted_key));
		if (decrypted_key && *decrypted_key)
			verify(key_helper.WandPassword().HasContent());
		verify(!encryption_key_manager.HasEncryptionKey());

		/* Now we can emulate the end of the sync connection. The
		 * SyncEncryptionKeyManager did not receive an encryption-key, so it
		 * will try to get it from wand, but don't call the WandLoginCallback
		 * until we say so: */
		key_helper.DelayWandLoginCallback();
		OpSyncState sync_state;
		encryption_key_manager.OnSyncFinished(sync_state);
		verify(!encryption_key_manager.HasEncryptionKey());
		verify(!key_helper.IsWaitingForEncryptionKey());
		if (decrypted_key && *decrypted_key)
			verify(key_helper.WandPassword().HasContent());

		// Now call the WandLoginCallback:
		verify_success(key_helper.CallWandLoginCallback());
		if (expected_decrypted_key)
		{	/* if we expect to load a valid key, verify that we have it: */
			verify(encryption_key_manager.HasEncryptionKey());
			verify(!key_helper.IsWaitingForEncryptionKey());
			verify(key_helper.WandPassword().HasContent());

			/* verify that we have the same encryption-key: */
			OpString encryption_key;
			UINT8 encryption_key_bin[16]; // ARRAY OK 2011-02-15 markuso
			verify_success(encryption_key_manager.GetEncryptionKey().Decrypt(encryption_key, encryption_key_bin, username, password));
			verify_string(encryption_key, key_helper.WandPassword());
			verify_string(encryption_key, decrypted_key);

			/* verify that the coordinator now has a sync-item */
			/* Note: as we don't re-encrypt the encryption-key when storing the
			 * encrypted encryption-key in the sync-item, the blob shall be the
			 * same as the one in the current encryption_key_manager, but it may
			 * be different to the encrypted_key from the table: */
			OpString encrypted_encryption_key;
			verify_success(encryption_key_manager.GetEncryptionKey().GetEncryptedEncryptionKey(encrypted_encryption_key));
			verify(SyncCoordinatorHasEncryptionKeySyncDataItem(&coordinator, encrypted_encryption_key));
		}
		else
		{	/* The encryption-key in wand was invalid, so it shall have been
			 * deleted from wand: */
			verify(!encryption_key_manager.HasEncryptionKey());
			verify(key_helper.IsWaitingForEncryptionKey());
			verify(!key_helper.WandPassword().HasContent());
		}
	}
	finally
	{
		/* TODO: clean-up the created sync-items from the coordinator */
		OP_DELETE(factory);
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	}
}

foreach (test_name, encrypted_key, decrypted_key, expected_decrypted_key) from received_encryption_key
{
	test("Receive encryption-key after changed Account pwd; load " test_name " from wand")
	require init;
	require PREFS_WRITE;
	require WAND_SUPPORT;
	require success "IsWaitingForEncryptionKey";
	{
		/* This test emulates a response from the Link server sending an
		 * encryption-key which cannot be decrypted in the client. This happens
		 * e.g. when the user changed the Opera Account password.
		 * It is expected that the encrypted encryption-key is then loaded from
		 * wand
		 * - test_name == "simple" tests that we can load a valid encryption-key
		 *   from wand, which is then stored in the OpSyncCoordinator and
		 *   a corresponding sync-item is prepared to be sent to Link.
		 * - The other tests verify the case where wand has an entry for the
		 *   encryption-key which has an invalid content. I.e. the content is
		 *   not a hex-string of length 32. In this case the wand-entry is
		 *   deleted and we shall ask the user to try to decrypt the received
		 *   encryption-key with the old Opera Account password.
		 */
		OP_STATUS status;
		const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
		const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
		if (!sync_passwords)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
		if (!sync_enabled)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

		const OpStringC username(UNI_L("zog"));
		const OpStringC password(UNI_L("zar"));

		ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
		OpSyncCollection* new_items = OP_NEW(OpSyncCollection, ());
		OpSyncItem* sync_item = 0;
		OpSyncCoordinator coordinator;
		ST_SyncUIListener ui_listener;
		verify(factory);
		verify(new_items);
		verify_success(coordinator.Init(factory, FALSE));
		verify_success(coordinator.SetSyncUIListener(&ui_listener));
		factory = 0; // now the coordinator owns the factory ...
		SyncEncryptionKeyManager encryption_key_manager;
		SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
		TRAP(status, encryption_key_manager.InitL(&coordinator));
		verify_success(status);
		verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

		/* Now we store the decrypted encryption-key in the wand emulation (but
		 * not in the SyncEncryptionKeyManager) such that the
		 * SyncEncryptionKeyManager can find it in wand: */
		verify_success(key_helper.StoreLoginWithoutWindow(UNI_L("opera:encryption-key"), username, decrypted_key));
		verify(key_helper.IsWaitingForEncryptionKey());
		verify(encryption_key_manager.IsSupportEnabled());
		if (decrypted_key && *decrypted_key)
			verify(key_helper.WandPassword().HasContent());
		verify(!encryption_key_manager.HasEncryptionKey());

		/* Create a sync item that contains the encryption-key that cannot be
		 * decrypted (because we have a different password here). (Note: for
		 * this test it does not matter that the encrypted encryption-key is the
		 * same one that is stored in wand, i.e. in contains an invalid value):
		 */
		verify(CreateEncryptionKeyItem(coordinator, &sync_item, encrypted_key));
		new_items->AddItem(sync_item);

		verify(ui_listener.GetLastError() == SYNC_OK);
		/* tell the SyncEncryptionKeyManager that data has arrived: */
		key_helper.DelayWandLoginCallback();
		OpSyncDataError data_error = SYNC_DATAERROR_NONE;
		verify_success(encryption_key_manager.SyncDataAvailable(new_items, data_error));
		verify(ui_listener.GetLastError() == SYNC_OK);

		/* now we received the encryption-key, so we no longer wait for it: */
		verify(!key_helper.IsWaitingForEncryptionKey());
		verify(encryption_key_manager.IsSupportEnabled());
		/* But the encrypted encryption-key cannot be decrypted, so the manager
		 * should not yet have an encryption-key: */
		verify(!encryption_key_manager.HasEncryptionKey());

		/* Now tell the SyncEncryptionKeyManager that the encryption-key is
		 * loaded from wand: */
		verify_success(key_helper.CallWandLoginCallback());
		if (expected_decrypted_key)
		{	/* if we expect to load a valid key, verify that we have it: */
			verify(encryption_key_manager.HasEncryptionKey());

			OpString encryption_key;
			verify_success(encryption_key_manager.GetEncryptionKey().Decrypt(encryption_key, username, password));
			verify_string(encryption_key, key_helper.WandPassword());
			verify_string(encryption_key, decrypted_key);

			/* verify that the coordinator now has a sync-item with the expected
			 * encrypted encryption-key:
			 * Note: as we don't re-encrypt the encryption-key when storing the
			 * encrypted encryption-key in the sync-item, the blob shall be the
			 * same as the one in the current encryption_key_manager, but it may
			 * be different to the encrypted_key from the table: */
			OpString encrypted_encryption_key;
			verify_success(encryption_key_manager.GetEncryptionKey().GetEncryptedEncryptionKey(encrypted_encryption_key));
			verify(SyncCoordinatorHasEncryptionKeySyncDataItem(&coordinator, encrypted_encryption_key));
		}
		else
		{	/* The encryption-key in wand was invalid, so it shall have been
			 * deleted from wand: */
			verify(!encryption_key_manager.HasEncryptionKey());
			verify(!key_helper.WandPassword().HasContent());
			// and the ui_listener shall have been notified:
			verify(ui_listener.HasReencryptContext());
			/* and we shall not start waiting for an encryption-key, because
			 * the user shall have the possibility to enter the old password: */
			verify(!key_helper.IsWaitingForEncryptionKey());
		}
	}
	finally
	{
		if (sync_item)
		{
			new_items->Remove(sync_item);
			sync_item->SetDataSyncItem(0);
			OP_DELETE(sync_item);
			sync_item = 0;
		}
		OP_DELETE(new_items);
		OP_DELETE(factory);
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	}
}

foreach (test_name, encrypted_key, decrypted_key, expected_decrypted_key) from received_encryption_key
{
	test("Receive " test_name " encryption-key after changed Account pwd; empty wand, user enters old password")
	require init;
	require PREFS_WRITE;
	require WAND_SUPPORT;
	require success "Receive encryption-key after changed Account pwd; load simple from wand";
	{
		/* This test emulates a response from the Link server sending an
		 * encryption-key which cannot be decrypted in the client. This happens
		 * e.g. when the user changed the Opera Account password.
		 * If there is no encryption-key in wand, then the OpSyncUIListener
		 * shall be notified about this event (by calling the method
		 * OpSyncUIListener::OnSyncReencryptEncryptionKeyFailed()). The ui may
		 * then show a dialog where the user can enter the old Opera Account
		 * password and thus continue the operation: */
		OP_STATUS status;
		const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
		const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
		if (!sync_passwords)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
		if (!sync_enabled)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

		const OpStringC username(UNI_L("zog"));
		const OpStringC password(UNI_L("zar"));

		ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
		OpSyncCollection* new_items = OP_NEW(OpSyncCollection, ());
		OpSyncItem* sync_item = 0;
		OpSyncCoordinator coordinator;
		ST_SyncUIListener ui_listener;
		verify(factory);
		verify(new_items);
		verify_success(coordinator.Init(factory, FALSE));
		verify_success(coordinator.SetSyncUIListener(&ui_listener));
		factory = 0; // now the coordinator owns the factory ...
		SyncEncryptionKeyManager encryption_key_manager;
		SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
		TRAP(status, encryption_key_manager.InitL(&coordinator));
		verify_success(status);
		verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));
		ST_EncryptionKeyListener encryption_key_listener(&encryption_key_manager);

		verify(key_helper.IsWaitingForEncryptionKey());
		verify(encryption_key_manager.IsSupportEnabled());
		// now the encryption-key is not stored in wand:
		if (decrypted_key && *decrypted_key)
			verify(!key_helper.WandPassword().HasContent());
		verify(!encryption_key_manager.HasEncryptionKey());
		verify(encryption_key_listener.Count() == 0);
		verify(encryption_key_listener.CountDeleted() == 0);

		/* Create a sync item that contains the encryption-key that cannot be
		 * decrypted: */
		verify(CreateEncryptionKeyItem(coordinator, &sync_item, encrypted_key));
		new_items->AddItem(sync_item);

		verify(ui_listener.GetLastError() == SYNC_OK);
		/* tell the SyncEncryptionKeyManager that data has arrived: */
		OpSyncDataError data_error = SYNC_DATAERROR_NONE;
		verify_success(encryption_key_manager.SyncDataAvailable(new_items, data_error));
		verify(ui_listener.GetLastError() == SYNC_OK);

		/* now we received the encryption-key, so we no longer wait for it: */
		verify(!key_helper.IsWaitingForEncryptionKey());
		verify(encryption_key_manager.IsSupportEnabled());
		/* we failed to decrypt the encryption-key, so the manager should not
		 * yet have an encryption-key: */
		verify(!encryption_key_manager.HasEncryptionKey());
		// but the ui_listener shall have been notified:
		verify(ui_listener.HasReencryptContext());
		verify(encryption_key_listener.Count() == 0);
		verify(encryption_key_listener.CountDeleted() == 0);

		/* 1. tell the context a wrong password - then the ui-listener will be
		 * notified again: */
		ui_listener.ReencryptDecryptWithPassword(UNI_L("foo"));
		verify(ui_listener.GetLastError() == SYNC_OK);
		verify(ui_listener.HasReencryptContext());
		verify(encryption_key_listener.Count() == 0);
		verify(encryption_key_listener.CountDeleted() == 0);

		/* 2. tell the context the correct password - then the ui-listener will
		 * not be notified again: */
		ui_listener.ReencryptDecryptWithPassword(UNI_L("zap"));
		verify(ui_listener.GetLastError() == SYNC_OK);
		verify(!ui_listener.HasReencryptContext());
		if (expected_decrypted_key)
		{
			/* if we expect to receive a valid key, verify that we have it: */
			verify(encryption_key_manager.HasEncryptionKey());
			verify(encryption_key_listener.Count() == 1);
			verify(encryption_key_listener.CountDeleted() == 0);

			OpString encryption_key;
			UINT8 encryption_key_bin[16]; // ARRAY OK 2011-02-15 markuso
			verify_success(encryption_key_manager.GetEncryptionKey().Decrypt(encryption_key, encryption_key_bin, username, password));
			verify_string(encryption_key, key_helper.WandPassword());
			verify_string(encryption_key, decrypted_key);

			/* verify that the coordinator now has a sync-item with the expected
			 * encrypted encryption-key:
			 * Note: as we don't re-encrypt the encryption-key when storing the
			 * encrypted encryption-key in the sync-item, the blob shall be the
			 * same as the one in the current encryption_key_manager, but it may
			 * be different to the encrypted_key from the table: */
			OpString encrypted_encryption_key;
			verify_success(encryption_key_manager.GetEncryptionKey().GetEncryptedEncryptionKey(encrypted_encryption_key));
			verify(SyncCoordinatorHasEncryptionKeySyncDataItem(&coordinator, encrypted_encryption_key));
		}
		else
		{	/* The received encryption-key was invalid, so it shall have been
			 * deleted: */
			verify(!encryption_key_manager.HasEncryptionKey());
			verify(key_helper.IsWaitingForEncryptionKey());
			verify(!key_helper.WandPassword().HasContent());
			verify(encryption_key_listener.Count() == 0);
			verify(encryption_key_listener.CountDeleted() == 1);
		}
	}
	finally
	{
		if (sync_item)
		{
			new_items->Remove(sync_item);
			sync_item->SetDataSyncItem(0);
			OP_DELETE(sync_item);
			sync_item = 0;
		}
		OP_DELETE(new_items);
		OP_DELETE(factory);
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	}
}

test("Receive encryption-key after changed Account pwd; empty wand, user selects delete")
require init;
require PREFS_WRITE;
require WAND_SUPPORT;
require success "Receive encryption-key after changed Account pwd; load simple from wand";
{
	/* This test emulates a response from the Link server sending an
	 * encryption-key which cannot be decrypted in the client. This happens
	 * e.g. when the user changed the Opera Account password.
	 * If there is no encryption-key in wand, then the OpSyncUIListener shall
	 * be notified about this event (by calling the method
	 * OpSyncUIListener::OnSyncReencryptEncryptionKeyFailed()). The ui may then
	 * show a dialog where the user can select to create a new encryption-key
	 * and delete the existing wand data: */
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zar"));
	const OpStringC encrypted_key(simple_encrypted_key);

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCollection* new_items = OP_NEW(OpSyncCollection, ());
	OpSyncItem* sync_item = 0;
	OpSyncCoordinator coordinator;
	ST_SyncUIListener ui_listener;
	verify(factory);
	verify(new_items);
	verify_success(coordinator.Init(factory, FALSE));
	verify_success(coordinator.SetSyncUIListener(&ui_listener));
	factory = 0; // now the coordinator owns the factory ...
	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

	verify(key_helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	// now the encryption-key is not stored in wand:
	verify(!key_helper.WandPassword().HasContent());
	verify(!encryption_key_manager.HasEncryptionKey());

	/* Create a sync item that contains the encryption-key that cannot be
	 * decrypted: */
	verify(CreateEncryptionKeyItem(coordinator, &sync_item, encrypted_key));
	new_items->AddItem(sync_item);

	verify(ui_listener.GetLastError() == SYNC_OK);
	/* tell the SyncEncryptionKeyManager that data has arrived: */
	OpSyncDataError data_error = SYNC_DATAERROR_NONE;
	verify_success(encryption_key_manager.SyncDataAvailable(new_items, data_error));
	verify(ui_listener.GetLastError() == SYNC_OK);

	/* now we received the encryption-key, so we no longer wait for it: */
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	/* the encryption-key was invalid, so the manager should not yet have an
	 * encryption-key: */
	verify(!encryption_key_manager.HasEncryptionKey());
	// but the ui_listener shall have been notified:
	verify(ui_listener.HasReencryptContext());

	/* 1. tell the context to create a new encryption key: */
	ui_listener.ReencryptCreateNewEncryptionKey();
	verify(ui_listener.GetLastError() == SYNC_OK);
	verify(!ui_listener.HasReencryptContext());
	verify(encryption_key_manager.HasEncryptionKey());

	OpString encryption_key;
	verify_success(encryption_key_manager.GetEncryptionKey().Decrypt(encryption_key, username, password));
	verify_string(encryption_key, key_helper.WandPassword());

	/* verify that the coordinator now has a sync-item with the expected
	 * encrypted encryption-key:
	 * Note: as we don't re-encrypt the encryption-key when storing the
	 * encrypted encryption-key in the sync-item, the blob shall be the same: */
	OpString new_encrypted_key;
	verify_success(encryption_key_manager.GetEncryptionKey().GetEncryptedEncryptionKey(new_encrypted_key));
	verify(SyncCoordinatorHasEncryptionKeySyncDataItem(&coordinator, new_encrypted_key));
}
finally
{
	if (sync_item)
	{
		new_items->Remove(sync_item);
		sync_item->SetDataSyncItem(0);
		OP_DELETE(sync_item);
		sync_item = 0;
	}
	OP_DELETE(new_items);
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

test("Reencrypt encryption-key")
require init;
require success "IsWaitingForEncryptionKey";
{
	/* This test verifies that calling
	 * SyncEncryptionKeyManager::ReencryptEncryptionKey() successfully
	 * re-encrypts an existing encryption-key and creates an OpSyncDataItem in
	 * the active sync-queue. */
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zap"));
	const OpStringC encrypted_key(simple_encrypted_key);
	const OpStringC decrypted_key(simple_decrypted_key);

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...

	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);

	/* Initialise the coordinator and the encryption_key_manager such that both
	 * use the same Opera Account credentials and the encryption-key of the
	 * SyncEncryptionKeyManager is set: */
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	ST_EncryptionKeyListener encryption_key_listener(&encryption_key_manager);
	key_helper.SetEncryptionKey(encrypted_key, decrypted_key, username);
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(key_helper.WandPassword().HasContent());
	verify(encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_listener.Count() == 0);
	verify(encryption_key_listener.CountDeleted() == 0);

	/* Now re-encrypt the existing encryption-key with the new password: */
	const OpStringC new_password(UNI_L("zak"));
	verify_success(encryption_key_manager.ReencryptEncryptionKey(username, password, new_password));
	/* the EncryptionKeyListener is not notified, because the existing
	 * encryption-key is re-encrypted but not changed: */
	verify(encryption_key_listener.Count() == 0);
	verify(encryption_key_listener.CountDeleted() == 0);

	OpString key;
	// decrypting with the old password shall fail:
	verify(encryption_key_manager.GetEncryptionKey().Decrypt(key, username, password) == OpStatus::ERR_NO_ACCESS);
	/* decrypting with the new password shall succeed and yield the old
	 * decrypted key: */
	verify_success(encryption_key_manager.GetEncryptionKey().Decrypt(key, username, new_password));
	verify_string(key, decrypted_key);

	/* verify that the coordinator now has a sync-item with the expected
	 * encrypted encryption-key: */
	OpString new_encrypted_key;
	verify_success(encryption_key_manager.GetEncryptionKey().GetEncryptedEncryptionKey(new_encrypted_key));
	verify(SyncCoordinatorHasEncryptionKeySyncDataItem(&coordinator, new_encrypted_key));
}
finally
{
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

test("Reencrypt encryption-key fails")
require init;
require success "Reencrypt encryption-key";
{
	/* This test verifies that if
	 * SyncEncryptionKeyManager::ReencryptEncryptionKey() fails, the
	 * encryption-key is cleared and the OpSyncCoordinator instance starts
	 * waiting to receive the encryption-key from the Link server in the next
	 * connection. The failure is here emulated by using the wrong credentials,
	 * so the current encrypted encryption-key cannot be decrypted. */
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	const OpStringC username(UNI_L("zog"));
	const OpStringC wrong_password(UNI_L("zal"));
	const OpStringC encrypted_key(simple_encrypted_key);
	const OpStringC decrypted_key(simple_decrypted_key);

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...

	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);

	/* Initialise the coordinator and the encryption_key_manager such that both
	 * use the same Opera Account credentials and the encryption-key of the
	 * SyncEncryptionKeyManager is set: */
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	ST_EncryptionKeyListener encryption_key_listener(&encryption_key_manager);
	key_helper.SetEncryptionKey(encrypted_key, decrypted_key, username);
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(key_helper.WandPassword().HasContent());
	verify(encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_listener.Count() == 0);
	verify(encryption_key_listener.CountDeleted() == 0);

	/* Now re-encrypt the existing encryption-key with the new password: */
	const OpStringC new_password(UNI_L("zak"));
	/* Expect to fail, because password is not correct: */
	verify(encryption_key_manager.ReencryptEncryptionKey(username, wrong_password, new_password), OpStatus::ERR_NO_ACCESS);
	// Now there is no more encryption-key:
	verify(!encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_listener.Count() == 0);
	verify(encryption_key_listener.CountDeleted() == 1);
	// and we wait for the encryption-key from the server:
	verify(key_helper.IsWaitingForEncryptionKey());
	// but the encryption-key is still stored in wand:
	verify(key_helper.WandPassword().HasContent());
}
finally
{
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

test("Change encryption key twice creates one sync-item")
{
	/* Verifies that generating a new encryption-key twice (before sending
	 * the data to the Link server) results in only one single sync-item. */
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zap"));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...

	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

	// To avoid an assert, reset the encryption-key before generating a new key:
	key_helper.SetEncryptionKey(UNI_L(""), UNI_L(""), UNI_L(""));
	verify_success(encryption_key_manager.GenerateNewEncryptionKey());
	// To avoid an assert, reset the encryption-key before generating a new key:
	key_helper.SetEncryptionKey(UNI_L(""), UNI_L(""), UNI_L(""));
	verify_success(encryption_key_manager.GenerateNewEncryptionKey());

	OpString new_encrypted_key;
	verify_success(encryption_key_manager.GetEncryptionKey().GetEncryptedEncryptionKey(new_encrypted_key));
	verify(SyncCoordinatorHasEncryptionKeySyncDataItem(&coordinator, new_encrypted_key));
}
finally
{
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

subtest TestLoginInformation(OpSyncCoordinator* coordinator, const OpStringC& expected_username, const OpStringC& expected_password)
{
	OpString username;
	OpString password;
	verify_success(coordinator->GetLoginInformation(username, password));
	verify_string(username, expected_username);
	verify_string(password, expected_password);
}

test("Change login password")
require init;
require success "Reencrypt encryption-key";
{
	/* This test verifies that calling
	 * OpSyncCoordinator::SetLoginInformation() with a new password (and the
	 * same username) successfully re-encrypts an existing encryption-key and
	 * creates an OpSyncDataItem in the active sync-queue. */
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zap"));
	const OpStringC encrypted_key(simple_encrypted_key);
	const OpStringC decrypted_key(simple_decrypted_key);

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...

	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
	/* Initialise the coordinator and the encryption_key_manager such that both
	 * use the same Opera Account credentials and the encryption-key of the
	 * SyncEncryptionKeyManager is set: */
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));
	key_helper.SetEncryptionKey(encrypted_key, decrypted_key, username);
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(key_helper.WandPassword().HasContent());
	verify(encryption_key_manager.HasEncryptionKey());

	/* Now change the password: */
	const OpStringC new_password(UNI_L("zak"));
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, new_password));

	// the coordinator shall now hold the new password:
	verify(TestLoginInformation(&coordinator, username, new_password));

	OpString key;
	// decrypting with the old password shall fail:
	verify(encryption_key_manager.GetEncryptionKey().Decrypt(key, username, password) == OpStatus::ERR_NO_ACCESS);
	/* decrypting with the new password shall succeed and yield the old
	 * decrypted key: */
	verify_success(encryption_key_manager.GetEncryptionKey().Decrypt(key, username, new_password));
	verify_string(key, decrypted_key);

	/* verify that the coordinator now has a sync-item with the expected
	 * encrypted encryption-key: */
	OpString new_encrypted_key;
	verify_success(encryption_key_manager.GetEncryptionKey().GetEncryptedEncryptionKey(new_encrypted_key));
	verify(SyncCoordinatorHasEncryptionKeySyncDataItem(&coordinator, new_encrypted_key));
}
finally
{
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

test("Change login username")
require init;
require success "Reencrypt encryption-key";
{
	/* This test verifies that calling
	 * OpSyncCoordinator::SetLoginInformation() with a new username clears the
	 * existing encryption-key. */
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zap"));
	const OpStringC encrypted_key(simple_encrypted_key);
	const OpStringC decrypted_key(simple_decrypted_key);

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...

	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
	/* Initialise the coordinator and the encryption_key_manager such that both
	 * use the same Opera Account credentials and the encryption-key of the
	 * SyncEncryptionKeyManager is set: */
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));
	key_helper.SetEncryptionKey(encrypted_key, decrypted_key, username);
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(key_helper.WandPassword().HasContent());
	verify(encryption_key_manager.HasEncryptionKey());

	/* Now change the username (keep the password): */
	const OpStringC new_username(UNI_L("zoo"));
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), new_username, password));
	// the coordinator shall now hold the new username/password:
	verify(TestLoginInformation(&coordinator, new_username, password));
	// now we start waiting for the encryption-key from the Link server:
	verify(key_helper.IsWaitingForEncryptionKey());
	// wand still has the encryption-key for the old username/password:
	verify(key_helper.WandPassword().HasContent());
	// the SyncEncryptionKeyManager does not have the encryption-key:
	verify(!encryption_key_manager.HasEncryptionKey());
}
finally
{
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

subtest CreateEncryptionTypeItem(OpSyncCoordinator& coordinator, OpSyncItem** sync_item, const uni_char* encryption_type)
{
	verify(CreateEncryptionSyncItem(coordinator, sync_item, OpSyncDataItem::DATAITEM_ENCRYPTION_TYPE, encryption_type));
}

table test_encryption_type(const char* testname, const uni_char* encryption_type, bool expect_enabled)
{
	{ "empty",			UNI_L(""),				true },
	{ "opera-account",	UNI_L("opera_account"),	true },
	{ "unknown",		UNI_L("unknown type"),	false }
}

/**
 * These tests verify that sending one encryption-key + one encryption-type
 * sync-item is handled correctly.
 * On receiving a support encryption-type, the encryption-key should be stored
 * in wand and listeners should be notified about the availability of the key.
 * On receiving an unknown encryption-type, the encryption-key is not handled.
 */
foreach (testname, encryption_type, expect_enabled) from test_encryption_type
{
	test("encryption-type " testname)
		require init;
	{
		OP_STATUS status;
		const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
		const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
		if (!sync_passwords)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
		if (!sync_enabled)
			TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

		OpSyncItem* sync_item = 0;
		OpSyncCollection new_items;
		ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
		OpSyncCoordinator coordinator;
		ST_SyncUIListener ui_listener;
		verify(factory);
		verify_success(coordinator.Init(factory, FALSE));
		factory = 0; // now the coordinator owns the factory ...
		verify_success(coordinator.SetSyncUIListener(&ui_listener));

		const OpStringC username(UNI_L("zog"));
		const OpStringC password(UNI_L("zap"));
		const OpStringC encrypted_key(simple_encrypted_key);

		SyncEncryptionKeyManager encryption_key_manager;
		SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
		ST_EncryptionKeyListener encryption_key_listener(&encryption_key_manager);
		/* Initialise the coordinator and the encryption_key_manager such that
		 * both use the same Opera Account credentials: */
		TRAP(status, encryption_key_manager.InitL(&coordinator));
		verify_success(status);
		verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

		/* As we don't have an encryption-key yet, we wait for it: */
		verify(key_helper.IsWaitingForEncryptionKey());
		verify(encryption_key_manager.IsSupportEnabled());
		verify(!key_helper.WandPassword().HasContent());
		verify(!encryption_key_manager.HasEncryptionKey());
		verify(encryption_key_listener.Count() == 0);
		verify(encryption_key_listener.CountDeleted() == 0);

		/* Create a sync item that contains the encryption-key: */
		verify(CreateEncryptionKeyItem(coordinator, &sync_item, encrypted_key));
		new_items.AddItem(sync_item);
		sync_item = 0;

		/* Create an encryption-type sync item */
		verify(CreateEncryptionTypeItem(coordinator, &sync_item, encryption_type));
		new_items.AddItem(sync_item);
		sync_item = 0;

		verify(ui_listener.GetLastError() == SYNC_OK);
		/* tell the SyncEncryptionKeyManager that data has arrived: */
		OpSyncDataError data_error = SYNC_DATAERROR_NONE;
		verify_success(encryption_key_manager.SyncDataAvailable(&new_items, data_error));
		verify(ui_listener.GetLastError() == SYNC_OK);

		/* Now that we received a key, we no longer wait for it. */
		verify(!key_helper.IsWaitingForEncryptionKey());
		verify(encryption_key_manager.IsSupportEnabled());
		if (expect_enabled)
		{
			/* If we expect a known type, the key should be stored in wand, and
			 * it should be usable, and listeners should be notified: */
			verify(key_helper.WandPassword().HasContent());
			verify(encryption_key_manager.HasEncryptionKey());
			verify(encryption_key_listener.Count() == 1);
			verify(encryption_key_listener.CountDeleted() == 0);
			verify(encryption_key_manager.IsEncryptionKeyUsable());
		}
		else
		{
			/* If we expect an unknown type, the key should not be stored in
			 * wand, and it should not be usable, and listeners should not be
			 * notified: */
			verify(!key_helper.WandPassword().HasContent());
			verify(!encryption_key_manager.HasEncryptionKey());
			verify(encryption_key_listener.Count() == 0);
			verify(encryption_key_listener.CountDeleted() == 0);
			verify(!encryption_key_manager.IsEncryptionKeyUsable());
		}
	}
	finally
	{
		new_items.Clear();
		OP_DELETE(sync_item);
		OP_DELETE(factory);
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	}
}

/**
 * This test verifies that we can first receive an encryption-key plus an
 * unknown encryption-type and in a second connection receive a known
 * encryption-type which then enables the encryption-key that was received on
 * the first time.
 */
test("encryption-type unknown -> opera_account")
require init;
{
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	OpSyncItem* sync_item = 0;
	OpSyncCollection new_items;
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	ST_SyncUIListener ui_listener;
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...
	verify_success(coordinator.SetSyncUIListener(&ui_listener));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zap"));
	const OpStringC encrypted_key(simple_encrypted_key);

	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
	ST_EncryptionKeyListener encryption_key_listener(&encryption_key_manager);
	/* Initialise the coordinator and the encryption_key_manager such that
	 * both use the same Opera Account credentials: */
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

	/* As we don't have an encryption-key yet, we wait for it: */
	verify(key_helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(!key_helper.WandPassword().HasContent());
	verify(!encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_listener.Count() == 0);
	verify(encryption_key_listener.CountDeleted() == 0);

	/* Create a sync item that contains the encryption-key: */
	verify(CreateEncryptionKeyItem(coordinator, &sync_item, encrypted_key));
	new_items.AddItem(sync_item);
	sync_item = 0;

	/* Create an encryption-type sync item (unknown type) */
	verify(CreateEncryptionTypeItem(coordinator, &sync_item, UNI_L("unknown")));
	new_items.AddItem(sync_item);
	sync_item = 0;

	verify(ui_listener.GetLastError() == SYNC_OK);
	/* tell the SyncEncryptionKeyManager that data has arrived: */
	OpSyncDataError data_error = SYNC_DATAERROR_NONE;
	verify_success(encryption_key_manager.SyncDataAvailable(&new_items, data_error));
	verify(ui_listener.GetLastError() == SYNC_OK);

	/* Now that we received a key, we no longer wait for it. And the key should
	 * not yet be handled, i.e. not stored in wand, no listeners notified: */
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(!key_helper.WandPassword().HasContent());
	verify(!encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(encryption_key_listener.Count() == 0);
	verify(encryption_key_listener.CountDeleted() == 0);
	verify(!encryption_key_manager.IsEncryptionKeyUsable());

	new_items.Clear();

	/* Create an encryption-type sync item (known type) */
	verify(CreateEncryptionTypeItem(coordinator, &sync_item, UNI_L("opera_account")));
	new_items.AddItem(sync_item);
	sync_item = 0;

	verify(ui_listener.GetLastError() == SYNC_OK);
	/* tell the SyncEncryptionKeyManager that data has arrived: */
	data_error = SYNC_DATAERROR_NONE;
	verify_success(encryption_key_manager.SyncDataAvailable(&new_items, data_error));
	verify(ui_listener.GetLastError() == SYNC_OK);

	/* Now we should have handled the key that we received the first time: */
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(key_helper.WandPassword().HasContent());
	verify(encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(encryption_key_listener.Count() == 1);
	verify(encryption_key_listener.CountDeleted() == 0);
	verify(encryption_key_manager.IsEncryptionKeyUsable());
}
finally
{
	new_items.Clear();
	OP_DELETE(sync_item);
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

/**
 * This test verifies that we can first receive an encryption-key, which is then
 * stored in wand, then in a second connection an unknown encryption-type, so
 * the listeners are notified and in a third connection receive a known
 * encryption-type which then enables the encryption-key that was received on
 * the first time.
 */
test("encryption-type unknown -> opera_account.2")
require init;
{
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	OpSyncItem* sync_item = 0;
	OpSyncCollection new_items;
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	ST_SyncUIListener ui_listener;
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...
	verify_success(coordinator.SetSyncUIListener(&ui_listener));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zap"));
	const OpStringC encrypted_key(simple_encrypted_key);

	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
	ST_EncryptionKeyListener encryption_key_listener(&encryption_key_manager);
	/* Initialise the coordinator and the encryption_key_manager such that
	 * both use the same Opera Account credentials: */
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

	/* As we don't have an encryption-key yet, we wait for it: */
	verify(key_helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(!key_helper.WandPassword().HasContent());
	verify(!encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_listener.Count() == 0);
	verify(encryption_key_listener.CountDeleted() == 0);

	/* Create a sync item that contains the encryption-key: */
	verify(CreateEncryptionKeyItem(coordinator, &sync_item, encrypted_key));
	new_items.AddItem(sync_item);
	sync_item = 0;

	verify(ui_listener.GetLastError() == SYNC_OK);
	/* tell the SyncEncryptionKeyManager that data has arrived: */
	OpSyncDataError data_error = SYNC_DATAERROR_NONE;
	verify_success(encryption_key_manager.SyncDataAvailable(&new_items, data_error));
	verify(ui_listener.GetLastError() == SYNC_OK);

	/* Now that we received a key, we no longer wait for it. And the key should
	 * not yet be handled, i.e. not stored in wand, no listeners notified: */
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(key_helper.WandPassword().HasContent());
	verify(encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(encryption_key_listener.Count() == 1);
	verify(encryption_key_listener.CountDeleted() == 0);
	verify(encryption_key_manager.IsEncryptionKeyUsable());

	new_items.Clear();

	/* Create an encryption-type sync item (unknown type) */
	verify(CreateEncryptionTypeItem(coordinator, &sync_item, UNI_L("unknown")));
	new_items.AddItem(sync_item);
	sync_item = 0;

	verify(ui_listener.GetLastError() == SYNC_OK);
	/* tell the SyncEncryptionKeyManager that data has arrived: */
	data_error = SYNC_DATAERROR_NONE;
	verify_success(encryption_key_manager.SyncDataAvailable(&new_items, data_error));
	verify(ui_listener.GetLastError() == SYNC_OK);

	/* Now the key should still be in wand, but not usable and the listener
	 * shall be notified that it was deleted: */
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(key_helper.WandPassword().HasContent());
	verify(encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(encryption_key_listener.Count() == 1);
	verify(encryption_key_listener.CountDeleted() == 1);
	verify(!encryption_key_manager.IsEncryptionKeyUsable());

	new_items.Clear();

	/* Create an encryption-type sync item (known type) */
	verify(CreateEncryptionTypeItem(coordinator, &sync_item, UNI_L("opera_account")));
	new_items.AddItem(sync_item);
	sync_item = 0;

	verify(ui_listener.GetLastError() == SYNC_OK);
	/* tell the SyncEncryptionKeyManager that data has arrived: */
	data_error = SYNC_DATAERROR_NONE;
	verify_success(encryption_key_manager.SyncDataAvailable(&new_items, data_error));
	verify(ui_listener.GetLastError() == SYNC_OK);

	/* Now we should have the key that we received the first time: */
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(key_helper.WandPassword().HasContent());
	verify(encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(encryption_key_listener.Count() == 2);
	verify(encryption_key_listener.CountDeleted() == 1);
	verify(encryption_key_manager.IsEncryptionKeyUsable());
}
finally
{
	new_items.Clear();
	OP_DELETE(sync_item);
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

/**
 * This test verifies that on receiving first an encryption-key and a known
 * encryption-type, we store the encryption-key in wand. Then on receiving an
 * unknown encryption-type, the listeners are notified about the deletion of the
 * encryption-key (though the key is still in wand).
 */
test("encryption-type opera_account -> unknown")
require init;
{
	OP_STATUS status;
	const int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	const int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	if (!sync_passwords)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	if (!sync_enabled)
		TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	OpSyncItem* sync_item = 0;
	OpSyncCollection new_items;
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	ST_SyncUIListener ui_listener;
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...
	verify_success(coordinator.SetSyncUIListener(&ui_listener));

	const OpStringC username(UNI_L("zog"));
	const OpStringC password(UNI_L("zap"));
	const OpStringC encrypted_key(simple_encrypted_key);

	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
	ST_EncryptionKeyListener encryption_key_listener(&encryption_key_manager);
	/* Initialise the coordinator and the encryption_key_manager such that
	 * both use the same Opera Account credentials: */
	TRAP(status, encryption_key_manager.InitL(&coordinator));
	verify_success(status);
	verify_success(coordinator.SetLoginInformation(UNI_L("myopera"), username, password));

	/* As we don't have an encryption-key yet, we wait for it: */
	verify(key_helper.IsWaitingForEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(!key_helper.WandPassword().HasContent());
	verify(!encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_listener.Count() == 0);
	verify(encryption_key_listener.CountDeleted() == 0);

	/* Create a sync item that contains the encryption-key: */
	verify(CreateEncryptionKeyItem(coordinator, &sync_item, encrypted_key));
	new_items.AddItem(sync_item);
	sync_item = 0;

	/* Create an encryption-type sync item (known type) */
	verify(CreateEncryptionTypeItem(coordinator, &sync_item, UNI_L("opera_account")));
	new_items.AddItem(sync_item);
	sync_item = 0;

	verify(ui_listener.GetLastError() == SYNC_OK);
	/* tell the SyncEncryptionKeyManager that data has arrived: */
	OpSyncDataError data_error = SYNC_DATAERROR_NONE;
	verify_success(encryption_key_manager.SyncDataAvailable(&new_items, data_error));
	verify(ui_listener.GetLastError() == SYNC_OK);

	/* Now that we received a key, we no longer wait for it. And the key should
	 * be stored in wand and listeners shall be notified: */
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(key_helper.WandPassword().HasContent());
	verify(encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(encryption_key_listener.Count() == 1);
	verify(encryption_key_listener.CountDeleted() == 0);
	verify(encryption_key_manager.IsEncryptionKeyUsable());

	new_items.Clear();

	/* Create an encryption-type sync item (unknown type) */
	verify(CreateEncryptionTypeItem(coordinator, &sync_item, UNI_L("unknown")));
	new_items.AddItem(sync_item);
	sync_item = 0;

	verify(ui_listener.GetLastError() == SYNC_OK);
	/* tell the SyncEncryptionKeyManager that data has arrived: */
	data_error = SYNC_DATAERROR_NONE;
	verify_success(encryption_key_manager.SyncDataAvailable(&new_items, data_error));
	verify(ui_listener.GetLastError() == SYNC_OK);

	/* After receiving the unknown type we still have the encryption-key, but we
	 * don't use it: */
	verify(!key_helper.IsWaitingForEncryptionKey());
	verify(key_helper.WandPassword().HasContent());
	verify(encryption_key_manager.HasEncryptionKey());
	verify(encryption_key_manager.IsSupportEnabled());
	verify(encryption_key_listener.Count() == 1);
	verify(encryption_key_listener.CountDeleted() == 1);
	verify(!encryption_key_manager.IsEncryptionKeyUsable());
}
finally
{
	new_items.Clear();
	OP_DELETE(sync_item);
	OP_DELETE(factory);
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	TRAP(status, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}
