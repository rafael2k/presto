/* -*- Mode: c++; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*-
 *
 * Copyright (C) 1995-2011 Opera Software AS.  All rights reserved.
 *
 * This file is part of the Opera web browser.
 * It may not be distributed under any circumstances.
 */

group "sync";
require SUPPORT_DATA_SYNC;

include "modules/selftest/src/testutils.h";
include "modules/sync/sync_encryption_key.h";
include "modules/sync/sync_coordinator.h";
include "modules/sync/sync_parser.h";
include "modules/sync/sync_parser_myopera.h";
include "modules/sync/testcases/sync_ST_factory.h";
include "modules/sync/testcases/sync_ST_transport.h";
include "modules/pi/OpSystemInfo.h";
include "modules/util/OpSharedPtr.h";
include "modules/opdata/OpStringStream.h";

// type, primary key data, status, key to check, data it should contain
table Table_ordered_1(OpSyncDataItem::DataItemType, const uni_char*, OpSyncItem::Key, const uni_char*)
{
	// bookmark A
	{ OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK1"), OpSyncItem::SYNC_KEY_TITLE, UNI_L("Test bookmark A") },
	{ OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK1"), OpSyncItem::SYNC_KEY_URI, UNI_L("http://www.opera.com/") },
	{ OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK1"), OpSyncItem::SYNC_KEY_PARENT, UNI_L("") },
	{ OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK1"), OpSyncItem::SYNC_KEY_PREV, UNI_L("") },

	{ OpSyncDataItem::DATAITEM_GENERIC, UNI_L(""), OpSyncItem::SYNC_KEY_NONE, UNI_L("") },

	{ OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER, UNI_L("FOLDER1"), OpSyncItem::SYNC_KEY_TITLE, UNI_L("Test Folder A") },
	{ OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER, UNI_L("FOLDER1"), OpSyncItem::SYNC_KEY_PREV, UNI_L("BOOKMARK1") },

	{ OpSyncDataItem::DATAITEM_GENERIC, UNI_L(""), OpSyncItem::SYNC_KEY_NONE, UNI_L("") },

	// bookmark B
	{ OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK2"), OpSyncItem::SYNC_KEY_TITLE, UNI_L("Test bookmark B") },
	{ OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK2"), OpSyncItem::SYNC_KEY_URI, UNI_L("http://www.cnn.com/") },
	{ OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK2"), OpSyncItem::SYNC_KEY_PARENT, UNI_L("") },
	{ OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK2"), OpSyncItem::SYNC_KEY_PREV, UNI_L("FOLDER1") },

	{ OpSyncDataItem::DATAITEM_GENERIC, UNI_L(""), OpSyncItem::SYNC_KEY_NONE, UNI_L("") },
}

table Table_input_1(const char*,		// name of the test
					condition,
					OpSyncDataItem::DataItemType,// data item type
					const uni_char*,	// value of id attribute
					OpSyncItem::Key,	// key to check
					const uni_char*)	// expected data
{
	/*
	<bookmark_folder status="added" created="2007-06-16T20:19:07Z" id="A3D3DC7746530847BBD01E2047D61FD7" parent="" previous="6E6C44C82B55C0438CDEC9031CF472DA">
	  <panel_pos>-1</panel_pos>
	  <show_in_panel>0</show_in_panel>
	  <personal_bar_pos>-1</personal_bar_pos>
	  <show_in_personal_bar>0</show_in_personal_bar>
	  <nickname/>
	  <description/>
	  <title>W880i</title>
	</bookmark_folder>
	*/
	{
		"bookmark-folder 'W880i' has expected prev attribute",
		SYNC_HAVE_BOOKMARKS,
		OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER, UNI_L("A3D3DC7746530847BBD01E2047D61FD7"),
		OpSyncItem::SYNC_KEY_PREV, UNI_L("6E6C44C82B55C0438CDEC9031CF472DA")
	},
	{
		"bookmark-folder 'W880i' has expected title",
		SYNC_HAVE_BOOKMARKS,
		OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER, UNI_L("A3D3DC7746530847BBD01E2047D61FD7"),
		OpSyncItem::SYNC_KEY_TITLE, UNI_L("W880i")
	},

	/*
	<bookmark status="added" visited="2006-01-13T12:33:54Z" id="BA13D5BBA3BD0E43AE42BB5E437DBED6" parent="D088D4BD58B2A74794D09A85D6D62228" previous="798311ECB4036F479778E9E7B126BA66">
	  <panel_pos>-1</panel_pos>
	  <show_in_panel>0</show_in_panel>
	  <personal_bar_pos>-1</personal_bar_pos>
	  <show_in_personal_bar>0</show_in_personal_bar>
	  <icon/>
	  <nickname/>
	  <description/>
	  <title>http://waxy.org/random/images/weblog/love_your_job.gif</title>
	  <uri>http://waxy.org/random/images/weblog/love_your_job.gif</uri>
	</bookmark>
	*/
	{
		"bookmark 'love_your_job' has expected prev attribute",
		SYNC_HAVE_BOOKMARKS,
		OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BA13D5BBA3BD0E43AE42BB5E437DBED6"),
		OpSyncItem::SYNC_KEY_PREV, UNI_L("798311ECB4036F479778E9E7B126BA66")
	},
	{
		"bookmark 'love_your_job' has expected parent attribute",
		SYNC_HAVE_BOOKMARKS,
		OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BA13D5BBA3BD0E43AE42BB5E437DBED6"),
		OpSyncItem::SYNC_KEY_PARENT, UNI_L("D088D4BD58B2A74794D09A85D6D62228")
	},
	{
		"bookmark 'love_your_job' has expected uri",
		SYNC_HAVE_BOOKMARKS,
		OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BA13D5BBA3BD0E43AE42BB5E437DBED6"),
		OpSyncItem::SYNC_KEY_URI, UNI_L("http://waxy.org/random/images/weblog/love_your_job.gif")
	},

	{
		"pm_form_auth has expected username",
		SYNC_HAVE_PASSWORD_MANAGER,
		OpSyncDataItem::DATAITEM_PM_FORM_AUTH, UNI_L("1234567890ABCDEF1234567890ABCDEF"),
		OpSyncItem::SYNC_KEY_USERNAME, UNI_L("username, encrypted in a blob")
	},
	{
		"pm_form_auth has expected attribute scope",
		SYNC_HAVE_PASSWORD_MANAGER,
		OpSyncDataItem::DATAITEM_PM_FORM_AUTH, UNI_L("1234567890ABCDEF1234567890ABCDEF"),
		OpSyncItem::SYNC_KEY_PM_FORM_AUTH_SCOPE, UNI_L("page")
	},

	/*
	<extension id="9f3ac0ca7d974574b039cc05af781e8a" status="added">
	  <version>124</version>
	  <extension_update_uri>http://widget.com/extension.ext</extension_update_uri>
	  <title>ST extension</title>
	  <author>Anonymous Opera Developer</author>
	</extension>
	*/
	{
		"extension has expected version",
		SYNC_HAVE_EXTENSIONS,
		OpSyncDataItem::DATAITEM_EXTENSION, UNI_L("9f3ac0ca7d974574b039cc05af781e8a"),
		OpSyncItem::SYNC_KEY_VERSION, UNI_L("124")
	},
	{
		"extension has expected update uri",
		SYNC_HAVE_EXTENSIONS,
		OpSyncDataItem::DATAITEM_EXTENSION, UNI_L("9f3ac0ca7d974574b039cc05af781e8a"),
		OpSyncItem::SYNC_KEY_EXTENSION_UPDATE_URI, UNI_L("http://widget.com/extension.ext")
	},
	{
		"extension has expected title",
		SYNC_HAVE_EXTENSIONS,
		OpSyncDataItem::DATAITEM_EXTENSION, UNI_L("9f3ac0ca7d974574b039cc05af781e8a"),
		OpSyncItem::SYNC_KEY_TITLE, UNI_L("ST extension")
	},
	{
		"extension has expected author",
		SYNC_HAVE_EXTENSIONS,
		OpSyncDataItem::DATAITEM_EXTENSION, UNI_L("9f3ac0ca7d974574b039cc05af781e8a"),
		OpSyncItem::SYNC_KEY_AUTHOR, UNI_L("Anonymous Opera Developer")
	},
}

global
{
#define GUID1 "OPERASOFTWARE2bd95FE421D3BFC11C9"
#define GUID2 "PREVIOUS2bd95FE421D3BFC11C9"

	class ST_SyncListener : public OpSyncDataClient
	{
	public:
		ST_SyncListener(OpSyncCoordinator* sync_coordinator)
			: listener_failed(FALSE)
			, m_sync_enabled(FALSE)
			, m_sync_coordinator(sync_coordinator)
			, m_next_data_error(SYNC_DATAERROR_NONE) {}

		virtual ~ST_SyncListener() {
			ClearIncomingItems();
		}

		void ClearIncomingItems() {
			while (incoming_items.First()) {
				OpSyncItem* first = incoming_items.First();
				incoming_items.Remove(first);
				first->SetDataSyncItem(0);
				OP_DELETE(first);
			}
		}

		/**
		 * @name Implementation of OpSyncDataClient
		 * @{
		 */

		virtual OP_STATUS SyncDataInitialize(OpSyncDataItem::DataItemType type) {
			return OpStatus::OK;
		}

		virtual OP_STATUS SyncDataAvailable(OpSyncCollection* new_items, OpSyncDataError& data_error) {
			for (OpSyncItemIterator sync_item(new_items->First()); *sync_item; ++sync_item)
			{
				OpSyncItem::Key key = sync_item->GetPrimaryKey();
				OpString key_data;
				sync_item->GetData(key, key_data);
				OpSyncItem* copy = 0;
				m_sync_coordinator->GetSyncItem(&copy, sync_item->GetType(), key, key_data);
				if (copy)
				{
					copy->SetDataSyncItem(sync_item->GetDataSyncItem()->Copy());
					incoming_items.AddItem(copy);
				}
			}
			if (m_next_data_error != SYNC_DATAERROR_NONE)
				data_error = m_next_data_error;
			return OpStatus::OK;
		}

		virtual OP_STATUS SyncDataFlush(OpSyncDataItem::DataItemType type, BOOL first_sync, BOOL is_dirty) {
			return OpStatus::OK;
		}

		virtual OP_STATUS SyncDataSupportsChanged(OpSyncDataItem::DataItemType type, BOOL has_support) {
			m_sync_enabled = has_support;
			return OpStatus::OK;
		}

		/** @} */ // Implementation of OpSyncDataClient

		BOOL SyncingEnabled() { return m_sync_enabled; }

		void SetNextSyncDataError(OpSyncDataError data_error) {
			m_next_data_error = data_error;
		}

		BOOL listener_failed;
		OpSyncCollection incoming_items;
		BOOL m_sync_enabled;

	private:
		OpSyncCoordinator*	m_sync_coordinator;
		OpSyncDataError m_next_data_error;
	};

	/**
	 * This class can be used to verify that the OpSyncUIListener is called
	 * correctly. To use this class create a local instance and call
	 * OpSyncCoordinator::SetSyncUIListener():
	 * @code
	 * ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	 * OpSyncCoordinator coordinator;
	 * ST_SyncUIListener ui_listener;
	 * verify(factory);
	 * verify_success(coordinator.Init(factory, FALSE));
	 * verify_success(coordinator.SetSyncUIListener(&ui_listener));
	 * @endcode
	 */
	class ST_SyncUIListener : public OpSyncUIListener
	{
		OpSyncError m_last_error;
		OpString m_error_message;
	public:
		ST_SyncUIListener() : m_last_error(SYNC_OK) {}
		virtual ~ST_SyncUIListener() {}

		/**
		 * @name Implementation of OpSyncUIListener
		 * @{
		 */
		virtual void OnSyncStarted(BOOL items_sending) {}
		virtual void OnSyncError(OpSyncError error, const OpStringC& error_message) {
			m_last_error = error;
			m_error_message.Set(error_message);
		}
		virtual void OnSyncFinished(OpSyncState& sync_state) {}
#ifdef SYNC_ENCRYPTION_KEY_SUPPORT
		virtual void OnSyncReencryptEncryptionKeyFailed(OpSyncUIListener::ReencryptEncryptionKeyContext* context) {}
		virtual void OnSyncReencryptEncryptionKeyCancel(ReencryptEncryptionKeyContext* context) {}
#endif // SYNC_ENCRYPTION_KEY_SUPPORT
		/** @} */ // Implementation of OpSyncUIListener

		OpSyncError GetLastError(OpString& error_message) {
			OpSyncError err = m_last_error;
			m_last_error = SYNC_OK;
			error_message.TakeOver(m_error_message);
			return err;
		}
	};

	ST_SyncListener* sync_listener;
	OpSyncCoordinator* sync_coordinator;
}

setup
{
	sync_listener = 0;
	sync_coordinator = 0;
}

/**
 * Find the specified action in the vector of expected merge-actions. If the
 * action is found in the vector, it is removed from the vector.
 * @param expected_merge_actions is the vector of expected merge-actions. The
 *  specified action is removed from this vector if it was found.
 * @param action_in_xml,len is the sub-string and length of part of the
 *  generated xml which describes the merge-datatype.
 * @return verified ok if the specified action_in_xml,len was found in the
 *  expected_merge_actions and a failure if it was not found.
 */
subtest FindMergeAction(OpVector<char>& expected_merge_actions, const OpStringC8& action_in_xml, int len)
{
	bool found = false;
	for (unsigned i=0; i<expected_merge_actions.GetCount(); i++)
	{
		if (action_in_xml.CompareI(expected_merge_actions.Get(i), len) == 0)
		{
			found = true;
			expected_merge_actions.Remove(i);
		}
	}
	if (found)
		verify(found);
	else
	{	// Try to make a readable failure message:
		OpString8 expected_action;
		OpString8 action_found_in_xml;
		verify_success(action_found_in_xml.Set(action_in_xml, len));
		verify_string(expected_action, action_found_in_xml);
	}
}

/**
 * Parses the specified xml-string for a section of <action>...
 * <merge datatype="xxx"...</action>. Each found datatype "xxx" is expected to
 * be found in the vector expected_merge_actions. If a found datatype is not in
 * that vector or if the vector has more items that are not found, this subtest
 * fails.
 * @note Found datatype strings are removed from the specified vector.
 */
subtest CheckExpectedMergeActions(const OpStringC8& xml, OpVector<char>& expected_merge_actions)
{
	if (expected_merge_actions.GetCount() == 0)
	{
		verify(xml.FindI("<actions>") < 0);
		verify(xml.FindI("<merge datatype=\"") < 0);
		verify(xml.FindI("</actions>") < 0);
	}
	else
	{
		int start_action = xml.FindI("<actions>");
		verify(0 < start_action);
		int end_action = xml.FindI("</actions>", start_action);
		verify(start_action < end_action);
		int start_merge = xml.FindI("<merge datatype=\"", start_action);
		while (start_merge > 0)
		{
			verify(start_merge+17 < end_action);
			int end_datatype = xml.FindI("\"", start_merge+17);
			verify(end_datatype < end_action);
			verify(FindMergeAction(expected_merge_actions, xml.SubString(start_merge + 17), end_datatype-(start_merge+17)));
			start_merge = xml.FindI("<merge datatype=\"", end_datatype);
		}
		verify(expected_merge_actions.GetCount() == 0);
	}
}

/** Verify that on the first sync (sync-state is 0) we add a merge-action to the
 * xml data that is sent to the Link server.
 */
test("merge-action")
{
	ST_SyncFactory factory;
	OpSyncParser* parser = 0;
	OpSyncDataQueue* data_queue = 0;
	verify_success(factory.GetParser(&parser, NULL));
	verify_success(factory.GetQueueHandler(&data_queue, NULL, FALSE));
	parser->SetDataQueue(data_queue);

	OpVector<char> expected_merge_actions;
	OpSyncState sync_state;
	SyncSupportsState supports_state;
	/* Enable support for all supports-types: */
	supports_state.SetSupports(SYNC_SUPPORTS_BOOKMARK, true);
	expected_merge_actions.Add(const_cast<char*>("bookmark"));
	supports_state.SetSupports(SYNC_SUPPORTS_CONTACT, true);
	expected_merge_actions.Add(const_cast<char*>("contact"));
	supports_state.SetSupports(SYNC_SUPPORTS_ENCRYPTION, true);
	// no merge-action for the encryption-key
	supports_state.SetSupports(SYNC_SUPPORTS_FEED, true);
	// no merge-action for feeds
	supports_state.SetSupports(SYNC_SUPPORTS_NOTE, true);
	expected_merge_actions.Add(const_cast<char*>("note"));
	supports_state.SetSupports(SYNC_SUPPORTS_PASSWORD_MANAGER, true);
	// no merge-action for passwords
	supports_state.SetSupports(SYNC_SUPPORTS_SEARCHES, true);
	expected_merge_actions.Add(const_cast<char*>("search_engine"));
	supports_state.SetSupports(SYNC_SUPPORTS_SPEEDDIAL, true);
	expected_merge_actions.Add(const_cast<char*>("speeddial"));
	supports_state.SetSupports(SYNC_SUPPORTS_SPEEDDIAL_2, true);
	expected_merge_actions.Add(const_cast<char*>("speeddial2"));
	supports_state.SetSupports(SYNC_SUPPORTS_TYPED_HISTORY, true);
	// no merge-action for typed history
	supports_state.SetSupports(SYNC_SUPPORTS_URLFILTER, true);
	expected_merge_actions.Add(const_cast<char*>("urlfilter"));
	verify_success(parser->Init(0, sync_state, supports_state));

	OpString8 generated_xml;
	verify_success(static_cast<MyOperaSyncParser*>(parser)->GenerateXML(generated_xml, *data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_OUTGOING)));
	verify(CheckExpectedMergeActions(generated_xml, expected_merge_actions));
}
finally
{
	OP_DELETE(parser);
	if (data_queue)
		data_queue->Shutdown();
	OP_DELETE(data_queue);
}

/** Verify that on the first sync (sync-state is 0) we don't add a merge-action
 * to the xml data that is sent to the Link server if the support type is not
 * enabled.
 */
test("merge-action no support")
{
	ST_SyncFactory factory;
	OpSyncParser* parser = 0;
	OpSyncDataQueue* data_queue = 0;
	verify_success(factory.GetParser(&parser, NULL));
	verify_success(factory.GetQueueHandler(&data_queue, NULL, FALSE));
	parser->SetDataQueue(data_queue);

	OpVector<char> expected_merge_actions;
	OpSyncState sync_state;
	SyncSupportsState supports_state;
	verify_success(parser->Init(0, sync_state, supports_state));

	OpString8 generated_xml;
	verify_success(static_cast<MyOperaSyncParser*>(parser)->GenerateXML(generated_xml, *data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_OUTGOING)));
	verify(CheckExpectedMergeActions(generated_xml, expected_merge_actions));
}
finally
{
	OP_DELETE(parser);
	if (data_queue)
		data_queue->Shutdown();
	OP_DELETE(data_queue);
}

/** Verify that if a single support-type was enabled (i.e. the sync-state is not
 * the initial state but the support-type's state is) we add a merge-action to
 * the xml data that is sent to the Link server.
 */
test("merge-action support enabled")
{
	ST_SyncFactory factory;
	OpSyncParser* parser = 0;
	OpSyncDataQueue* data_queue = 0;
	verify_success(factory.GetParser(&parser, NULL));
	verify_success(factory.GetQueueHandler(&data_queue, NULL, FALSE));
	parser->SetDataQueue(data_queue);

	OpVector<char> expected_merge_actions;
	OpSyncState sync_state;
	SyncSupportsState supports_state;
	sync_state.SetSyncState(UNI_L("3"));
	sync_state.SetSyncState(UNI_L("0"), SYNC_SUPPORTS_BOOKMARK);
	supports_state.SetSupports(SYNC_SUPPORTS_BOOKMARK, true);
	expected_merge_actions.Add(const_cast<char*>("bookmark"));
	sync_state.SetSyncState(UNI_L("3"), SYNC_SUPPORTS_CONTACT);
	supports_state.SetSupports(SYNC_SUPPORTS_CONTACT, true);
	/* expect no merge-action for contact, because they don't have the default
	 * sync-state "0". */
	verify_success(parser->Init(0, sync_state, supports_state));

	OpString8 generated_xml;
	verify_success(static_cast<MyOperaSyncParser*>(parser)->GenerateXML(generated_xml, *data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_OUTGOING)));
	verify(CheckExpectedMergeActions(generated_xml, expected_merge_actions));
}
finally
{
	OP_DELETE(parser);
	if (data_queue)
		data_queue->Shutdown();
	OP_DELETE(data_queue);
}

/** Verify that a merge action is delayed if there are still outgoing
 * sync-items.
 */
test("merge-action delayed")
{
	ST_SyncNullInternalSyncListener null_listener;
	ST_SyncFactory factory;
	OpSyncParser* parser = 0;
	OpSyncDataQueue* data_queue = 0;
	verify_success(factory.GetParser(&parser, &null_listener));
	verify_success(factory.GetQueueHandler(&data_queue, &null_listener, FALSE));
	parser->SetDataQueue(data_queue);

	OpVector<char> expected_merge_actions;
	OpSyncState sync_state;
	SyncSupportsState supports_state;
	supports_state.SetSupports(SYNC_SUPPORTS_BOOKMARK, true);
	verify_success(parser->Init(0, sync_state, supports_state));

	OpSyncDataItem* item = OP_NEW(OpSyncDataItem, (OpSyncDataItem::DATAITEM_BOOKMARK));
	verify(item);
	data_queue->Add(item);

	OpString8 generated_xml;
	verify_success(static_cast<MyOperaSyncParser*>(parser)->GenerateXML(generated_xml, *data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_OUTGOING)));
	verify(CheckExpectedMergeActions(generated_xml, expected_merge_actions));
}
finally
{
	OP_DELETE(parser);
	if (data_queue)
		data_queue->Shutdown();
	OP_DELETE(data_queue);
}

/** Verify that after the first sync (sync-state > 0) we don't add a
 * merge-action to the xml data that is sent to the Link server.
 */
test("merge-action sync-state not 0")
{
	ST_SyncFactory factory;
	OpSyncParser* parser = 0;
	OpSyncDataQueue* data_queue = 0;
	verify_success(factory.GetParser(&parser, NULL));
	verify_success(factory.GetQueueHandler(&data_queue, NULL, FALSE));
	parser->SetDataQueue(data_queue);

	OpVector<char> expected_merge_actions;
	OpSyncState sync_state;
	sync_state.SetSyncState(UNI_L("1"));
	sync_state.SetSyncState(UNI_L("1"), SYNC_SUPPORTS_BOOKMARK);
	SyncSupportsState supports_state;
	supports_state.SetSupports(SYNC_SUPPORTS_BOOKMARK, true);
	verify_success(parser->Init(0, sync_state, supports_state));

	OpString8 generated_xml;
	verify_success(static_cast<MyOperaSyncParser*>(parser)->GenerateXML(generated_xml, *data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_OUTGOING)));
	verify(CheckExpectedMergeActions(generated_xml, expected_merge_actions));
}
finally
{
	OP_DELETE(parser);
	if (data_queue)
		data_queue->Shutdown();
	OP_DELETE(data_queue);
}

/** Verify fix for DSK-346569. When a sync-support was enabled and the
 * sync-state was empty, the xml-generation crashed on generating a
 * backlog_since attribute. It is expected to generate a backlog_since="0".
 */
test("backlog_since 0")
{
	ST_SyncFactory factory;
	OpSyncParser* parser = 0;
	OpSyncDataQueue* data_queue = 0;
	verify_success(factory.GetParser(&parser, NULL));
	verify_success(factory.GetQueueHandler(&data_queue, NULL, FALSE));
	parser->SetDataQueue(data_queue);

	OpSyncState sync_state;
	sync_state.SetSyncState(UNI_L("1"));
	sync_state.SetSyncState(NULL, SYNC_SUPPORTS_BOOKMARK);
	SyncSupportsState supports_state;
	supports_state.SetSupports(SYNC_SUPPORTS_BOOKMARK, true);
	verify_success(parser->Init(0, sync_state, supports_state));

	OpString8 generated_xml;
	verify_success(static_cast<MyOperaSyncParser*>(parser)->GenerateXML(generated_xml, *data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_OUTGOING)));
	verify(generated_xml.FindI("backlog_since=\"0\"") > 0);
}
finally
{
	OP_DELETE(parser);
	if (data_queue)
		data_queue->Shutdown();
	OP_DELETE(data_queue);
}

test("create object")
{
	sync_coordinator = OP_NEW(OpSyncCoordinator, ());
	verify(sync_coordinator != NULL);

	sync_listener = OP_NEW(ST_SyncListener, (sync_coordinator));
	verify(sync_listener != NULL);

	ST_SyncFactory* sync_factory = OP_NEW(ST_SyncFactory, ());
	verify(sync_factory != NULL);

	// sync_coordinator takes ownership of the sync_factory now
	OP_STATUS s = sync_coordinator->Init(sync_factory, FALSE);
	verify_success(s);

	sync_coordinator->SetSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_BOOKMARK);
	// this one should be ignored:
	sync_coordinator->SetSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER);
	// add support for password manager items
	sync_coordinator->SetSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_PM_FORM_AUTH);
	sync_coordinator->SetSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH);
	// look out for the encryption_key as well:
	sync_coordinator->SetSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_ENCRYPTION_KEY);
	sync_coordinator->SetSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_EXTENSION);
}

test("Abort adding of items - simulate client OOM")
require success "create object";
{
	OpSyncItem* item = 0;
	// Create bookmark - but abort half way
	verify_success(sync_coordinator->GetSyncItem(&item, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("BOOKMARK-ABORTED")));
	verify(item);
	{	// delete the sync_item at the end of this scope
		OpAutoPtr<OpSyncItem> sync_item(item);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
		verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_PARENT, UNI_L("FOLDER1")));
		// pretend we failed here and don't commit it

		/* Workaround to fix memory-leak: This should not be necessary, but
		 * currently we need to delete the OpSyncDataItem that is associated to
		 * the OpSyncItem, because we don't call CommitItem():
		 * TODO: The OpSyncItem destructor shall delete its OpSyncDataItem if
		 * the OpSyncDataItem is not owned by anybody else. */
		sync_item->SetDataSyncItem(0);
	}

	// try to get it again
	OP_STATUS s = sync_coordinator->GetExistingSyncItem(&item, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("BOOKMARK-ABORTED"));
	// this should fail
	verify(!OpStatus::IsSuccess(s));
}
finally
{
	OpSyncCoordinator::SelftestHelper(sync_coordinator).ClearDataQueue();
}

test("OpDataQueue::AddItemOrdered")
require success "create object";
{
	BOOL start_new_item = TRUE;
	OpSyncItem* sync_item = 0;

	iterate (table_type, table_id, table_key, table_data) from Table_ordered_1
	{
		if (table_type == OpSyncDataItem::DATAITEM_GENERIC)
		{
			verify_success(sync_item->CommitItem(FALSE, TRUE));
			OP_DELETE(sync_item);
			sync_item = 0;
			start_new_item = TRUE;
		}
		else if (start_new_item)
		{
			verify_success(sync_coordinator->GetSyncItem(&sync_item, table_type, OpSyncItem::SYNC_KEY_ID, table_id));
			sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
			start_new_item = FALSE;
		}
		else
		{
			verify_success(sync_item->SetData(table_key, table_data));
		}
	}

	// Now update the items a bit so they are rearranged.
	// Change parent to the folder and previous to empty
	verify_success(sync_coordinator->UpdateItem(OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK1"), OpSyncItem::SYNC_KEY_PARENT, UNI_L("FOLDER1")));
	verify_success(sync_coordinator->UpdateItem(OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK1"), OpSyncItem::SYNC_KEY_PREV, UNI_L("BOOKMARK2")));

	// verify the data:
	OpString data;

	verify_success(sync_coordinator->GetExistingSyncItem(&sync_item, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("BOOKMARK1")));
	verify(sync_item != NULL);

	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_PARENT, data));
	verify_string(data, "FOLDER1");

	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_PREV, data));
	verify_string(data, "BOOKMARK2");

	OP_DELETE(sync_item);
	sync_item = 0;

	OpSyncCoordinator::SelftestHelper sync_helper(sync_coordinator);
	OpSyncDataQueue* data_queue = sync_helper.GetSyncDataQueue();
	verify(data_queue != NULL);

	// verify that the items were really reordered to reflect the change in parent and previous
	OpSyncDataCollection* collection = data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_ACTIVE);
	verify(collection != NULL);

	OpSyncDataItemIterator current(collection->First());
	verify(*current);
	verify_string(current->FindData(UNI_L("id")), "FOLDER1");
	verify(current->GetType() == OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER);

	verify(++current);
	verify_string(current->FindData(UNI_L("id")), "BOOKMARK2");
	verify(current->GetType() == OpSyncDataItem::DATAITEM_BOOKMARK);
}
finally
{
	if (sync_item)
		OP_DELETE(sync_item);
	OpSyncCoordinator::SelftestHelper(sync_coordinator).ClearDataQueue();
}

test("Bug 358327 - Queue written before using link")
{
	/* An OpSyncDataClient that has its pref enabled will not receive a call to
	 * SyncDataSupportsChanged(has_support=TRUE) when SyncEnabled and SyncUsed
	 * are both false. But on enabling SyncEnabled, it will be called: */
	int sync_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncUsed);
	int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	int sync_bookmarks = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncBookmarks);
	TRAPD(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, 0));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 0));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, 1));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	ST_SyncListener listener(&coordinator);
	verify_success(coordinator.Init(factory, FALSE));

	coordinator.SetSyncDataClient(&listener, OpSyncDataItem::DATAITEM_BOOKMARK);
	verify(!listener.SyncingEnabled());

	/* Calling SetSupports() does not change this - SetSupports() only sets the
	 * SyncBookmarks pref to true, but that does not change anything about Sync
	 * not being enabled or used before... */
	coordinator.SetSupports(SYNC_SUPPORTS_BOOKMARK);
	verify(!listener.SyncingEnabled());

	/* Now verify that enabling sync will notify the data-client: */
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));
	verify(listener.SyncingEnabled());
	/* TODO: currently core and desktop disagree on when SyncUsed is set. core's
	 * or gogi's sync-manager sets SyncUsed to 1 when Opera receives an answer
	 * from the Link Server. Desktop sets SyncUsed to 1 when it enables
	 * SyncEnabled for the first time. */
}
finally
{
	coordinator.RemoveSyncDataClient(&listener, OpSyncDataItem::DATAITEM_BOOKMARK);
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, sync_used));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, sync_bookmarks));
}

test("Keep data-client enabled after used once")
{
	/* If sync was used once (SyncUsed is true), but is disabled now
	 * (SyncEnabled is false), an OpSyncDataClient that has its pref enabled
	 * will receive a call to SyncDataSupportsChanged(has_support=TRUE) when the
	 * client is added within SYNC_CHECK_LAST_USED_DAYS days. Thus the client
	 * can continue to write updates to the queue file. But after that period
	 * the queue file should not be updated any more as otherwise the data to
	 * send to the Link server may be too big.
	 * Note: DSK-309316 is about to change this behaviour... */
	int sync_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncUsed);
	int sync_last_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncLastUsed);
	int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	int sync_bookmarks = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncBookmarks);

	unsigned long seconds_now, milliseconds_now;
	g_op_time_info->GetWallClock(seconds_now, milliseconds_now);

	TRAPD(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, 1));
	/* set SyncLastUsed to yesterday: */
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncLastUsed, seconds_now-60*60*24));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 0));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, 1));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	ST_SyncListener listener(&coordinator);
	verify_success(coordinator.Init(factory, FALSE));

	coordinator.SetSyncDataClient(&listener, OpSyncDataItem::DATAITEM_BOOKMARK);
	/* The client is expected to be enabled, though SyncEnabled is false: */
	verify(listener.SyncingEnabled());

	/* Now verify that disabling sync will notify the data-client: */
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, 0));
	verify(!listener.SyncingEnabled());
}
finally
{
	coordinator.RemoveSyncDataClient(&listener, OpSyncDataItem::DATAITEM_BOOKMARK);
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, sync_used));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncLastUsed, sync_last_used));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, sync_bookmarks));
}

test("Keep data-client enabled no longer than SYNC_CHECK_LAST_USED_DAYS")
{
	/* If sync was used once (SyncUsed is true), but is disabled now
	 * (SyncEnabled is false), an OpSyncDataClient that has its pref enabled
	 * will receive a call to SyncDataSupportsChanged(has_support=TRUE) when the
	 * client is added within SYNC_CHECK_LAST_USED_DAYS days. Thus the client
	 * can continue to write updates to the queue file. But after that period
	 * the queue file should not be updated any more as otherwise the data to
	 * send to the Link server may be too big.
	 * Note: DSK-309316 is about to change this behaviour... */
	int sync_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncUsed);
	int sync_last_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncLastUsed);
	int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	int sync_bookmarks = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncBookmarks);

	unsigned long seconds_now, milliseconds_now;
	g_op_time_info->GetWallClock(seconds_now, milliseconds_now);

	TRAPD(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, 1));
	/* set SyncLastUsed to yesterday: */
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncLastUsed, seconds_now-SYNC_CHECK_LAST_USED_DAYS*60*60*24-1));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 0));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, 1));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	ST_SyncListener listener(&coordinator);
	verify_success(coordinator.Init(factory, FALSE));

	coordinator.SetSyncDataClient(&listener, OpSyncDataItem::DATAITEM_BOOKMARK);
	/* The client is expected to be enabled, though SyncEnabled is false: */
	verify(!listener.SyncingEnabled());

	/* Now verify that enabling sync will notify the data-client: */
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));
	verify(listener.SyncingEnabled());
}
finally
{
	coordinator.RemoveSyncDataClient(&listener, OpSyncDataItem::DATAITEM_BOOKMARK);
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, sync_used));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncLastUsed, sync_last_used));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, sync_bookmarks));
}

test("BroadcastSyncSupportChanged")
{
	/* This test verifies that OpSyncDataClient::SyncDataSupportsChanged() is
	 * called when the support for one data type is enabled. */
	OP_STATUS s;
	int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	int sync_bookmarks = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncBookmarks);
	if (!sync_enabled)
		TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));
	if (sync_bookmarks)
		TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, 0));
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	ST_SyncListener listener(&coordinator);
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	coordinator.SetSyncDataClient(&listener, OpSyncDataItem::DATAITEM_BOOKMARK);

	// The client is expected to be disabled:
	verify(!listener.SyncingEnabled());
	verify(!coordinator.GetSupports(SYNC_SUPPORTS_BOOKMARK));

	// On enabling the supports type ...
	coordinator.SetSupports(SYNC_SUPPORTS_BOOKMARK);
	// ... the listener shall be notified:
	verify(listener.SyncingEnabled());
	verify(coordinator.GetSupports(SYNC_SUPPORTS_BOOKMARK));
}
finally
{
	coordinator.RemoveSyncDataClient(&listener, OpSyncDataItem::DATAITEM_BOOKMARK);
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, sync_bookmarks));
}

test("BroadcastSyncSupportChanged while sync in progress")
require success "BroadcastSyncSupportChanged";
{
	/* This test verifies that OpSyncDataClient::SyncDataSupportsChanged() is
	 * not called when the support for one data type is enabled while a sync
	 * connection is in progress (OpSyncCoordinator::IsSyncInProgress()).
	 * Instead the change is recorded as pending and hen the sync-connection is
	 * completed (OpSyncCoordinator::OnSyncCompleted()), the pending
	 * notifications are broadcast. */
	OP_STATUS s;
	int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	int sync_bookmarks = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncBookmarks);
	if (!sync_enabled)
		TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));
	if (sync_bookmarks)
		TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, 0));
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);
	ST_SyncListener listener(&coordinator);
#ifdef SYNC_ENCRYPTION_KEY_SUPPORT
	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper encryption_key_helper(&encryption_key_manager);
	TRAP(s, encryption_key_manager.InitL(&coordinator));
#endif // SYNC_ENCRYPTION_KEY_SUPPORT
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	verify(!coordinator.UseDiskQueue());
	coordinator.SetSyncDataClient(&listener, OpSyncDataItem::DATAITEM_BOOKMARK);

	// The client is expected to be disabled:
	verify(!coordinator.IsSyncInProgress());
	verify(!listener.SyncingEnabled());
	verify(!coordinator.GetSupports(SYNC_SUPPORTS_BOOKMARK));
	sync_helper.SetSyncInProgress(TRUE);
	verify(coordinator.IsSyncInProgress());

	// On enabling the supports type ...
	coordinator.SetSupports(SYNC_SUPPORTS_BOOKMARK);
	// ... the listener shall not be notified ...
	verify(coordinator.IsSyncInProgress());
	verify(!listener.SyncingEnabled());
	verify(coordinator.GetSupports(SYNC_SUPPORTS_BOOKMARK));

	// ... before we complete syncing:
	OpSyncCollection new_items;
	OpSyncState sync_state;
	OpSyncServerInformation server_info;
	coordinator.OnSyncCompleted(&new_items, sync_state, server_info);
	verify(coordinator.UseDiskQueue());
	verify(!coordinator.IsSyncInProgress());
	verify(listener.SyncingEnabled());
	verify(coordinator.GetSupports(SYNC_SUPPORTS_BOOKMARK));
}
finally
{
	coordinator.SetUseDiskQueue(FALSE);
	coordinator.RemoveSyncDataClient(&listener, OpSyncDataItem::DATAITEM_BOOKMARK);
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, sync_bookmarks));
}

test("password-manager depends on encryption-key")
require SYNC_HAVE_PASSWORD_MANAGER;
{
	/* The password-manager support depends on encryption-key support. So
	 * enabling the password-manager should also enable encryption-key
	 * support. */
	int sync_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncUsed);
	int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	int sync_pm = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);

	TRAPD(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, 1));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));

	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	ST_SyncListener listener(&coordinator);
	verify_success(coordinator.Init(factory, FALSE));

	coordinator.SetSyncDataClient(&listener, OpSyncDataItem::DATAITEM_ENCRYPTION_KEY);
	/* The client is expected to be enabled because sync password manager is
	 * enabled: */
	verify(listener.SyncingEnabled());

	/* Now verify that disabling password manager disables encryption-key.
	 * Note: currently password-manager is the only support type that uses
	 * encryption-key. But it is possible that other types will start using the
	 * encryption-key as well. In that case disabling the password manager pref
	 * will not change encryption-key support of the other type is still
	 * enabled. */
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 0));
	verify(!listener.SyncingEnabled());
}
finally
{
	coordinator.RemoveSyncDataClient(&listener, OpSyncDataItem::DATAITEM_ENCRYPTION_KEY);
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, sync_used));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_pm));
}

test("Bug 363972 - Verify that the ordering is correctly handled")
{
	OpSyncItem* sync_item_ptr = 0;
	OpSyncCoordinator coordinator;
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));

	// Create folder
	verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER, OpSyncItem::SYNC_KEY_ID, UNI_L("FOLDER1")));
	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
		verify_success(sync_item->CommitItem(FALSE));
	}
	sync_item_ptr = 0;

	// Create bookmark with folder as parent
	verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("BOOKMARK1")));
	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
		verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_PARENT, UNI_L("FOLDER1")));
		verify_success(sync_item->CommitItem(FALSE));
	}
	sync_item_ptr = 0;

	// Create bookmark with first bookmark as previous and folder as parent
	verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("BOOKMARK2")));
	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
		verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_PARENT, UNI_L("FOLDER1")));
		verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_PREV, UNI_L("BOOKMARK1")));
		verify_success(sync_item->CommitItem(FALSE));
	}
	sync_item_ptr = 0;

	// verify the order
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);
	OpSyncDataQueue* data_queue = sync_helper.GetSyncDataQueue();
	verify(data_queue != NULL);

	// verify that the items were really reordered to reflect the change in parent and previous
	OpSyncDataCollection* collection = data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_ACTIVE);
	verify(collection != NULL);

	OpSyncDataItemIterator current(collection->First());

	// first should be the folder
	verify(*current);
	verify_string(current->FindData(UNI_L("id")), "FOLDER1");
	verify(current->GetType() == OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER);
	verify(current->GetBaseType() == OpSyncDataItem::DATAITEM_BOOKMARK);

	// 2nd should be the first bookmark
	verify(++current);
	verify_string(current->FindData(UNI_L("id")), "BOOKMARK1");
	verify(current->GetType() == OpSyncDataItem::DATAITEM_BOOKMARK);
	verify(current->GetBaseType() == OpSyncDataItem::DATAITEM_BOOKMARK);

	// 3rd should be the 2nd bookmark
	verify(++current);
	verify_string(current->FindData(UNI_L("id")), "BOOKMARK2");
	verify(current->GetType() == OpSyncDataItem::DATAITEM_BOOKMARK);
	verify(current->GetBaseType() == OpSyncDataItem::DATAITEM_BOOKMARK);
}

test("Bug 363963 - Delete two consecutive items")
{
	OpSyncCoordinator coordinator;
	ST_SyncListener listener(&coordinator);
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));

	// Create bookmark 0 -> Add it
	OpSyncItem* sync_item_ptr = 0;
	verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("Bookmark0-id")));
	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
		verify_success(sync_item->CommitItem(FALSE));
	}
	sync_item_ptr = 0;

	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);
	OpSyncDataQueue* my_queue = sync_helper.GetSyncDataQueue();
	verify(my_queue);
	OpSyncDataCollection* collection = my_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_ACTIVE);
	verify(collection);
	//output("collection count = %d\n", collection->GetCount());

	// Delete bookmark A -> Commit it and UpdateItem on B with new previous B
	verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("BookmarkA-id")));
	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_DELETED);
		verify_success(sync_item->CommitItem(FALSE));
	}
	sync_item_ptr = 0;

	collection = my_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_ACTIVE);
	verify(collection);
	//output("collection count = %d\n", collection->GetCount());

	// The update
	verify_success(coordinator.UpdateItem(OpSyncDataItem::DATAITEM_BOOKMARK,
										  UNI_L("BookmarkB-id"),
										  OpSyncItem::SYNC_KEY_PREV,
										  UNI_L("Bookmark0-id")));

	collection = my_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_ACTIVE);
	verify(collection);
	//output("collection count = %d\n", collection->GetCount());

	// Delete bookmark B -> Commit it (and Update its next item)
	verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("BookmarkB-id")));
	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_DELETED);
		verify_success(sync_item->CommitItem(FALSE));
	}
	sync_item_ptr = 0;

	// Check that there is only three items in the out_queue.
	collection = my_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_ACTIVE);
	verify(collection);
//	output("collection count = %d\n", collection->GetCount());
	// NOTE: commented this away, since it fails, and I want the rest of the test to run
	//verify(collection->GetCount() == 3);

	verify(collection->HasItems());

	int bookmark_a_count = 0;
	int bookmark_b_count = 0;
	int bookmark_0_count = 0;
	for (OpSyncDataItemIterator current(collection->First()); *current; ++current)
	{
		verify(current->GetType() == OpSyncDataItem::DATAITEM_BOOKMARK);

		OpString primary_key;
		verify_success(primary_key.Set(current->FindData(UNI_L("id"))));
		verify(primary_key.HasContent());

		//output("primary_key = %s\n", uni_down_strdup(primary_key.CStr()));

		if (primary_key == UNI_L("BookmarkA-id"))
		{
			verify(current->GetStatus() == OpSyncDataItem::DATAITEM_ACTION_DELETED);
			verify(bookmark_a_count == 0);
			bookmark_a_count++;
//			output("previous of item a is %s\n", uni_down_strdup(current->FindData(UNI_L("previous"))));

		}
		else if (primary_key == UNI_L("BookmarkB-id"))
		{
			verify(current->GetStatus() == OpSyncDataItem::DATAITEM_ACTION_DELETED);
			verify(bookmark_b_count == 0);
			bookmark_b_count++;
//			output("previous of item b is %s\n", uni_down_strdup(current->FindData(UNI_L("previous"))));

		}
		else if (primary_key == UNI_L("Bookmark0-id"))
		{
			verify(current->GetStatus() == OpSyncDataItem::DATAITEM_ACTION_ADDED);
			verify(bookmark_0_count == 0);
			bookmark_0_count++;
			verify(current->FindData(UNI_L("previous")) == 0);

		}
		else
		{
			verify(FALSE);
		}
	}
}

test("create items")
require success "create object";
{
	OpSyncItem* sync_item_ptr = 0;
	verify_success(sync_coordinator->GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L(GUID1)));
	verify(sync_item_ptr);
	OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);

	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_TITLE, UNI_L("Opera Software ASA")));
	verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_URI, UNI_L("http://www.opera.com/")));
	verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_PREV, UNI_L("")));
	verify_success(sync_item->CommitItem(FALSE));
}

test("verify GetData()")
require success "create items";
{
	OpSyncItem* sync_item_ptr = 0;
	OpString data;

	verify_success(sync_coordinator->GetExistingSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L(GUID1)));
	verify(sync_item_ptr);
	OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);

	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_TITLE, data));
	verify_string(data, "Opera Software ASA");

	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_URI, data));
	verify_string(data, "http://www.opera.com/");
}

test("verify that creating same item with different values updates item")
require success "create items";
{
	OpSyncItem* sync_item_ptr = 0;
	OpString data;

	verify_success(sync_coordinator->GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L(GUID1)));
	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);

		// change title to something else
		verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_TITLE, UNI_L("Opera Software")));
		verify_success(sync_item->CommitItem(FALSE));
	}
	sync_item_ptr = 0;

 	verify_success(sync_coordinator->GetExistingSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L(GUID1)));
 	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_TITLE, data));
		verify_string(data, "Opera Software");
	}
}

test("verify UpdateItem()")
require success "create items";
{
	/* type, primary key data of item to update, key to update, key data */
	verify_success(sync_coordinator->UpdateItem(OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L(GUID1), OpSyncItem::SYNC_KEY_PREV, UNI_L(GUID2)));

	OpSyncItem* sync_item_ptr = 0;
 	verify_success(sync_coordinator->GetExistingSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L(GUID1)));
 	verify(sync_item_ptr);
	OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
	OpString data;
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_PREV, data));
	verify_string(data, GUID2);
}

test("Bug #315475 - Pasting items gives wrong previous")
{
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	verify_success(coordinator.Init(factory, FALSE));

	OpSyncItem* sync_item_ptr = 0;

	// Create bookmark
	verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("BOOKMARK1")));
	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
		verify_success(sync_item->CommitItem(FALSE, TRUE));
	}
	sync_item_ptr = 0;

	// Create bookmark
	verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("BOOKMARK2")));
	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
		verify_success(sync_item->CommitItem(FALSE, TRUE));
	}
	sync_item_ptr = 0;

	// Update item in the queue
	verify_success(coordinator.UpdateItem(OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK1"), OpSyncItem::SYNC_KEY_PREV, UNI_L("BOOKMARK2")));

	// Create bookmark
	verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("BOOKMARK3")));
	verify(sync_item_ptr);
	{
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
		verify_success(sync_item->CommitItem(FALSE, TRUE));
	}
	sync_item_ptr = 0;

	// Update item in the queue
	verify_success(coordinator.UpdateItem(OpSyncDataItem::DATAITEM_BOOKMARK, UNI_L("BOOKMARK2"), OpSyncItem::SYNC_KEY_PREV, UNI_L("BOOKMARK3")));

	/*
		Order in the queue should now be:

		BOOKMARK 3
		BOOKMARK 2
		BOOKMARK 1
	*/

	// verify the order
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);
	OpSyncDataQueue* data_queue = sync_helper.GetSyncDataQueue();
	verify(data_queue != NULL);

	// verify that the items were really reordered to reflect the change in parent and previous
	OpSyncDataCollection* collection = data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_ACTIVE);
	verify(collection != NULL);

	OpSyncDataItemIterator current(collection->First());

	// 1st should be the 3rd bookmark
	verify(*current);
	verify_string(current->FindData(UNI_L("id")), "BOOKMARK3");
	verify(current->GetType() == OpSyncDataItem::DATAITEM_BOOKMARK);

	// 2nd should be the 2nd bookmark
	verify(++current);
	verify_string(current->FindData(UNI_L("id")), "BOOKMARK2");
	verify(current->GetType() == OpSyncDataItem::DATAITEM_BOOKMARK);

	// 3rd should be the 1st bookmark
	verify(++current);
	verify_string(current->FindData(UNI_L("id")), "BOOKMARK1");
	verify(current->GetType() == OpSyncDataItem::DATAITEM_BOOKMARK);
}

test("strip illegal control chars")
require success "create items";
{
	OpSyncItem* sync_item_ptr = 0;
	OpString data;

 	verify_success(sync_coordinator->GetExistingSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L(GUID1)));
 	verify(sync_item_ptr);
	OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);

	verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_TITLE, UNI_L("\x01\x019\tOpera Software ASA\n\r")));

	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_TITLE, data));
	verify_string(data, "\tOpera Software ASA\n\r");
}

test("parse items")
require success "create items";
require SYNC_HAVE_PASSWORD_MANAGER;
require PREFS_WRITE;
file uni input_1_xml "input_1.xml";
{
	int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	int sync_passwords = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncPasswordManager);
	int sync_bookmarks = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncBookmarks);
#ifdef SYNC_HAVE_EXTENSIONS
	int sync_extensions = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncExtensions);
#endif
	// Enable password syncing to test parsing the pm_* items:
	TRAPD(ignore, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, 1));
	TRAP(ignore, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, 1));
	TRAP(ignore, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));
#ifdef SYNC_HAVE_EXTENSIONS
	TRAP(ignore, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncExtensions, 1));
#endif

	verify(!sync_coordinator->UseDiskQueue());
#ifdef SYNC_ENCRYPTION_KEY_SUPPORT
	SyncEncryptionKeyManager encryption_key_manager;
	SyncEncryptionKeyManager::SelftestHelper key_helper(&encryption_key_manager);
	/* Initialise the coordinator and the encryption_key_manager such that the
	 * encryption-key is set, so OpSyncCoordinator::StartSync() does not create
	 * a request for the encryption-key only and we can test parsing a normal
	 * xml response: */
	TRAPD(status, encryption_key_manager.InitL(sync_coordinator));
	verify_success(status);
	/* Don't let the SyncEncryptionKeyManager receive the encryption-key from
	 * input_1.xml, the sync_listener instance already gets all items, and the
	 * SyncEncryptionKeyManager will fail to decrypt the data, causing an
	 * unexpected error: */
	sync_coordinator->RemoveSyncDataClient(&encryption_key_manager, OpSyncDataItem::DATAITEM_ENCRYPTION_KEY);
	const OpStringC username(UNI_L("zog"));
	const OpStringC encrypted_key(UNI_L("+dYkZO4EYZvkQge/0fE1saPh4e9zNjud0g4Z4ai1H5HxpDriuNNFSupNpR+wXRVoL5a7q3WoVyDP+FGiTMXc+qX+sUlYtRPQ6v4vC6R0YFyHdeEy/+/a5A=="));
	const OpStringC decrypted_key(UNI_L("000102030405060708090A0B0C0D0E0F"));
	key_helper.SetEncryptionKey(encrypted_key, decrypted_key, username);
	verify(encryption_key_manager.HasEncryptionKey());
#endif // SYNC_ENCRYPTION_KEY_SUPPORT

	OpSyncCoordinator::SelftestHelper sync_helper(sync_coordinator);
	/* Clear the data-queue, so we can load input_1_xml into an empty queue: */
	sync_helper.ClearDataQueue();
	verify_success(sync_helper.StartFileSync(input_1_xml));
	verify(sync_listener->listener_failed == FALSE);
	/* After the first complete sync we expect the disk-queue to be enabled: */
	verify(sync_coordinator->UseDiskQueue());
}
finally
{
	if (!sync_enabled)
		TRAP(ignore, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	if (!sync_passwords)
		TRAP(ignore, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncPasswordManager, sync_passwords));
	if (!sync_bookmarks)
		TRAP(ignore, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, sync_bookmarks));
#ifdef SYNC_HAVE_EXTENSIONS
	if (!sync_extensions)
		TRAP(ignore, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncExtensions, sync_extensions));
#endif

	sync_coordinator->SetSyncActive(FALSE);
	sync_coordinator->OnSyncError(SYNC_ERROR, UNI_L("test is finished"));
	sync_coordinator->SetUseDiskQueue(FALSE);
}

test("parse items: count")
require success "parse items";
{
	int real_items = 0;
	verify(sync_listener->incoming_items.HasItems());
	for (OpSyncItemIterator item(sync_listener->incoming_items.First()); *item; ++item)
	{
		real_items++;
		OpSyncDataItem::DataItemType type = item->GetType();
		verify(type != OpSyncDataItem::DATAITEM_GENERIC);
		verify(type == OpSyncDataItem::DATAITEM_BOOKMARK ||
			   type == OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER ||
			   type == OpSyncDataItem::DATAITEM_BOOKMARK_SEPARATOR ||
			   type == OpSyncDataItem::DATAITEM_ENCRYPTION_KEY ||
			   type == OpSyncDataItem::DATAITEM_PM_HTTP_AUTH ||
			   type == OpSyncDataItem::DATAITEM_PM_FORM_AUTH ||
			   type == OpSyncDataItem::DATAITEM_EXTENSION);
	}

	/* items in input_1.xml include:
	 * - 18 bookmarks/bookmark folders
	 * - 1 pm_form_auth
	 * - 1 encryption_key (which is automatically enabled for password manager)
	 * - 1 extension
	 * - 2 speeddial, which are not counted in the incoming_items,
	 *   because the selftest does not include speeddial support, see
	 *   test("create object").
	 * So verify that we received all items this listener supports:
	 */
#ifdef SYNC_HAVE_EXTENSIONS
	verify(real_items == 21);
#else
	verify(real_items == 20);
#endif
}

foreach (test_name, condition, table_type, table_id, table_key, expected_data) from Table_input_1
{
	test("parse items: " test_name)
		require success "parse items";
		require condition;
	{
		bool found_item = false;
		for (OpSyncItemIterator item(sync_listener->incoming_items.First()); *item; ++item)
		{
			if (table_type == item->GetType())
			{
				OpString id;
				verify_success(item->GetData(OpSyncItem::SYNC_KEY_ID, id));
				if (id == table_id)
				{
					OpString data;
					verify_success(item->GetData(table_key, data));
					verify_string(data, expected_data);
					found_item = true;
				}
			}
		}
		verify(found_item);
	}
}

test("parse items: encryption_key")
require success "parse items";
{
	bool found_item = false;
	for (OpSyncItemIterator item(sync_listener->incoming_items.First()); *item; ++item)
	{
		if (OpSyncDataItem::DATAITEM_ENCRYPTION_KEY == item->GetType())
		{
			OpSyncDataItem* data_item = item->GetDataSyncItem();
			verify(data_item);
			verify_string(data_item->m_key, "id");
			verify_string(data_item->m_data, "0");
			verify(data_item->HasChildren());
			OpSyncDataItem* child = data_item->FindChildById(UNI_L(""));
			verify_string(child->m_data, "0102030405060708090A");
			found_item = true;
		}
	}
	verify(found_item);
}

test("Add and modify same item")
{
	/* This test verifies that you generate one OpSyncDataItem with the correct
	 * data if you first add an OpSyncItem with status "added" and then create
	 * another OpSyncItem with the same sync-id and status "modified". */
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);

	verify_success(coordinator.Init(factory, FALSE));

	{
		/* 1. create a bookmark with status added: */
		OpSyncItem* sync_item_ptr;
		verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("bookmark 1")));
		verify(sync_item_ptr);
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		verify_success(sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED));
		verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_TITLE, UNI_L("Opera Software ASA")));
		verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_URI, UNI_L("http://www.opera.com/")));
		verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_PREV, UNI_L("")));
		verify_success(sync_item->CommitItem());
	}

	{
		/* 2. create a bookmark item with status modified, modifying the title
		 * only: */
		OpSyncItem* sync_item_ptr;
		verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("bookmark 1")));
		verify(sync_item_ptr);
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		verify_success(sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_MODIFIED));
		verify_success(sync_item->SetData(OpSyncItem::SYNC_KEY_TITLE, UNI_L("Opera")));
		verify_success(sync_item->CommitItem());
	}

	/* verify the items in the active queue: */
	OpSyncDataQueue* data_queue = sync_helper.GetSyncDataQueue();
	verify(data_queue != NULL);
	OpSyncDataCollection* active_items = data_queue->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_ACTIVE);
	verify(active_items);

	verify(active_items->GetCount() == 1);
	OpString data;

	{
		OpSyncItem* sync_item_ptr;
		verify_success(coordinator.GetSyncItem(&sync_item_ptr, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("bookmark 1")));
		verify(sync_item_ptr);
		OpAutoPtr<OpSyncItem> sync_item(sync_item_ptr);
		OpSyncDataItem* data_item = active_items->First();
		verify(data_item->GetStatus() == OpSyncDataItem::DATAITEM_ACTION_ADDED);
		sync_item->SetDataSyncItem(data_item);
		verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, data));
		verify_string(data, "bookmark 1");
		verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_TITLE, data));
		verify_string(data, "Opera");
		verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_URI, data));
		verify_string(data, "http://www.opera.com/");
		verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_PREV, data));
		verify_string(data, "");
	}
}

test("BroadcastDataAvailable")
{
	/* This test verifies that an OpSyncDataClient can return the OpSyncError
	 * SYNC_DATAERROR_ASYNC in a call to SyncDataAvailable() and that the
	 * sync-items for that data-types remain in the received item queue, but the
	 * sync-items for another data-type are removed. */
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);

	ST_SyncListener* listener1 = 0;
	ST_SyncListener* listener2 = 0;

	verify_success(coordinator.Init(factory, FALSE));

	/* listener1 is an OpSyncDataClient (for bookmark type) that consumes the
	 * OpSyncItems */
	listener1 = OP_NEW(ST_SyncListener, (&coordinator));
	verify(listener1);
	coordinator.SetSyncDataClient(listener1, OpSyncDataItem::DATAITEM_BOOKMARK);

	/* listener2 is an OpSyncDataItem (for password manager types) that sets the
	 * sync-error to SYNC_DATAERROR_ASYNC */
	listener2 = OP_NEW(ST_SyncListener, (&coordinator));
	verify(listener2);
	coordinator.SetSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_FORM_AUTH);
	coordinator.SetSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH);
	listener2->SetNextSyncDataError(SYNC_DATAERROR_ASYNC);

	/* Populate the received item data-queue with one bookmark item, one pm-form
	 * item and one pm-http item: */
	OpSyncDataQueue* data_queue = sync_helper.GetSyncDataQueue();
	verify(data_queue != NULL);
	OpSyncCollection* received_items = data_queue->GetSyncCollection(OpSyncDataQueue::SYNCQUEUE_RECEIVED_ITEMS);
	verify(received_items);

	OpSyncItem* sync_item;
	// one bookmark:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("book 1")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_TITLE, UNI_L("Opera Software ASA"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_URI, UNI_L("http://www.opera.com/"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_PREV, UNI_L(""));
	received_items->AddItem(sync_item);

	// one pm-form:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_PM_FORM_AUTH, OpSyncItem::SYNC_KEY_ID, UNI_L("form 2")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_PAGE_URL, UNI_L("BLOB1"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_FORM_DATA, UNI_L("BLOB2"));
	received_items->AddItem(sync_item);

	// one pm-http:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH, OpSyncItem::SYNC_KEY_ID, UNI_L("http 3")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_PAGE_URL, UNI_L("BLOBa"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_USERNAME, UNI_L("BLOBb"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_PASSWORD, UNI_L("BLOBc"));
	received_items->AddItem(sync_item);
	verify(received_items->GetCount() == 3);

	// broadcast the new items to all listeners
	OpSyncState sync_state;
	sync_state.SetSyncState(UNI_L("15"));
	sync_state.SetSyncState(UNI_L("15"), SYNC_SUPPORTS_BOOKMARK);
	sync_state.SetSyncState(UNI_L("15"), SYNC_SUPPORTS_PASSWORD_MANAGER);
	SyncSupportsState supports_state;
	supports_state.SetSupports(SYNC_SUPPORTS_BOOKMARK, true);
	supports_state.SetSupports(SYNC_SUPPORTS_PASSWORD_MANAGER, true);
	verify_success(sync_helper.BroadcastDataAvailable(supports_state, sync_state));
	/* now the bookmark should be removed from the received queue and the
	 * pm-entries should remain, and the sync-state for
	 * SYNC_SUPPORTS_PASSWORD_MANAGER should be not-persistent */
	OpString id;
	verify(received_items->GetCount() == 2);
	sync_item = received_items->First();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "form 2");
	sync_item = sync_item->Next();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "http 3");

	verify(listener1->incoming_items.GetCount() == 1); // one bookmark
	sync_item = listener1->incoming_items.First();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "book 1");

	verify(listener2->incoming_items.GetCount() == 2); // two pm items
	sync_item = listener2->incoming_items.First();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "form 2");
	sync_item = sync_item->Next();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "http 3");
}
finally
{
	if (listener1)
	{
		coordinator.RemoveSyncDataClient(listener1, OpSyncDataItem::DATAITEM_BOOKMARK);
		OP_DELETE(listener1);
	}
	if (listener2)
	{
		coordinator.RemoveSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_FORM_AUTH);
		coordinator.RemoveSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH);
		OP_DELETE(listener2);
	}
}

test("BroadcastDataAvailable one supports type only")
require success "BroadcastDataAvailable";
{
	/* This test verifies that only the OpSyncDataClient for the specified
	 * supports type is called when BroadcastDataAvailable() is called with a
	 * different argument than SYNC_SUPPORTS_MAX. Any OpSyncItem for another
	 * data-type (here bookmark) shall not be removed and the data-types for the
	 * specified supports type is not removed if the OpSyncDataClient sets the
	 * sync-error to SYNC_DATAERROR_ASYNC in the call to SyncDataAvailable().
	 * (See also ContinueSyncData() for the test when the sync-client does not
	 * set the sync-error to SYNC_DATAERROR_ASYNC.) */
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);

	ST_SyncListener* listener1 = 0;
	ST_SyncListener* listener2 = 0;

	verify_success(coordinator.Init(factory, FALSE));

	/* listener1 is an OpSyncDataClient (for bookmark type) that is expected to
	 * not be called: */
	listener1 = OP_NEW(ST_SyncListener, (&coordinator));
	verify(listener1);
	coordinator.SetSyncDataClient(listener1, OpSyncDataItem::DATAITEM_BOOKMARK);

	/* listener2 is an OpSyncDataItem (for password manager types) that sets the
	 * sync-error to SYNC_DATAERROR_ASYNC */
	listener2 = OP_NEW(ST_SyncListener, (&coordinator));
	verify(listener2);
	coordinator.SetSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_FORM_AUTH);
	coordinator.SetSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH);
	listener2->SetNextSyncDataError(SYNC_DATAERROR_ASYNC);

	/* Populate the received item data-queue with one bookmark item, one pm-form
	 * item and one pm-http item: */
	OpSyncDataQueue* data_queue = sync_helper.GetSyncDataQueue();
	verify(data_queue != NULL);
	OpSyncCollection* received_items = data_queue->GetSyncCollection(OpSyncDataQueue::SYNCQUEUE_RECEIVED_ITEMS);
	verify(received_items);

	OpSyncItem* sync_item;
	// one bookmark:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("book 1")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_TITLE, UNI_L("Opera Software ASA"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_URI, UNI_L("http://www.opera.com/"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_PREV, UNI_L(""));
	received_items->AddItem(sync_item);

	// one pm-form:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_PM_FORM_AUTH, OpSyncItem::SYNC_KEY_ID, UNI_L("form 2")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_PAGE_URL, UNI_L("BLOB1"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_FORM_DATA, UNI_L("BLOB2"));
	received_items->AddItem(sync_item);

	// one pm-http:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH, OpSyncItem::SYNC_KEY_ID, UNI_L("http 3")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_PAGE_URL, UNI_L("BLOBa"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_USERNAME, UNI_L("BLOBb"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_PASSWORD, UNI_L("BLOBc"));
	received_items->AddItem(sync_item);
	verify(received_items->GetCount() == 3);

	// broadcast the new items to all listeners
	OpSyncState sync_state;
	sync_state.SetSyncState(UNI_L("15"));
	sync_state.SetSyncState(UNI_L("15"), SYNC_SUPPORTS_BOOKMARK);
	sync_state.SetSyncState(UNI_L("15"), SYNC_SUPPORTS_PASSWORD_MANAGER);
	SyncSupportsState supports_state;
	supports_state.SetSupports(SYNC_SUPPORTS_PASSWORD_MANAGER, true);
	verify_success(sync_helper.BroadcastDataAvailable(supports_state, sync_state));
	/* now the bookmark listener should not be called and the pm-entries should
	 * remain as well, and the sync-state for SYNC_SUPPORTS_PASSWORD_MANAGER
	 * should be not-persistent */
	OpString id;
	verify(received_items->GetCount() == 3);
	sync_item = received_items->First();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "book 1");
	sync_item = sync_item->Next();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "form 2");
	sync_item = sync_item->Next();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "http 3");

	verify(listener1->incoming_items.GetCount() == 0); // was not called

	verify(listener2->incoming_items.GetCount() == 2); // two pm items
	sync_item = listener2->incoming_items.First();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "form 2");
	sync_item = sync_item->Next();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "http 3");
}
finally
{
	if (listener1)
	{
		coordinator.RemoveSyncDataClient(listener1, OpSyncDataItem::DATAITEM_BOOKMARK);
		OP_DELETE(listener1);
	}
	if (listener2)
	{
		coordinator.RemoveSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_FORM_AUTH);
		coordinator.RemoveSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH);
		OP_DELETE(listener2);
	}
}

test("ContinueSyncData")
require success "BroadcastDataAvailable one supports type only";
{
	/* This test verifies that an OpSyncDataClient can return the OpSyncError
	 * SYNC_DATAERROR_ASYNC in a call to SyncDataAvailable() and that calling
	 * ContinueSyncData() results in another call to SyncDataAvailable() and if
	 * the client then sets the sync-error to SYNC_DATAERROR_ASYNC all
	 * sync-items of that data-type are removed (while other data-types remain).
	 */
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	OpSyncCoordinator coordinator;
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);

	ST_SyncListener* listener1 = 0;
	ST_SyncListener* listener2 = 0;

	verify_success(coordinator.Init(factory, FALSE));

	/* listener1 is an OpSyncDataClient (for bookmark type) that consumes the
	 * OpSyncItems */
	listener1 = OP_NEW(ST_SyncListener, (&coordinator));
	verify(listener1);
	coordinator.SetSyncDataClient(listener1, OpSyncDataItem::DATAITEM_BOOKMARK);

	/* listener2 is an OpSyncDataItem (for password manager types) that sets the
	 * sync-error to SYNC_DATAERROR_ASYNC in the first call and
	 * SYNC_DATAERROR_NONE in the second call (which is initiated by
	 * ContinueSyncData(): */
	listener2 = OP_NEW(ST_SyncListener, (&coordinator));
	verify(listener2);
	coordinator.SetSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_FORM_AUTH);
	coordinator.SetSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH);
	// first use SYNC_DATAERROR_ASYNC:
	listener2->SetNextSyncDataError(SYNC_DATAERROR_ASYNC);

	/* Populate the received item data-queue with one bookmark item, one pm-form
	 * item and one pm-http item: */
	OpSyncDataQueue* data_queue = sync_helper.GetSyncDataQueue();
	verify(data_queue != NULL);
	OpSyncCollection* received_items = data_queue->GetSyncCollection(OpSyncDataQueue::SYNCQUEUE_RECEIVED_ITEMS);
	verify(received_items);

	OpSyncItem* sync_item;
	// one bookmark:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("book 1")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_TITLE, UNI_L("Opera Software ASA"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_URI, UNI_L("http://www.opera.com/"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_PREV, UNI_L(""));
	received_items->AddItem(sync_item);

	// one pm-form:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_PM_FORM_AUTH, OpSyncItem::SYNC_KEY_ID, UNI_L("form 2")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_PAGE_URL, UNI_L("BLOB1"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_FORM_DATA, UNI_L("BLOB2"));
	received_items->AddItem(sync_item);

	// one pm-http:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH, OpSyncItem::SYNC_KEY_ID, UNI_L("http 3")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_PAGE_URL, UNI_L("BLOBa"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_USERNAME, UNI_L("BLOBb"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_PASSWORD, UNI_L("BLOBc"));
	received_items->AddItem(sync_item);
	verify(received_items->GetCount() == 3);

	// broadcast the new items to all listeners
	OpSyncState sync_state;
	sync_state.SetSyncState(UNI_L("15"));
	sync_state.SetSyncState(UNI_L("15"), SYNC_SUPPORTS_BOOKMARK);
	sync_state.SetSyncState(UNI_L("15"), SYNC_SUPPORTS_PASSWORD_MANAGER);
	SyncSupportsState supports_state;
	supports_state.SetSupports(SYNC_SUPPORTS_BOOKMARK, true);
	supports_state.SetSupports(SYNC_SUPPORTS_PASSWORD_MANAGER, true);
	verify_success(sync_helper.BroadcastDataAvailable(supports_state, sync_state));

	/* Now the bookmark listener was called and the bookmark item was consumed,
	 * while the pm-item was not consumed: */
	verify(listener1->incoming_items.GetCount() == 1); // one bookmark
	listener1->ClearIncomingItems();
	verify(listener2->incoming_items.GetCount() == 2); // two pm items
	listener2->ClearIncomingItems();
	verify(received_items->GetCount() == 2); // pm items

	/* On the next call to SyncDataAvailable() the listener2 shall no longer set
	 * the error code SYNC_DATAERROR_ASYNC: */
	listener2->SetNextSyncDataError(SYNC_DATAERROR_NONE);

	// Add another bookmark:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, UNI_L("book 4")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_MODIFIED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_TITLE, UNI_L("Testing"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_URI, UNI_L("some url"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_PREV, UNI_L(""));
	received_items->AddItem(sync_item);

	// Add another pm-form:
	verify_success(coordinator.GetSyncItem(&sync_item, OpSyncDataItem::DATAITEM_PM_FORM_AUTH, OpSyncItem::SYNC_KEY_ID, UNI_L("form 5")));
	verify(sync_item);
	sync_item->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED);
	sync_item->SetData(OpSyncItem::SYNC_KEY_PAGE_URL, UNI_L("BLOBX"));
	sync_item->SetData(OpSyncItem::SYNC_KEY_FORM_DATA, UNI_L("BLOBY"));
	received_items->AddItem(sync_item);

	coordinator.ContinueSyncData(SYNC_SUPPORTS_PASSWORD_MANAGER);

	/* now the bookmark listener should not be called and the pm-entries should
	 * be removed */
	verify(listener1->incoming_items.GetCount() == 0); // was not called
	verify(listener2->incoming_items.GetCount() == 3); // three pm items
	verify(received_items->GetCount() == 1); // the new bookmark

	OpString id;
	sync_item = received_items->First();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "book 4");

	sync_item = listener2->incoming_items.First();
	// Note: we first get all form-items
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "form 2");
	sync_item = sync_item->Next();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "form 5");
	// then the http item:
	sync_item = sync_item->Next();
	verify_success(sync_item->GetData(OpSyncItem::SYNC_KEY_ID, id));
	verify_string(id, "http 3");
}
finally
{
	if (listener1)
	{
		coordinator.RemoveSyncDataClient(listener1, OpSyncDataItem::DATAITEM_BOOKMARK);
		OP_DELETE(listener1);
	}
	if (listener2)
	{
		coordinator.RemoveSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_FORM_AUTH);
		coordinator.RemoveSyncDataClient(listener2, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH);
		OP_DELETE(listener2);
	}
}

subtest CreateBookmarkSyncItem(OpSyncCoordinator& coordinator, OpSyncItem** sync_item, bool is_folder, unsigned int i, unsigned int parent)
{
	OpString value;
	if (is_folder)
		verify_success(value.AppendFormat("bookmark-folder-with-id-%08d", i));
	else
		verify_success(value.AppendFormat("bookmark-with-id-%08d", i));
	verify(sync_item);
	verify_success(coordinator.GetSyncItem(sync_item, is_folder ? OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER : OpSyncDataItem::DATAITEM_BOOKMARK, OpSyncItem::SYNC_KEY_ID, value.CStr()));
	verify(*sync_item);
	verify_success((*sync_item)->SetStatus(OpSyncDataItem::DATAITEM_ACTION_ADDED));

	if (parent)
	{
		value.Set(""); verify_success(value.AppendFormat("bookmark-folder-with-id-%08d", i));
		verify_success((*sync_item)->SetData(OpSyncItem::SYNC_KEY_PARENT, value));
	}
	if (!is_folder)
	{
		value.Set(""); value.AppendFormat("created-at-%08d", i);
		verify_success((*sync_item)->SetData(OpSyncItem::SYNC_KEY_CREATED, value));
	}
	value.Set(""); value.AppendFormat("title: %08d", i);
	verify_success((*sync_item)->SetData(OpSyncItem::SYNC_KEY_TITLE, value));
	value.Set(""); value.AppendFormat("description: %08d", i);
	verify_success((*sync_item)->SetData(OpSyncItem::SYNC_KEY_DESCRIPTION, value));
	value.Set(""); value.AppendFormat("nickname-%08d", i);
	verify_success((*sync_item)->SetData(OpSyncItem::SYNC_KEY_NICKNAME, value));
	value.Set(""); value.AppendFormat("%08d", i);
	verify_success((*sync_item)->SetData(OpSyncItem::SYNC_KEY_PANEL_POS, value));
}

/** This test creates a collection of 5000 OpSyncItems, creates a copy of these
 * and verifies that OpSyncCoordinator::MergeDirtySyncItems() merges all items
 * correctly. This selftest was mainly used to improve the performance of
 * OpSyncCoordinator::MergeDirtySyncItems().
 */
test("Merge dirty sync items")
{
	/* enable the following line (and the corresponding lines) to add simple
	 * profiling of the OpSyncCoordinator::MergeDirtySyncItems(): */
	//double start = g_op_time_info->GetRuntimeMS();
	// save current prefs ...
	OP_STATUS s;
	int sync_used = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncUsed);
	int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	int sync_bookmarks = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncBookmarks);
	// ... before ensuring to enable bookmark sync:
	if (sync_used)
		TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, 0));
	if (!sync_enabled)
		TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));
	if (!sync_bookmarks)
		TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, 1));

	OpSyncCoordinator coordinator;
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	verify(factory);
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0; // now the coordinator owns the factory ...

	OpSyncDataHashedCollection items_from_client;
	OpSyncDataCollection items_from_server;
	OpSyncDataCollection items_missing_on_client;
	OpSyncDataCollection items_missing_on_server;
	/* Create a bunch of bookmarks and folders.
	 * The first 100 items (0..99) are folders,
	 * the first 50 folders 0..49 have no parent,
	 * the folders 50..99 have the parent 1,
	 * the items 100..5000 are bookmarks: */
	const unsigned int COUNT_ITEMS = 5000;
	for (unsigned int i=0; i<COUNT_ITEMS; i++)
	{
		OpSyncItem* sync_item = 0;
		verify(CreateBookmarkSyncItem(coordinator, &sync_item, i < 100, i, (i/50)%100));
		verify(sync_item);
		sync_item->CommitItem(TRUE, FALSE);
		OP_DELETE(sync_item);
	}

	// Move all dirty items into items_from_client:
	OpSyncDataCollection* dirty_items = sync_helper.GetSyncDataQueue()->GetSyncDataCollection(OpSyncDataQueue::SYNCQUEUE_DIRTY_ITEMS);
	items_from_client.AppendItems(dirty_items);
	// Create a copy of all items in items_from_server (in reverse order to make
	// the find operation as expensive as possible):
	for (OpSyncDataItemIterator item(items_from_client.First()); *item; ++item)
		items_from_server.AddFirst(item->Copy());

	verify(items_from_client.GetCount() == COUNT_ITEMS);
	verify(items_from_server.GetCount() == COUNT_ITEMS);
	//double merge_start = g_op_time_info->GetRuntimeMS();
	verify_success(sync_helper.MergeDirtySyncItems(items_from_client, items_from_server, items_missing_on_client, items_missing_on_server));
	//double merge_done = g_op_time_info->GetRuntimeMS();
	//output("\ntime: %fs (%fs total)\n", (merge_done-merge_start)/1000.0, (merge_done-start)/1000.0);
	verify(items_from_client.GetCount() == 0);
	verify(items_from_server.GetCount() == 0);
	verify(items_missing_on_client.GetCount() == 0);
	verify(items_missing_on_server.GetCount() == 0);
}
finally
{
	// restore prefs
	if (sync_used)
		TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncUsed, sync_used));
	if (!sync_enabled)
		TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
	if (!sync_bookmarks)
		TRAP(s, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncBookmarks, sync_bookmarks));
}

test("FindAcceptedFormatFromType")
{
	BOOL match_on_subtype;

	SYNCACCEPTEDFORMAT *accepted = FindAcceptedFormatFromType(OpSyncDataItem::DATAITEM_BLACKLIST, match_on_subtype);
	verify(accepted && match_on_subtype && accepted->sub_element_item_type == OpSyncDataItem::DATAITEM_BLACKLIST);

	accepted = FindAcceptedFormatFromType(OpSyncDataItem::DATAITEM_BOOKMARK, match_on_subtype);
	verify(accepted && !match_on_subtype);

	accepted = FindAcceptedFormatFromType(OpSyncDataItem::DATAITEM_URLFILTER, match_on_subtype);
	verify(accepted && !match_on_subtype);
}

test("OnSyncError")
file uni input_err_xml "input_err.xml";
{
	/* Verifies that an error-code and error-message, that is delivered in an
	 * xml-document from the Link server, is forwarded to the associated
	 * OpSyncUIListener instance. */
	int sync_enabled = g_pcsync->GetIntegerPref(PrefsCollectionSync::SyncEnabled);
	TRAPD(ignore, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, 1));

	ST_SyncUIListener ui_listener;
	OpSyncCoordinator coordinator;
	ST_SyncFactory* factory = OP_NEW(ST_SyncFactory, ());
	verify(factory);
	// sync_coordinator takes ownership of the sync_factory now
	verify_success(coordinator.Init(factory, FALSE));
	factory = 0;
	verify_success(coordinator.SetSyncUIListener(&ui_listener));
#ifdef SYNC_ENCRYPTION_KEY_SUPPORT
	SyncEncryptionKeyManager encryption_key_manager;
	TRAP(ignore, encryption_key_manager.InitL(&coordinator));
#endif // SYNC_ENCRYPTION_KEY_SUPPORT
	OpSyncCoordinator::SelftestHelper sync_helper(&coordinator);
	verify_success(sync_helper.StartFileSync(input_err_xml));
	OpString error_message;
	verify(ui_listener.GetLastError(error_message) == SYNC_ERROR_PARSER);
	verify_string(error_message, "Error Message 203");
}
finally
{
	coordinator.RemoveSyncUIListener(&ui_listener);
	if (!sync_enabled)
		TRAP(ignore, g_pcsync->WriteIntegerL(PrefsCollectionSync::SyncEnabled, sync_enabled));
}

exit
{
	if (sync_coordinator && sync_listener)
	{
		sync_coordinator->RemoveSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_BOOKMARK);
		// this one should be ignored:
		sync_coordinator->RemoveSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_BOOKMARK_FOLDER);
		sync_coordinator->RemoveSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_PM_FORM_AUTH);
		sync_coordinator->RemoveSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_PM_HTTP_AUTH);
		sync_coordinator->RemoveSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_ENCRYPTION_KEY);
		sync_coordinator->RemoveSyncDataClient(sync_listener, OpSyncDataItem::DATAITEM_EXTENSION);
	}

	OP_DELETE(sync_listener);
	sync_listener = 0;

	OP_DELETE(sync_coordinator);
	sync_coordinator = 0;
}

test("Generate XML for extension")
	require SYNC_HAVE_EXTENSIONS;
{
	// A factory that makes MyOperaSyncParsers.
	ST_SyncFactory factory;

	// Create a parser - this is a MyOperaSyncParsers instance.
	OpSyncParser* parser = NULL;
	verify_success(factory.GetParser(&parser, NULL));
	OpSharedPtr<OpSyncParser> parser_anchor(parser);

	// Set up a data queue, needed for generating xml.
	OpSyncDataQueue* data_queue = NULL;
	verify_success(factory.GetQueueHandler(&data_queue, NULL, FALSE));
	OpSharedPtr<OpSyncDataQueue> queue_anchor(data_queue);

	parser->SetDataQueue(data_queue);

	// Create a DATAITEM_EXTENSION Item.
	OpSharedPtr<OpSyncItem> extension_item = make_shared<OpSyncItem>(OpSyncDataItem::DATAITEM_EXTENSION);
	verify(extension_item.get());
	verify_success(extension_item->Construct());

	// Set its attributes.
	verify_success(extension_item->SetPrimaryKey(OpSyncItem::SYNC_KEY_ID, UNI_L("cd4a8b0725a44fcdbaf20d48f7d00a10")));
	verify_success(extension_item->SetData(OpSyncItem::SYNC_KEY_AUTHOR, UNI_L("Anonymous Opera Developer")));
	verify_success(extension_item->SetData(OpSyncItem::SYNC_KEY_TITLE, UNI_L("ST extension")));
	verify_success(extension_item->SetData(OpSyncItem::SYNC_KEY_EXTENSION_UPDATE_URI, UNI_L("http://url")));
	verify_success(extension_item->SetData(OpSyncItem::SYNC_KEY_VERSION, UNI_L("0.9")));

	// The collection will hold our single extension_item
	OpSyncDataCollection collection;
	collection.AddItem(extension_item->GetDataSyncItem());

	// Generate!
	OpString8 generated_xml;
	verify_success(static_cast<MyOperaSyncParser*>(parser)->GenerateXML(generated_xml, collection));
	generated_xml.Strip(TRUE, TRUE); // Stripping leading and trailing whitespace.

	OpString8 expected_xml;
	verify_success(expected_xml.Append("<?xml version=\"1.0\" encoding=\"utf-8\"?>"));
	verify_success(expected_xml.Append("<link version=\"1.2\" syncstate=\"0\" dirty=\"0\" xmlns=\"http://xmlns.opera.com/2006/link\">"));
	verify_success(expected_xml.Append("<client_info/>"));
	verify_success(expected_xml.Append("<data>"));
	verify_success(expected_xml.Append("<extension status=\"added\" id=\"cd4a8b0725a44fcdbaf20d48f7d00a10\" version=\"0.9\">"));
	verify_success(expected_xml.Append("<author>Anonymous Opera Developer</author>"));
	verify_success(expected_xml.Append("<title>ST extension</title>"));
	verify_success(expected_xml.Append("<extension_update_uri>http://url</extension_update_uri>"));
	verify_success(expected_xml.Append("</extension>"));
	verify_success(expected_xml.Append("</data>"));
	verify_success(expected_xml.Append("</link>"));
	verify_string(generated_xml, expected_xml);
}
