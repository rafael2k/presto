<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
          "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<link rel=stylesheet href="../../coredoc/coredoc.css" />
<title>Module: Pubsuffix</title>
</head>

<body>

<h1>Module: Pubsuffix</h1>

<h2>About this module</h2>

<p>Pubsuffix will retrieve XML documents from an online repository that describes the domain hierarchy structure of individual Top Level Domains (TLDs),
providing a reasonably good way to tell registry-like domains like co.uk and vgs.no from ordinary domains like bbc.co.uk and vg.no, allowing
this information to be used as a foundation for security policies for cookies, Javascript (document.domain), and other features.</p>

<p>If no online specification can be found, a DNS based heuristic is used to guess what type of domain we are looking at.</p>

<p>This module is not be generally accessed, the primary API is ServerName::GetDomainTypeASync(), which will either return the domain type of the servername, 
or the initiate the asynchrounous operation(s) to retireve and decode the data.</p>

<p>The XML fileformat is described in <a href="draft-pettersen-subtld-structure.txt">draft-pettersen-subtld-structure.txt</a>, and IETF Internet-Draft, and 
the DNS heuristic is described in  <a href="draft-pettersen-dns-cookie-validate.txt">draft-pettersen-dns-cookie-validate.txt</a>.</p>

<h2>Interface overview and API documentation</h2>

<p><a href="api/index.html">API documentation generated by
Doxygen</a> contains all necessary information for the external APIs.</p>

<h3>Public API</h3>

<dl>
	<dt>ServerName::GetDomainTypeASync()
		<dd><p>(defined in url module) This function either returns the determined type of domain immediately, or ServerName::DOMAIN_WAIT_FOR_UPDATE if the 
		type is not yet available.  ServerName::GetCurrentDomainType() can be used to retrieve the current value, without triggering the lookup.</p>
			
			<p>If DOMAIN_WAIT_FOR_UPDATE is returned, the caller must register a callback, and wait for a MSG_PUBSUF_FINISHED_AUTO_UPDATE_ACTION (Id is 0)
		message before retrying. Multiple attempts may be needed, since this message does not specify any unique ID.</p>
			
			<dl>
				<dt>ServerName::DOMAIN_UNKNOWN
					<dd><p>The domain type is unknown.<p>
				<dt>ServerName::DOMAIN_NORMAL
					<dd><p>The domain is (believed to be) a normal host or commercial domain like www.opera.com or opera.com.</p>
				<dt>ServerName::DOMAIN_REGISTRY
					<dd><p>The domain is (believed to be) a registry-like domain like co.uk, vgs.no, or city.state.us</p>
				<dt>ServerName::DOMAIN_TLD
					<dd><p>The domain is a Top Level Domain</p>
			</dl>
</dl>

<h3> Semi-Public API</h3>

<dl>
	<dt>PubsuffixModule::CheckDomainASync()
		<dd><p>(Accessed through g_pubsuf_api-&gt;CheckDomainASync() ) Main engine for ServerName::GetDomainTypeASync().</p>
			
			<p>Initiates the loading and parsing of the specification files.</p>
			
			<p>Returns OpRecStatus::FINISHED if the operation completed immediately, OpStatus::OK if a lookup is started 
			(in which case MSG_PUBSUF_FINISHED_AUTO_UPDATE_ACTION will be posted when it is completed), or an OpStatus 
		error code if there was an error.</p>
</dl>

<h2>Implementation description</h2>

<p><a href="all/index.html">API documentation generated by
Doxygen</a> contains information about the internal organization of the module.</p>

<h3>Core APIs</h3>

<h4>PubsuffixModule</h4>

<p>This is the module object. It contains a list over TLDs that have been handled in this session. It may also (optionally) contain a list 
of override URLs for some TLDs.</p>

<dl>
	<dt>CheckDomainASync()
		<dd><p>Starts the process of retrieving the domain type of the requested domain. Operation can be asynchonous. See above for description.
			While looking up a TLD all other request for the same TLD will be blocked (in the case of the XML file they will be available at the same time as the first
		to request information.</p>
	<dt>HaveCheckedDomain()
		<dd><p>Have the specification of the identified TLD been checked in this session?</p>
	<dt>SetHaveCheckedDomain()
		<dd><p>Mark the speciifed TLD as checked in this session; Prevents multiple requests in the same session, particularly for failed requests.</p>
	<dt>AddUpdateOverride()
		<dd><p>(Import using API_PUBSUFFIX_OVERRIDE_UPDATE) Adds a override URL for a given TLD. Such overrides are NOT expected to be digitally signed.</p>
</dl>

<h4>PublicSuffix_Updater</h4>

<p>This class handles the actual download and parsing of the TLD's XML specification, and also manages the DNS based fallback handler.</p>

<p>The updater will download the file, if it has not been downloaded already, and is still current, it will then process the parsed XML file, and if that fails
initiate an attempt to check the type of the requested domain name using the DNS fallback.</p>

<dl>
	<dt>Construction
		<dd><p>The object is initialized using the TLD and the domain name that triggered the action. The Construct() 
		step either creates a default URL on the online repository, or based on a specified override URL for this sepcific TLD.</p>
	<dt>StartLoading()
		<dd><p>This will either start loading the specified URL, or if it has already been loaded, process the document immediately, and return. 
		If necessary, a fallback is initiated.</p>
	<dt>ProcessFile()
		<dd><p>This function parses the file, and sets all ServerNames in the specified TLD to the appropriate type.</p>
	<dt>SetFinished()
		<dd><p>This will, in in case of failure by the XML step, intiate a DNS fallback. Otherwise it will complete the operation and indicate that
		the request is finished.</p>
</dl>

<h4>DNS_RegistryCheck_Handler</h4>

<p>This is a fallback mechanism using DNS to determine if a given domain name is an ordinary name, or a registry like domain. The rule is that 
any domain name with an IP-address is considered an ordinary domain, one without is considered a registory-like domain.</p>

<p>In cases where a proxy is configured for a host, a HTTP HEAD request is sent instead of just doing a name lookup. This is because a DNS request for 
a proxied host might not return a valid result, as is the case when the client is behind a very thight firewall.</p>

<dl>
	<dt>Construction
		<dd><p>Initialized using the hostname to check</p>
	<dt>Start_Lookup
		<dd><p>Starts the lookup process. Normal use is to create a Comm object that will just do a DNS name lookup. When a proxy
			is configured a URL http://domainname/ with method HEAD is created, and used to request the information; 
		if a proxy is not configured for that particular host, then the Comm method is used instead.</p>
</dl>

<h3>Server</h3>

<p>The XML files downloaded from the online repository are generated by the script server/converter.py, with assistance from the digital signature 
generator Python extension in server/signer.cpp (extension created using the distutils script in server/build_signer.py).</p>

<p>The current input to the converter script is the Mozilla Public Suffix 
<a href=http://mxr.mozilla.org/mozilla-central/source/netwerk/dns/src/effective_tld_names.dat?raw=1">list</a>.</p>

<h3>Footprint</h3>

<p>The module is fairly small, about 10KB. Most of the processing is imported and performed by other modules, url and xmlfragment.</p>

<h3>Dynamic memory use and OOM handling</h3>

<dl>
<dt>OOM policies
<dd>><p>In OOM situations the current operation is aborted and a failure notice is given to the action's owner, either 
	by message or OpStatus return value. Very few functions LEAVE.</p>
	<p>An OOM condition is raised when detected in the module itself</p>

<dt>Who handles OOM?
<dd><p>Currently OOM is handled locally by aborting the operation. In some operations, when it is possible, the caller is informed of the status</p>

<dt>Flow
<dd><p>Much of the module is message callback based, and these functions are not able to report OOM situations directly to the documents or UI. 
	In these cases the current operation will be terminated, and errormessages sent.</p>

<dt>Heap memory usage
<dd><p>The module contains a list of TLD domain that have been checked in the current session, these data are currently 
	restricted to a single string for each TLD in a linked list (size about less than 32 plus an allocated string less than 8 bytes long).
	Usually a user will only visit at most a dozen or two different TLDs in a session, most of them having two or three characters in the name,
	meaning that typical heap memory use will be less than a 2 KB</p>
	
	<p>Optionally (API must be enabled), the module may also have a list of TLDs that have override URLs specified. The memory usage will primarily be decided
	by the string length of the URL.</p>
	
	<p>The module also defines a cache context used to store the URLs containing the pubsuffix data (these are stored for 30 days in disk cache)</p>

<dt>Stack memory usage
<dd><p>The pubsuffix parsing operation is recursive, but the number of levels is determined by the document being parsed. Usually limited to less than 6</p>

<dt>Static memory usage
<dd><p>Only what is contained in the module object, descibed above</p>

<dt>Caching and freeing memory
<dd><p>Caching is performed by the url and cache module in a separate context, subject to their caching policies.</p>

<dt>Freeing memory on exit
<dd><p>The list of checked TLDs is release automatically on exit, as is the cache context</p>

<dt>Temp buffers
<dd>None

<dt>Memory tuning
<dd><p>None directly available; memory usage may be controlled by the cache and URL modules.</p>

<dt>Tests
<dd><p>Selftest in module and imported from cookies</p>

<dt>Coverage
<dd><p>Selftest in module and imported from cookies</p>

<dt>Design choices
<dd><p>The specifications are stored as individual files on the remote repository. The files are digitally signed.</p>
	<p>The parsing only updates the servernames currently in use. Checks on new names require a new parsing of the file.</p>

<dt>Improvements
<dd><p>The specifications are stored as individual files on the remote repository. It may be that the combining all the files into one may 
	reduce accesses to the server, and reduce</p>
	<p>Handling of error situations might be improved, as might cache flushing.</p>
</dl>
