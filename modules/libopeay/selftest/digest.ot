group "libopeay.digest";
require _SSL_SUPPORT_;
language c++;

include "modules/libopeay/openssl/cryptlib.h";
include "modules/libopeay/openssl/evp.h";
include "modules/libopeay/openssl/sha.h";
include "modules/libopeay/openssl/md5.h";
include "modules/libopeay/selftest/digest.h";

global {
/* Test vectors from openssl*/

/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */


const static unsigned int sha1_input_sizes[1] = {3};
const static unsigned char sha1_input[] = {0x61, 0x62, 0x63};

const static unsigned char sha1_output[20] = 
	{0xa9, 0x99, 0x3e, 0x36, 0x47, 0x06, 0x81, 0x6a,
	 0xba, 0x3e, 0x25, 0x71, 0x78, 0x50, 0xc2, 0x6c, 
	 0x9c, 0xd0, 0xd8, 0x9d};


const static unsigned int md5_input_sizes[] = {0, 1,3, 14, 26, 62, 80};

const static unsigned char md5_input[][80] = {
	{0},

	{0x61},

	{0x61, 0x62, 0x63},

	{0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x20, 
	 0x64, 0x69, 0x67, 0x65, 0x73, 0x74},

	{0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 
	 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 
	 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 
	 0x79, 0x7a},

	{0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 
	 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
	 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 
	 0x59, 0x5a, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66,
	 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 
	 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76,
	 0x77, 0x78, 0x79, 0x7a, 0x30, 0x31, 0x32, 0x33, 
	 0x34, 0x35, 0x36, 0x37, 0x38, 0x39},

	{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 
	 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
	 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 
	 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32,
	 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 
	 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,
	 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 
	 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34,
	 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 
	 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30}
};

const static unsigned char md5_output[][16] = {
	{0xd4, 0x1d, 0x8c, 0xd9, 0x8f, 0x00, 0xb2, 0x04, 0xe9, 0x80, 0x09, 0x98, 0xec, 0xf8, 0x42, 0x7e},
	{0x0c, 0xc1, 0x75, 0xb9, 0xc0, 0xf1, 0xb6, 0xa8, 0x31, 0xc3, 0x99, 0xe2, 0x69, 0x77, 0x26, 0x61},
	{0x90, 0x01, 0x50, 0x98, 0x3c, 0xd2, 0x4f, 0xb0, 0xd6, 0x96, 0x3f, 0x7d, 0x28, 0xe1, 0x7f, 0x72},
	{0xf9, 0x6b, 0x69, 0x7d, 0x7c, 0xb7, 0x93, 0x8d, 0x52, 0x5a, 0x2f, 0x31, 0xaa, 0xf1, 0x61, 0xd0},
	{0xc3, 0xfc, 0xd3, 0xd7, 0x61, 0x92, 0xe4, 0x00, 0x7d, 0xfb, 0x49, 0x6c, 0xca, 0x67, 0xe1, 0x3b},
	{0xd1, 0x74, 0xab, 0x98, 0xd2, 0x77, 0xd9, 0xf5, 0xa5, 0x61, 0x1c, 0x2c, 0x9f, 0x41, 0x9d, 0x9f},
	{0x57, 0xed, 0xf4, 0xa2, 0x2b, 0xe3, 0xc9, 0x55, 0xac, 0x49, 0xda, 0x2e, 0x21, 0x07, 0xb6, 0x7a},

};


const static unsigned int sha256_input_sizes[][2] = {{3,3}, {56, 56}, {160, 1000000}};

const static unsigned char *sha256_input[] = 
{
	(const unsigned char *) "abc", // app_b1
	(const unsigned char *) "abcdbcde""cdefdefg""efghfghi""ghijhijk"
		"ijkljklm""klmnlmno""mnopnopq", // app_b2
	(const unsigned char *) "aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa" // app_b3
};

const static unsigned char sha256_output[][SHA256_DIGEST_LENGTH] = {
			// app_b1
{	0xba,0x78,0x16,0xbf,0x8f,0x01,0xcf,0xea,
	0x41,0x41,0x40,0xde,0x5d,0xae,0x22,0x23,
	0xb0,0x03,0x61,0xa3,0x96,0x17,0x7a,0x9c,
	0xb4,0x10,0xff,0x61,0xf2,0x00,0x15,0xad	},

			// app_b2
{	0x24,0x8d,0x6a,0x61,0xd2,0x06,0x38,0xb8,
	0xe5,0xc0,0x26,0x93,0x0c,0x3e,0x60,0x39,
	0xa3,0x3c,0xe4,0x59,0x64,0xff,0x21,0x67,
	0xf6,0xec,0xed,0xd4,0x19,0xdb,0x06,0xc1	},

			// app_b3
{	0xcd,0xc7,0x6e,0x5c,0x99,0x14,0xfb,0x92,
	0x81,0xa1,0xc7,0xe2,0x84,0xd7,0x3e,0x67,
	0xf1,0x80,0x9a,0x48,0xa4,0x97,0x20,0x0e,
	0x04,0x6d,0x39,0xcc,0xc7,0x11,0x2c,0xd0	}
};

const static unsigned int sha224_input_sizes[][2] = {{3,3}, {56, 56}, {64, 1000000}};

const static unsigned char *sha224_input[] = 
{
	(const unsigned char *) "abc", // app_b1
	(const unsigned char *) "abcdbcde""cdefdefg""efghfghi""ghijhijk"
		"ijkljklm""klmnlmno""mnopnopq", // app_b2
	(const unsigned char *) "aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa" // app_b3
};

const static unsigned char sha224_output[][SHA224_DIGEST_LENGTH] = {
			// addenum_1
{	0x23,0x09,0x7d,0x22,0x34,0x05,0xd8,0x22,
	0x86,0x42,0xa4,0x77,0xbd,0xa2,0x55,0xb3,
	0x2a,0xad,0xbc,0xe4,0xbd,0xa0,0xb3,0xf7,
	0xe3,0x6c,0x9d,0xa7 },

			// addenum_2
{	0x75,0x38,0x8b,0x16,0x51,0x27,0x76,0xcc,
	0x5d,0xba,0x5d,0xa1,0xfd,0x89,0x01,0x50,
	0xb0,0xc6,0x45,0x5c,0xb4,0xf5,0x8b,0x19,
	0x52,0x52,0x25,0x25 },

			// addenum_3
{	0x20,0x79,0x46,0x55,0x98,0x0c,0x91,0xd8,
	0xbb,0xb4,0xc1,0xea,0x97,0x61,0x8a,0x4b,
	0xf0,0x3f,0x42,0x58,0x19,0x48,0xb2,0xee,
	0x4e,0xe7,0xad,0x67 }
};



const static unsigned int sha512_input_sizes[][2] = {{3,3}, {112, 112}, {288, 1000000}};
const static unsigned char *sha512_input[] = 
{
	(const unsigned char *) "abc", // app_c1
	(const unsigned char *) "abcdefgh""bcdefghi""cdefghij""defghijk"
		"efghijkl""fghijklm""ghijklmn""hijklmno"
		"ijklmnop""jklmnopq""klmnopqr""lmnopqrs"
		"mnopqrst""nopqrstu", // app_c2
	(const unsigned char *) "aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa" // app_c3
};

const static unsigned char sha512_output[][SHA512_DIGEST_LENGTH] = {
		// app_c1
{	0xdd,0xaf,0x35,0xa1,0x93,0x61,0x7a,0xba,
	0xcc,0x41,0x73,0x49,0xae,0x20,0x41,0x31,
	0x12,0xe6,0xfa,0x4e,0x89,0xa9,0x7e,0xa2,
	0x0a,0x9e,0xee,0xe6,0x4b,0x55,0xd3,0x9a,
	0x21,0x92,0x99,0x2a,0x27,0x4f,0xc1,0xa8,
	0x36,0xba,0x3c,0x23,0xa3,0xfe,0xeb,0xbd,
	0x45,0x4d,0x44,0x23,0x64,0x3c,0xe8,0x0e,
	0x2a,0x9a,0xc9,0x4f,0xa5,0x4c,0xa4,0x9f },
		// app_c2
{	0x8e,0x95,0x9b,0x75,0xda,0xe3,0x13,0xda,
	0x8c,0xf4,0xf7,0x28,0x14,0xfc,0x14,0x3f,
	0x8f,0x77,0x79,0xc6,0xeb,0x9f,0x7f,0xa1,
	0x72,0x99,0xae,0xad,0xb6,0x88,0x90,0x18,
	0x50,0x1d,0x28,0x9e,0x49,0x00,0xf7,0xe4,
	0x33,0x1b,0x99,0xde,0xc4,0xb5,0x43,0x3a,
	0xc7,0xd3,0x29,0xee,0xb6,0xdd,0x26,0x54,
	0x5e,0x96,0xe5,0x5b,0x87,0x4b,0xe9,0x09 },

		// app_c3
{	0xe7,0x18,0x48,0x3d,0x0c,0xe7,0x69,0x64,
	0x4e,0x2e,0x42,0xc7,0xbc,0x15,0xb4,0x63,
	0x8e,0x1f,0x98,0xb1,0x3b,0x20,0x44,0x28,
	0x56,0x32,0xa8,0x03,0xaf,0xa9,0x73,0xeb,
	0xde,0x0f,0xf2,0x44,0x87,0x7e,0xa6,0x0a,
	0x4c,0xb0,0x43,0x2c,0xe5,0x77,0xc3,0x1b,
	0xeb,0x00,0x9c,0x5c,0x2c,0x49,0xaa,0x2e,
	0x4e,0xad,0xb2,0x17,0xad,0x8c,0xc0,0x9b }
};

const static unsigned int sha384_input_sizes[][2] = {{3,3}, {112, 112}, {64, 1000000}};

const static unsigned char *sha384_input[] = 
{
	(const unsigned char *) "abc", // app_d1
	(const unsigned char *) "abcdefgh""bcdefghi""cdefghij""defghijk"
		"efghijkl""fghijklm""ghijklmn""hijklmno"
		"ijklmnop""jklmnopq""klmnopqr""lmnopqrs"
		"mnopqrst""nopqrstu", // app_d2
	(const unsigned char *) "aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa"
				"aaaaaaaa""aaaaaaaa""aaaaaaaa""aaaaaaaa", // app_d3
};

const static unsigned char sha384_output[][SHA384_DIGEST_LENGTH] = {
		// app_d1 
{	0xcb,0x00,0x75,0x3f,0x45,0xa3,0x5e,0x8b,
	0xb5,0xa0,0x3d,0x69,0x9a,0xc6,0x50,0x07,
	0x27,0x2c,0x32,0xab,0x0e,0xde,0xd1,0x63,
	0x1a,0x8b,0x60,0x5a,0x43,0xff,0x5b,0xed,
	0x80,0x86,0x07,0x2b,0xa1,0xe7,0xcc,0x23,
	0x58,0xba,0xec,0xa1,0x34,0xc8,0x25,0xa7 },

		// app_d2
{	0x09,0x33,0x0c,0x33,0xf7,0x11,0x47,0xe8,
	0x3d,0x19,0x2f,0xc7,0x82,0xcd,0x1b,0x47,
	0x53,0x11,0x1b,0x17,0x3b,0x3b,0x05,0xd2,
	0x2f,0xa0,0x80,0x86,0xe3,0xb0,0xf7,0x12,
	0xfc,0xc7,0xc7,0x1a,0x55,0x7e,0x2d,0xb9,
	0x66,0xc3,0xe9,0xfa,0x91,0x74,0x60,0x39 },

		// app_d3
{	0x9d,0x0e,0x18,0x09,0x71,0x64,0x74,0xcb,
	0x08,0x6e,0x83,0x4e,0x31,0x0a,0x4a,0x1c,
	0xed,0x14,0x9e,0x9c,0x00,0xf2,0x48,0x52,
	0x79,0x72,0xce,0xc5,0x70,0x4c,0x2a,0x5b,
	0x07,0xb8,0xb3,0xdc,0x38,0xec,0xc4,0xeb,
	0xae,0x97,0xdd,0xd8,0x7f,0x3d,0x89,0x85 }

};

int TestDigest(EVP_MD_CB func, 
			const unsigned char *plain, unsigned int plain_len,  unsigned int plain_repeat_until,
			const unsigned char *digest, unsigned int digest_len)
{
	EVP_MD_CTX ctx;
	const EVP_MD *digester;
	unsigned char output_data[512]; // ARRAY OK 2009-05-25 yngve 
	unsigned int count=0;
	unsigned int data_count;

	EVP_MD_CTX_init(&ctx);

	digester= func();
	if(digester == NULL)
	  return -2;

	if(sizeof(output_data) < digest_len)
		return -3;

	if(sizeof(output_data) <= (size_t) EVP_MD_size(digester))
		return -4;

	EVP_DigestInit(&ctx, digester);
	OPERA_cleanse(output_data, sizeof(output_data));

	
	for(data_count = 0; data_count< plain_repeat_until;data_count += plain_len)
	{
		EVP_DigestUpdate(&ctx, plain, (data_count + plain_len < plain_repeat_until ? plain_len: plain_repeat_until- data_count));
	}
	EVP_DigestFinal(&ctx, output_data, &count);

	EVP_MD_CTX_cleanup(&ctx);

	return (count == digest_len ? op_memcmp(output_data, digest, count) : -1);
}


}

table testlist(const char *, int ,	EVP_MD_CB,
			const unsigned char *, const unsigned int *, const unsigned int *,
			const unsigned char *, unsigned int) {
	{"SHA1",	0,	EVP_sha1,	sha1_input,		&sha1_input_sizes[0],	NULL,			sha1_output,	sizeof(sha1_output)},
	{"MD5",		0,	EVP_md5,	md5_input[0],	&md5_input_sizes[0],	NULL,			md5_output[0],	sizeof(md5_output[0])},
	{"MD5",		1,	EVP_md5,	md5_input[1],	&md5_input_sizes[1],	NULL,			md5_output[1],	sizeof(md5_output[0])},
	{"MD5",		2,	EVP_md5,	md5_input[2],	&md5_input_sizes[2],	NULL,			md5_output[2],	sizeof(md5_output[0])},
	{"MD5",		3,	EVP_md5,	md5_input[3],	&md5_input_sizes[3],	NULL,			md5_output[3],	sizeof(md5_output[0])},
	{"MD5",		4,	EVP_md5,	md5_input[4],	&md5_input_sizes[4],	NULL,			md5_output[4],	sizeof(md5_output[0])},
	{"MD5",		5,	EVP_md5,	md5_input[5],	&md5_input_sizes[5],	NULL,			md5_output[5],	sizeof(md5_output[0])},
	{"MD5",		6,	EVP_md5,	md5_input[6],	&md5_input_sizes[6],	NULL,			md5_output[6],	sizeof(md5_output[0])},
	{"SHA256",	0,	EVP_sha256,	sha256_input[0],	&sha256_input_sizes[0][0],	&sha256_input_sizes[0][1],	sha256_output[0],	sizeof(sha256_output[0])},
	{"SHA256",	1,	EVP_sha256,	sha256_input[1],	&sha256_input_sizes[1][0],	&sha256_input_sizes[1][1],	sha256_output[1],	sizeof(sha256_output[1])},
	{"SHA256",	2,	EVP_sha256,	sha256_input[2],	&sha256_input_sizes[2][0],	&sha256_input_sizes[2][1],	sha256_output[2],	sizeof(sha256_output[2])},
	{"SHA224",	0,	EVP_sha224,	sha224_input[0],	&sha224_input_sizes[0][0],	&sha224_input_sizes[0][1],	sha224_output[0],	sizeof(sha224_output[0])},
	{"SHA224",	1,	EVP_sha224,	sha224_input[1],	&sha224_input_sizes[1][0],	&sha224_input_sizes[1][1],	sha224_output[1],	sizeof(sha224_output[1])},
	{"SHA224",	2,	EVP_sha224,	sha224_input[2],	&sha224_input_sizes[2][0],	&sha224_input_sizes[2][1],	sha224_output[2],	sizeof(sha224_output[2])},
	{"SHA512",	0,	EVP_sha512,	sha512_input[0],	&sha512_input_sizes[0][0],	&sha512_input_sizes[0][1],	sha512_output[0],	sizeof(sha512_output[0])},
	{"SHA512",	1,	EVP_sha512,	sha512_input[1],	&sha512_input_sizes[1][0],	&sha512_input_sizes[1][1],	sha512_output[1],	sizeof(sha512_output[1])},
	{"SHA512",	2,	EVP_sha512,	sha512_input[2],	&sha512_input_sizes[2][0],	&sha512_input_sizes[2][1],	sha512_output[2],	sizeof(sha512_output[2])},
	{"SHA384",	0,	EVP_sha384,	sha384_input[0],	&sha384_input_sizes[0][0],	&sha384_input_sizes[0][1],	sha384_output[0],	sizeof(sha384_output[0])},
	{"SHA384",	1,	EVP_sha384,	sha384_input[1],	&sha384_input_sizes[1][0],	&sha384_input_sizes[1][1],	sha384_output[1],	sizeof(sha384_output[1])},
	{"SHA384",	2,	EVP_sha384,	sha384_input[2],	&sha384_input_sizes[2][0],	&sha384_input_sizes[2][1],	sha384_output[2],	sizeof(sha384_output[2])},
};

test("Test Digest")
{
	iterate (name, test_num, func,plain, plain_len, plain_repeat_until, digest, digest_len) from testlist
	{
		output("\ntesting %s set %d ", name, test_num); 
		verify(plain_len != NULL);
		verify(TestDigest(func, plain, *plain_len, (plain_repeat_until ? *plain_repeat_until : *plain_len) , digest, digest_len) == 0);
	}
}

