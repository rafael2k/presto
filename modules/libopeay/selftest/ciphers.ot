group "libopeay.ciphers";
require _SSL_SUPPORT_;

language c++;

include "modules/libopeay/openssl/cryptlib.h";
include "modules/libopeay/openssl/evp.h";
include "modules/libopeay/selftest/ciphers.h";

global {
/* Test vectors from openssl*/

/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 * 
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 * 
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from 
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 * 
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 * 
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */


// RC4 tests

unsigned char rc4_keys[6][16]={
	{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},
	{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45},
	{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},
	{0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45}
	};

static unsigned char rc4_data_len[6]={8,8,8,20, 28, 10};
static unsigned char rc4_data[6][28]={
	{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0x12, 0x34, 0x56, 0x78},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	};

static unsigned char rc4_output[6][30]={
	{0x75, 0xb7, 0x87, 0x80, 0x99, 0xe0, 0xc5, 0x96},
	{0x74, 0x94, 0xc2, 0xe7, 0x10, 0x4b, 0x08, 0x79},
	{0xde, 0x18, 0x89, 0x41, 0xa3, 0x37, 0x5d, 0x3a},
	{0xd6, 0xa1, 0x41, 0xa7, 0xec, 0x3c, 0x38, 0xdf, 0xbd, 0x61, 0x5a, 0x11, 0x62, 0xe1, 0xc7, 0xba, 0x36, 0xb6, 0x78, 0x58},
	{0x66, 0xa0, 0x94, 0x9f, 0x8a, 0xf7, 0xd6, 0x89, 0x1f, 0x7f, 0x83, 0x2b, 0xa8, 0x33, 0xc0, 0x0c, 0x89, 0x2e, 0xbe, 0x30, 0x14, 0x3c, 0xe2, 0x87, 0x40, 0x01, 0x1e, 0xcf},
	{0xd6, 0xa1, 0x41, 0xa7, 0xec, 0x3c, 0x38, 0xdf, 0xbd, 0x61}
	};

/*
// RC2 tests
static const unsigned char RC2key[4][16]={
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	 0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F},
	};

static const unsigned char rc2_iv  [8]={0,0,0,0,0,0,0,0};

static const unsigned char rc2_data_len[4]={8,8,8,8};
static const unsigned char RC2plain[4][8]={
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};

static const unsigned char RC2cipher[4][8]={
	{0x1C,0x19,0x8A,0x83,0x8D,0xF0,0x28,0xB7},
	{0x21,0x82,0x9C,0x78,0xA9,0xF9,0xC0,0x74},
	{0x13,0xDB,0x35,0x17,0xD3,0x21,0x86,0x9E},
	{0x50,0xDC,0x01,0x62,0xBD,0x75,0x7F,0x31},
	};
*/

// DES test

static const unsigned char cbc_key []={	0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
static const unsigned char cbc3_key[]={	0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,
										0xf1,0xe0,0xd3,0xc2,0xb5,0xa4,0x97,0x86, 
										0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};

static const unsigned char cbc_iv  [8]={0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};

static const unsigned char cbc_data[]={
	0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x20,
	0x4E,0x6F,0x77,0x20,0x69,0x73,0x20,0x74,
	0x68,0x65,0x20,0x74,0x69,0x6D,0x65,0x20,
	0x66,0x6F,0x72,0x20,0x00,0x31,0x00,0x00
};

static const unsigned char cbc_ok[32]={
	0xcc,0xd1,0x73,0xff,0xab,0x20,0x39,0xf4,
	0xac,0xd8,0xae,0xfd,0xdf,0xd8,0xa1,0xeb,
	0x46,0x8e,0x91,0x15,0x78,0x88,0xba,0x68,
	0x1d,0x26,0x93,0x97,0xf7,0xfe,0x62,0xb4};

static const unsigned char cbc3_ok[32]={
	0x3F,0xE3,0x01,0xC9,0x62,0xAC,0x01,0xD0,
	0x22,0x13,0x76,0x3C,0x1C,0xBD,0x4C,0xDC,
	0x79,0x96,0x57,0xC0,0x64,0xEC,0xF5,0xD4,
	0x1C,0x67,0x38,0x12,0xCF,0xDE,0x96,0x75};

static const unsigned char des_cbc_size[] = {29, 32, 32};

// 3DES test


static const unsigned char des_ede_cbc3_data_len[1] = {32};

static const unsigned char des_ede_cbc3_key[24] = {
	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 
	0xf1, 0xe0, 0xd3, 0xc2, 0xb5, 0xa4, 0x97, 0x86,
	0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10
};

static const unsigned char des_ede_cbc3_iv[8] = {
	0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10
};

static const unsigned char des_ede_cbc3_input[32] = {
	0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x20,
	0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74,
	0x68, 0x65, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20,
	0x66, 0x6F, 0x72, 0x20, 0x00, 0x00, 0x00, 0x00
};

static const unsigned char des_ede_cbc3_output[32] = {
    0x3F, 0xE3, 0x01, 0xC9, 0x62, 0xAC, 0x01, 0xD0,
	0x22, 0x13, 0x76, 0x3C, 0x1C, 0xBD, 0x4C, 0xDC,
	0x79, 0x96, 0x57, 0xC0, 0x64, 0xEC, 0xF5, 0xD4,
	0x1C, 0x67, 0x38, 0x12, 0xCF, 0xDE, 0x96, 0x75
};

// AES test

static const unsigned char aes_data_len[1] = {16};

// AES-128-CBC


static const unsigned char aes_128_cbc_key[5][16] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C},
	{0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C},
	{0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C},
	{0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C},
};

static const unsigned char aes_128_cbc_iv[5][16] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F},
	{0x76, 0x49, 0xAB, 0xAC, 0x81, 0x19, 0xB2, 0x46, 0xCE, 0xE9, 0x8E, 0x9B, 0x12, 0xE9, 0x19, 0x7D},
	{0x50, 0x86, 0xCB, 0x9B, 0x50, 0x72, 0x19, 0xEE, 0x95, 0xDB, 0x11, 0x3A, 0x91, 0x76, 0x78, 0xB2},
	{0x73, 0xBE, 0xD6, 0xB8, 0xE3, 0xC1, 0x74, 0x3B, 0x71, 0x16, 0xE6, 0x9E, 0x22, 0x22, 0x95, 0x16},
};

static const unsigned char aes_128_cbc_input[5][16] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A},
	{0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C, 0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51},
	{0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11, 0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF},
	{0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17, 0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10},
};

static const unsigned char aes_128_cbc_output[5][16] = {
	{0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84, 0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D},
	{0x76, 0x49, 0xAB, 0xAC, 0x81, 0x19, 0xB2, 0x46, 0xCE, 0xE9, 0x8E, 0x9B, 0x12, 0xE9, 0x19, 0x7D},
	{0x50, 0x86, 0xCB, 0x9B, 0x50, 0x72, 0x19, 0xEE, 0x95, 0xDB, 0x11, 0x3A, 0x91, 0x76, 0x78, 0xB2},
	{0x73, 0xBE, 0xD6, 0xB8, 0xE3, 0xC1, 0x74, 0x3B, 0x71, 0x16, 0xE6, 0x9E, 0x22, 0x22, 0x95, 0x16},
	{0x3F, 0xF1, 0xCA, 0xA1, 0x68, 0x1F, 0xAC, 0x09, 0x12, 0x0E, 0xCA, 0x30, 0x75, 0x86, 0xE1, 0xA7},
};



// AES-256-CBC


static const unsigned char aes_256_cbc_key[5][32] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4},
	{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4},
	{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4},
	{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4},
};

static const unsigned char aes_256_cbc_iv[5][16] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F},
	{0xF5, 0x8C, 0x4C, 0x04, 0xD6, 0xE5, 0xF1, 0xBA, 0x77, 0x9E, 0xAB, 0xFB, 0x5F, 0x7B, 0xFB, 0xD6},
	{0x9C, 0xFC, 0x4E, 0x96, 0x7E, 0xDB, 0x80, 0x8D, 0x67, 0x9F, 0x77, 0x7B, 0xC6, 0x70, 0x2C, 0x7D},
	{0x39, 0xF2, 0x33, 0x69, 0xA9, 0xD9, 0xBA, 0xCF, 0xA5, 0x30, 0xE2, 0x63, 0x04, 0x23, 0x14, 0x61},
};

static const unsigned char aes_256_cbc_input[5][16] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A},
	{0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C, 0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51},
	{0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11, 0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF},
	{0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17, 0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10},
};

static const unsigned char aes_256_cbc_output[5][16] = {
	{0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5, 0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0},
	{0xF5, 0x8C, 0x4C, 0x04, 0xD6, 0xE5, 0xF1, 0xBA, 0x77, 0x9E, 0xAB, 0xFB, 0x5F, 0x7B, 0xFB, 0xD6},
	{0x9C, 0xFC, 0x4E, 0x96, 0x7E, 0xDB, 0x80, 0x8D, 0x67, 0x9F, 0x77, 0x7B, 0xC6, 0x70, 0x2C, 0x7D},
	{0x39, 0xF2, 0x33, 0x69, 0xA9, 0xD9, 0xBA, 0xCF, 0xA5, 0x30, 0xE2, 0x63, 0x04, 0x23, 0x14, 0x61},
	{0xB2, 0xEB, 0x05, 0xE2, 0xC3, 0x9B, 0xE9, 0xFC, 0xDA, 0x6C, 0x19, 0x07, 0x8C, 0x6A, 0x9D, 0x1B},
};


int TestEncrypt(EVP_CIPHER_CB func, const unsigned char *key, const unsigned char *iv, 
			const unsigned char *plain, unsigned int plain_len, 
			const unsigned char *encrypted, unsigned int encrypted_len)
{
	EVP_CIPHER_CTX ctx;
	const EVP_CIPHER *cipher;
	unsigned char output_data[512]; // ARRAY OK 2009-05-25 yngve 
	int count=0, count1=0;

	EVP_CIPHER_CTX_init(&ctx);

	cipher = func();
	if(cipher == NULL)
	  return -2;

	if(sizeof(output_data) < encrypted_len)
		return -3;

	if(sizeof(output_data) <= (plain_len + ((cipher->flags & EVP_CIPH_MODE)!= EVP_CIPH_CFB_MODE ? cipher->block_size : 1)*2))
		return -4;

	EVP_CipherInit(&ctx, cipher, key, iv, 1);
	EVP_CIPHER_CTX_set_padding(&ctx, 0);
	OPERA_cleanse(output_data, sizeof(output_data));

	EVP_CipherUpdate(&ctx, output_data, &count, plain, plain_len);
	EVP_EncryptFinal_ex(&ctx, output_data + count, &count1);

	count += count1;

	EVP_CIPHER_CTX_cleanup(&ctx);

	if((unsigned int) count == encrypted_len)
	{
		if(op_memcmp(output_data, encrypted, count) == 0)
			return 0;
		else
			return -5;
	}
	return -1;
}

int TestDecrypt(EVP_CIPHER_CB func, const unsigned char *key, const unsigned char *iv, 
			const unsigned char *plain, unsigned int plain_len, 
			const unsigned char *encrypted, unsigned int encrypted_len)
{
	EVP_CIPHER_CTX ctx;
	const EVP_CIPHER *cipher;
	unsigned char output_data[512]; // ARRAY OK 2009-05-25 yngve 
	int count=0, count1=0;

	EVP_CIPHER_CTX_init(&ctx);

	cipher = func();
	if(cipher == NULL)
	  return -2;

	if(sizeof(output_data) < encrypted_len)
		return -3;

	if(sizeof(output_data) <= plain_len + ((cipher->flags & EVP_CIPH_MODE)!= EVP_CIPH_CFB_MODE ? cipher->block_size : 1)*2)
		return -4;

	EVP_CipherInit(&ctx, cipher, key, iv, 0);
	EVP_CIPHER_CTX_set_padding(&ctx, 0);
	OPERA_cleanse(output_data, sizeof(output_data));

	EVP_CipherUpdate(&ctx, output_data, &count, encrypted, encrypted_len);
	EVP_DecryptFinal_ex(&ctx, output_data + count, &count1);

	count += count1;

	EVP_CIPHER_CTX_cleanup(&ctx);

	if((cipher->flags & EVP_CIPH_MODE) != EVP_CIPH_CFB_MODE  && cipher->block_size != 1)
	{
		if(count % cipher->block_size != 0)
			return -6;
		if((unsigned int) count < plain_len)
			return -7;
		else if((unsigned int) count != plain_len && ((unsigned int) count) - plain_len >= (unsigned int)cipher->block_size)
			return -8;

		return (op_memcmp(output_data, plain, plain_len) == 0 ? 0 : -9);
	}

	if((unsigned int) count == plain_len)
	{
		if(op_memcmp(output_data, plain, count) == 0)
			return 0;
		else
			return -5;
	}
	return -1;
}


}

table testlist(const char *, int ,
			EVP_CIPHER_CB, const unsigned char *, const unsigned char *, 
			const unsigned char *, const unsigned char *, 
			const unsigned char *, const unsigned char *) {
	{"RC4",		0,	EVP_rc4,	rc4_keys[0],	NULL,	rc4_data[0],	&rc4_data_len[0],	rc4_output[0],	&rc4_data_len[0]},
	{"RC4",		1,	EVP_rc4,	rc4_keys[1],	NULL,	rc4_data[1],	&rc4_data_len[1],	rc4_output[1],	&rc4_data_len[1]},
	{"RC4",		2,	EVP_rc4,	rc4_keys[2],	NULL,	rc4_data[2],	&rc4_data_len[2],	rc4_output[2],	&rc4_data_len[2]},
	{"RC4",		3,	EVP_rc4,	rc4_keys[3],	NULL,	rc4_data[3],	&rc4_data_len[3],	rc4_output[3],	&rc4_data_len[3]},
	{"RC4",		4,	EVP_rc4,	rc4_keys[4],	NULL,	rc4_data[4],	&rc4_data_len[4],	rc4_output[4],	&rc4_data_len[4]},
	{"RC4",		5,	EVP_rc4,	rc4_keys[5],	NULL,	rc4_data[5],	&rc4_data_len[5],	rc4_output[5],	&rc4_data_len[5]},
	//{"DES",		0,	EVP_des_cbc,	cbc_key,	cbc_iv,	cbc_data,		&des_cbc_size[0],	cbc_ok,			&des_cbc_size[1]},
	//{"3DES",	0,	EVP_des_ede3_cbc, cbc3_key,	cbc_iv,	cbc_data,		&des_cbc_size[0],	cbc3_ok,		&des_cbc_size[2]},
	{"3DES",	1,	EVP_des_ede3_cbc, des_ede_cbc3_key,	  des_ede_cbc3_iv,   des_ede_cbc3_input,   &des_ede_cbc3_data_len[0],	des_ede_cbc3_output, &des_ede_cbc3_data_len[0]},
	//{"AES-128",	0,	EVP_aes_128_cbc,  aes_128_cbc_key[0], aes_128_cbc_iv[0], aes_128_cbc_input[0], &aes_data_len[0], aes_128_cbc_output[0], &aes_data_len[0]},
	{"AES-128",	1,	EVP_aes_128_cbc,  aes_128_cbc_key[1], aes_128_cbc_iv[1], aes_128_cbc_input[1], &aes_data_len[0], aes_128_cbc_output[1], &aes_data_len[0]},
	{"AES-128",	2,	EVP_aes_128_cbc,  aes_128_cbc_key[2], aes_128_cbc_iv[2], aes_128_cbc_input[2], &aes_data_len[0], aes_128_cbc_output[2], &aes_data_len[0]},
	{"AES-128",	3,	EVP_aes_128_cbc,  aes_128_cbc_key[3], aes_128_cbc_iv[3], aes_128_cbc_input[3], &aes_data_len[0], aes_128_cbc_output[3], &aes_data_len[0]},
	{"AES-128",	4,	EVP_aes_128_cbc,  aes_128_cbc_key[4], aes_128_cbc_iv[4], aes_128_cbc_input[4], &aes_data_len[0], aes_128_cbc_output[4], &aes_data_len[0]},
	//{"AES-256",	0,	EVP_aes_256_cbc,  aes_256_cbc_key[0], aes_256_cbc_iv[0], aes_256_cbc_input[0], &aes_data_len[0], aes_256_cbc_output[0], &aes_data_len[0]},
	{"AES-256",	1,	EVP_aes_256_cbc,  aes_256_cbc_key[1], aes_256_cbc_iv[1], aes_256_cbc_input[1], &aes_data_len[0], aes_256_cbc_output[1], &aes_data_len[0]},
	{"AES-256",	2,	EVP_aes_256_cbc,  aes_256_cbc_key[2], aes_256_cbc_iv[2], aes_256_cbc_input[2], &aes_data_len[0], aes_256_cbc_output[2], &aes_data_len[0]},
	{"AES-256",	3,	EVP_aes_256_cbc,  aes_256_cbc_key[3], aes_256_cbc_iv[3], aes_256_cbc_input[3], &aes_data_len[0], aes_256_cbc_output[3], &aes_data_len[0]},
	{"AES-256",	4,	EVP_aes_256_cbc,  aes_256_cbc_key[4], aes_256_cbc_iv[4], aes_256_cbc_input[4], &aes_data_len[0], aes_256_cbc_output[4], &aes_data_len[0]},
};

test("Test Symmetric Encryption")
{
	iterate (name, test_num, func,key, iv, plain, plain_len, encrypted, encrypted_len) from testlist
	{
		output("\ntesting %s set %d ", name, test_num); 
		verify(plain_len != NULL);
		verify(encrypted_len != NULL);
		verify(TestEncrypt(func,key, iv, plain, (unsigned int) (*plain_len), encrypted, (unsigned int) (*encrypted_len)) == 0);
	}
}

test("Test Symmetric Decryption")
{
	iterate (name, test_num, func,key, iv, plain, plain_len, encrypted, encrypted_len) from testlist
	{
		output("\ntesting %s set %d ", name, test_num); 
		verify(plain_len != NULL);
		verify(encrypted_len != NULL);
		verify(TestDecrypt(func,key, iv, plain, (unsigned int) (*plain_len), encrypted, (unsigned int) (*encrypted_len)) == 0);
	}
}



