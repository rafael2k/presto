# Emacs: please use -*- tab-width: 4 -*-.  Thank you.

# This file describes the available system settings in Opera.

SYSTEM_ARCHITECTURE_IA32					jl

	The target CPU architecture is Intel IA32 (AKA x86), either 32 or 64 bits.

	Defines  : ARCHITECTURE_IA32

SYSTEM_ARCHITECTURE_ARM						jl

	The target CPU architecture is ARM.

	Defines  : ARCHITECTURE_ARM

SYSTEM_ARCHITECTURE_MIPS					jl

	The target CPU architecture is MIPS.

	Defines  : ARCHITECTURE_MIPS

SYSTEM_ARCHITECTURE_SUPERH					jl

	The target CPU architecture is SuperH (SH-n).

	Defines  : ARCHITECTURE_SUPERH

SYSTEM_ARCHITECTURE_POWERPC					jl

	The target CPU architecture is PowerPC.

	Defines  : ARCHITECTURE_POWERPC

SYSTEM_BIG_ENDIAN							kilsmo

	Set this one to YES if you have a processor that has big endian byte order (680x0, PowerPC, etc).
	Some processors have little endian byte order (x86, etc).

	Defines  : OPERA_BIG_ENDIAN

SYSTEM_RISC_ALIGNMENT						peter

	Set to YES if you have a processor that requires data to be aligned in
	memory according to the data type to be accessed directly, for instance
	16-bit data aligned to an even address.

	If enabled, code that need to access data at possibly non-aligned
	addresses must be done by manually adding the byte values together. If
	disabled, code is allowed to access such data directly.

	May be set to NO on the following CPUs: x86, PowerPC.

	Must be set to YES on the following CPUs: Sparc, Alpha, ARM, HPPA.

	Defines : NEEDS_RISC_ALIGNMENT

SYSTEM_IEEE_8087							lth

	This system uses IEEE-8087 floating-point layout: the word containing
	the sign, exponent, and high bits of the mantissa are stored at a higher
	address than the word containing the low bits of the mantissa.

	Defines  : IEEE_8087

SYSTEM_IEEE_MC68K							lth

	This system uses IEEE-MC68k floating-point layout: the word containing
	the sign, exponent, and high bits of the mantissa are stored at a lower
	address than the word containing the low bits of the mantissa.

	Defines  : IEEE_MC68k

SYSTEM_IEEE_DENORMALS						lth

    Set this to YES if IEEE denormal numbers can be used on your
    platform.  We need to know this since other browsers use denormal
    numbers in some circumstances and it's nice to be compatible when
    possible.

    Platforms on which it is believed that the value must be NO:

       Symbian

    Defines    : IEEE_DENORMALS

SYSTEM_NAN_EQUALS_EVERYTHING				lth

	This system has a bug in which the IEEE NaN value (not-a-number) compares
	equal with everything, rather than unequal.

	This bizarreness is known to be a problem in Visual Studio 6.0 (where it
	is caused by a bug in the libraries), but is believed to be fixed in
	Visual Studio .NET.

	Defines  : NAN_EQUALS_EVERYTHING

SYSTEM_NAN_ARITHMETIC_OK				    lth

	This system can safely perform arithmetic on IEEE NaN (not-a-number)
	values.  If set to NO, then code that might process NaNs should be
	careful never to use them directly in arithmetic operations, as the
	system may crash.

	Note that if you find yourself setting this feature to YES then it is
	possible that you have chosen the wrong setting for SYSTEM_QUIET_NAN_IS_ZERO
	instead.

	Defines  : NAN_ARITHMETIC_OK

SYSTEM_QUIET_NAN_IS_ONE						lth

	Set to NO if your system represents quiet NaN values with a high bit
	of 0 in the mantissa, and to YES if quiet NaN values are represented
	with a high bit of 1 in the mantissa, and in both cases only the
	high bit of the mantissa is used to distinguish between NaN types.

    If your system represents quiet NaNs any other way (including, if it
	uses more bits to distinguish the two types), then small parts of
	Opera may have to be reengineered.

	Background: quiet NaNs are values on which arithmetic can be performed,
	resulting in new (quiet) NaN values.  Signalling NaNs are values which
	will cause a floating-point exception if used in arithmetic.  Different
	CPUs have chosen different representations for quiet and signalling
	NaNs, which means that code in Opera (chiefly the ECMAScript engine) that
	relies on generating and using quiet NaNs must know how they are represented.

	Since the setting is CPU specific, here is a table of some CPUs and
	their settings for this system feature:

		i386			YES
		PowerPC			YES
		ARM				YES
		Hitachi SH-4	YES
		SPARC			YES
		MIPS			NO
		POWER			YES
		Alpha			YES
		Itanium			YES
		PA-RISC			NO
		68000			YES
		i860			YES
		S/390			YES

    In principle, one should be able to figure out what the value is for a
	given platform by writing a program that executes 0.0/0.0, and then
	inspecting the resulting representation.

	References:
		http://www.math.utah.edu/~beebe/software/ieee/README.NaN
		ARM architecture reference manual
		SH-4 Programming manual
		http://www.research.ibm.com/journal/rd/435/abbott.html

	Defines  : QUIET_NAN_IS_ONE

SYSTEM_INT64								markus

	The system has a signed integer with 64 bit precision available.

	Defines		: HAVE_INT64
	Required by	: SYSTEM_INT64_LITERAL

SYSTEM_UINT64								jl

	The system has aa unsigned integer with 64 bit precision available.

	Defines		: HAVE_UINT64
	Required by	: SYSTEM_UINT64_LITERAL

SYSTEM_INT64_LITERAL						arjanl

	There is a way to define 64-bit integer literals. The macro OP_INT64
	will need to be implemented.

	Defines		: HAVE_INT64_LITERAL
	Depends on	: SYSTEM_INT64

SYSTEM_UINT64_LITERAL						arjanl

	There is a way to define unsigned 64-bit integer litarals. The macro
	OP_UINT64 will need to be implemented.

	Defines		: HAVE_UINT64_LITERAL
	Depends on	: SYSTEM_UINT64

SYSTEM_64BIT								markus

	Set to YES if the processor is a 64-bit processor. This is not the
	same as saying YES to SYSTEM_INT64 since that one only talks about
	the availability of a integer which can represent 64-bit numbers.
	If this is set to NO, a 32-bit architecture is assumed.

	Defines   : SIXTY_FOUR_BIT
	Undefines : THIRTY_TWO_BIT

SYSTEM_CONSTANT_DATA_IS_EXECUTABLE			ulfma

	Set to YES if the platform supports executing constant global data as
	machine code. If set to NO, memory for machine instructions will be
	allocated dynamically at runtime.

	Global constant data has been observed to be executable with recent (as of
	February 11, 2011) GCC versions on Linux on at least x86, x86_64, and ARM.
	The data winds up in the .text segment.

	VC does not put global constant data in the .text segment, though it might
	still be executable if DEP (Data Execution Prevention) is disabled. This
	can of course not be relied on.

	Status for other platforms is unknown. Feel free to fill in.

	Defines   : CONSTANT_DATA_IS_EXECUTABLE

SYSTEM_GUID									peter

	Set to YES if the system libraries have supports for generating
	globaly/universally unique identifiers (GUIDs/UUIDs) as per RFC 4112. If
	this is enabled and the corresponding features requiring it are enabled,
	a porting interface for generating them will be enabled and must be
	implemented. If this is set to NO, a Opera-local algorithm will be
	used.

	Defines  : HAVE_UUID_GENERATE

SYSTEM_LOCALECONV							markus

	The system has the following function available:

	struct lconv* localeconv();

	Defines  : HAVE_LOCALECONV

SYSTEM_LONGLONG								markus

	The compiler has the type 'long long'.

	Defines  : HAVE_LONGLONG

SYSTEM_RECT                                 markus

	The system has the struct RECT.

	Defines  : HAVE_RECT

SYSTEM_POINT                                markus

	The system has the struct POINT.

	Defines  : HAVE_POINT

SYSTEM_COLORREF                             markus

	The system has the type COLORREF.

	Defines  : HAVE_COLORREF

SYSTEM_SIZE                                 markus

	The system has the struct SIZE.

	Defines  : HAVE_SIZE

SYSTEM_MAKELONG                             markus

	The system has the macro MAKELONG.

	Defines  : HAVE_MAKELONG

SYSTEM_RGB                                  markus

	The system has the macro RGB.

	Defines  : HAVE_RGB

SYSTEM_ALLOCA								rune

	The system has the following function for allocating
	space in the stack frame:

	void* alloca(size_t size);

	Defines  : HAVE_ALLOCA

SYSTEM_NEWA_CHECKS_OVERFLOW				johanh

	The system/compiler generates code for checking whether the
	statement "new Foo[num];" will overflow because
	sizeof(Foo) * num > SIZE_MAX.

	According to CORE-34984, Visual Studio does include this check,
	whereas GCC does not.

	Defines  : HAVE_NEWA_OVERFLOW_CHECK

SYSTEM_LONGJMP_VOLATILE_LOCALS				markus

	Define as YES if the compiler does not guarantee that the values
	of local variables in the function of a setjmp() are preserved
	when a longjmp() to the location of that setjmp() is made.

	Core nightly builds for GCC will be made with this set to YES.

	Defines : OP_MEMORY_VAR = "volatile" / ""

SYSTEM_GLOBALS								lth

	The system has support for global variables. If not, all global
	variables must be allocated specially in a system-wide structure.

	Undefines  : _NO_GLOBALS_

SYSTEM_COMPLEX_GLOBALS					   rikard

	Most platforms will want to set this to YES. The only platform
	that currently needs this is BREW.

    Set to NO if your toolchain only supports having integral types in
    const global arrays (and not eg pointers). This could be for
    example because the code needs to be Read Only Position
    Independent (ROPI).

	An example of what will happen follows. We have a global const
	char* array g_miffo. It is defined as follows:

	CONST_ARRAY(g_miffo, char*)
	  CONST_ENTRY("foo"),
	  CONST_ENTRY("bar")
	CONST_END(g_miffo)

	With SYSTEM_COMPLEX_GLOBALS=YES, this will expand to:

	const char* const g_miffo[] = {
	  "foo",
	  "bar"
	};

	while it with SYSTEM_COMPLEX_GLOBALS=NO will expand to:

	static void init_g_miffo() { const char** local = g_miffo; int i=0;
	  local[i++] = "foo",
	  local[i++] = "bar"
	;}

	In addition, there is one more macro: CONST_ARRAY_INIT(name) that
	expands to nada in the YES case, but to a call to the
	aforementioned init function in the NO case. This can be used to
	run the init function. This should preferrably be done when the
	module is initialized.

	Defines : HAS_COMPLEX_GLOBALS

SYSTEM_DLL_NAME_LOOKUP						markus

	Sets if the platform has support for symbol lookup in DLL's by
	name. If not enabled, symbols will be looked up by id's instead.

	Defines : DLL_NAME_LOOKUP_SUPPORT

SYSTEM_SETJMP								kilsmo

	Set this one to NO, if your platform does not support
	setjmp/longjmp. Should be YES on all known platforms except
	Symbian. When set to YES the macros op_setjmp and op_longjmp
	must be available.

	Defines     : SETJMP_SUPPORTED
	Required by : SYSTEM_LEAVE_WITH_JMP

SYSTEM_LEAVE_WITH_JMP						arjanl

	If set, use op_setjmp / op_longjmp to implement the TRAP/LEAVE exception
	handling mechanism. If not set, the system's compiler has to support C++
	exceptions, as these will be used to implement TRAP/LEAVE.

	Defines    : HAVE_LEAVE_WITH_JMP
	Undefines  : USE_CXX_EXCEPTIONS
	Depends on : SYSTEM_SETJMP

SYSTEM_DRIVES								yngve

	Set to YES if the platform uses drive letter in
	file names. Drive names consist of a letter followed
	by a colon. For example, "C:".

	Defines    : SYS_CAP_FILESYSTEM_HAS_DRIVES
	Depends on : nothing
	Required by: SYSTEM_MULTIPLE_DRIVES

SYSTEM_MULTIPLE_DRIVES						yngve

	Set to YES if the platform has multiple drives.
	See SYSTEM_DRIVES.

	Defines    : SYS_CAP_FILESYSTEM_HAS_MULTIPLE_DRIVES
	Depends on : SYSTEM_DRIVES
	Required by: nothing

SYSTEM_NETWORK_BACKSLASH_PATH				yngve

	Set to YES if the platform can access files
	using the syntax \\Host\path\to\file.txt

	This is normally used for accessing local network
	files on Windows systems.

	Defines : SYS_CAP_NETWORK_FILESYSTEM_BACKSLASH_PATH

SYSTEM_BLOCK_CON_FILE						yngve

	Set to YES if the file "C:\CON" is not allowed to
	be opened.

	On Windows systems this file is illegal and
	may cause crashes on Windows 95 and later, but not NT.

	Defines : SYS_CAP_BLOCK_CON_FILE

SYSTEM_OWN_OP_STATUS_VALUES					markus

	Set to YES to define own values for the OP_STATUS values OK,
	ERR, ERR_NO_MEMORY etc. The list of defines to set and the rules for
	how the values can be set can be found in hardcore/base/opstatus.h.

	When set to NO, default values will be used.

	Defines : OVERRIDE_OP_STATUS_VALUES

SYSTEM_YIELD								markus

	Set to YES if the system has a yield function which can be called
	to give the system a chance of running for a while while Opera is
	running. The macro op_yield will have to be implemented. If this
	is set to NO, the op_yield macro will have no effect.

	Defines   : HAVE_OP_YIELD

SYSTEM_GETPHYSMEM                           mstensho

    The system is capable of getting total available physical memory.

    Defines   : SYS_GETPHYSMEM

SYSTEM_DTOA                                 peter

	The system has the following function:

	char* dtoa(double d, char* buffer, int precision=-1);

	Note there is no op_dtoa macro.

	Group    : system primitive
	Defines  : HAVE_DTOA

SYSTEM_ETOA									peter

	The system has the following function:

	char* etoa(double d, char* buffer, int precision=-1);

	Note there is no op_dtoa macro.

	Group    : system primitive
	Defines  : HAVE_ETOA

SYSTEM_FCVT									peter

	The system has the following function:

	char* fcvt(double number, int ndigits, int *decpt, int *sign);

	Note there is no op_fcvt macro.

	Group    : system primitive
	Defines  : HAVE_FCVT

SYSTEM_ECVT									peter

	The system has the following function:

	char* ecvt(double number, int ndigits, int *decpt, int *sign);

	Note there is no op_ecvt macro.

	Group    : system primitive
	Defines  : HAVE_ECVT

SYSTEM_GCVT									peter

	The system has the following function:

	Note there is no op_gcvt macro.

	char* gcvt(double number, size_t ndigit, char *buf);

	Group    : system primitive
	Defines  : HAVE_GCVT

SYSTEM_STRTOD                                  peter

    The system has the following function:

    double strtod(const char *nptr, char **endptr);

    If SYSTEM_STRTOD==NO then the macro op_strtod need not be defined.

    Note, the recommended setting for SYSTEM_STRTOD is NO, because
    most libraries have versions of strtod that are not sufficiently
    good for several parts of Opera (notably ECMAScript and SVG).  Set
    SYSTEM_STRTOD to YES only after due consideration, and only if
    you're able to verify that it passes the stdlib selftests.

    Group    : library
    Defines  : HAVE_STRTOD

SYSTEM_MEMCMP								peter

	The system has the following function:

	int memcmp(void char* s1, const void* s2, size_t nbytes);

	If SYSTEM_MEMCMP==NO then the macro op_memcmp need not be defined.

	Group    : library
	Defines  : HAVE_MEMCMP

SYSTEM_MEMCPY								peter

	The system has the following function:

	void* memcpy(void* s1, const void* s2, size_t nbytes);

	If SYSTEM_MEMCPY==NO then the macro op_memcpy need not be defined.

	Group    : library
	Defines  : HAVE_MEMCPY

SYSTEM_MEMMEM								peter

	The system has the following function:

	void* memmem(const void* s1, size_t s1bytes, const void* s2, size_t s2bytes);

	If SYSTEM_MEMMEM==NO then the macro op_memmem need not be defined.

	Group    : library
	Defines  : HAVE_MEMMEM

SYSTEM_MEMMOVE								peter

	The system has the following function:

	void* memmove(void* s1, const void* s2, size_t nbytes);

	If SYSTEM_MEMMOVE==NO then the macro op_memmove need not be defined.

	Group    : library
	Defines  : HAVE_MEMMOVE

SYSTEM_MEMSET								peter

	The system has the following function:

	void* memset(void* s1, int n, size_t nbytes);

	If SYSTEM_MEMSET==NO then the macro op_memset need not be defined.

	Group    : library
	Defines  : HAVE_MEMSET

SYSTEM_MEMCHR								peter

	The system has the following function:

	void* memchr(const void* s1, int c);

	If SYSTEM_MEMCHR==NO then the macro op_memchr need not be defined.

	Group    : library
	Defines  : HAVE_MEMCHR

SYSTEM_UNI_MEMCHR							johanh

	The system has the following function:

	uni_char* wmemchr(const uni_char* s, uni_char c, size_t n)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_MEMCHR==NO then the macro uni_memchr need not be defined.

	Group    : library
	Defines  : HAVE_UNI_MEMCHR

SYSTEM_ITOA									markus

	The system has the following function:

	char* itoa(int, char*, int);

	If SYSTEM_ITOA==NO then the macro op_itoa need not be defined.

	Group    : library
	Defines  : HAVE_ITOA

SYSTEM_UNI_ITOA								markus

	The system has the following function:

	uni_char* itow(int, uni_char*, int);

	If SYSTEM_UNI_ITOA==NO then the macro uni_itoa need not be defined.

	Group    : library
	Defines  : HAVE_UNI_ITOA

SYSTEM_LTOA									markus

	The system has the following function:

	char* ltoa(long, char*, int);

	If SYSTEM_LTOA==NO then the macro op_ltoa need not be defined.

	Group    : library
	Defines  : HAVE_LTOA

SYSTEM_UNI_LTOA								markus

	The system has the following function:

	uni_char* ltow(long, uni_char*, int);

	If SYSTEM_UNI_LTOA==NO then the macro uni_ltoa need not be defined.

	Group    : library
	Defines  : HAVE_UNI_LTOA

SYSTEM_STRLEN								peter

	The system has the following function:

	size_t strlen(const char* s)

	If SYSTEM_STRLEN==NO then the macro op_strlen need not be defined.

	Group    : library
	Defines  : HAVE_STRLEN

SYSTEM_UNI_STRLEN							peter

	The system has the following function:

	size_t wcslen(const uni_char* s)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRLEN==NO then the macro uni_strlen need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRLEN

SYSTEM_STRCPY								peter

	The system has the following function:

	char* strcpy(char *s1, const char* s2)

	If SYSTEM_STRCPY==NO then the macro op_strcpy need not be defined.

	Group    : library
	Defines  : HAVE_STRCPY

SYSTEM_UNI_STRCPY							peter

	The system has the following function:

	uni_char* wcscpy(uni_char *s1, const uni_char* s2)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRCPY==NO then the macro uni_strcpy need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRCPY

SYSTEM_STRNCPY								peter

	The system has the following function:

	char* strncpy(char *s1, const char* s2, size_t n)

	If SYSTEM_STRNCPY==NO then the macro op_strncpy need not be defined.

	Group    : library
	Defines  : HAVE_STRNCPY

SYSTEM_UNI_STRNCPY							peter

	The system has the following function:

	uni_char* wcsncpy(uni_char *s1, const uni_char* s2, size_t n)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRNCPY==NO then the macro uni_strncpy need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRNCPY

SYSTEM_STRLCPY								peter

	The system has the following function:

	size_t strlcpy(char *s1, const char* s2, size_t n)

	If SYSTEM_STRLCPY==NO then the macro op_strlcpy need not be defined.

	Group    : library
	Defines  : HAVE_STRLCPY

SYSTEM_UNI_STRLCPY							peter

	The system has the following function:

	size_t wcslcpy(uni_char *s1, const uni_char* s2, size_t n)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRLCPY==NO then the macro uni_strlcpy need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRLCPY

SYSTEM_STRCAT								peter

	The system has the following function:

	char* strcat(char* s1, const char* s2)

	If SYSTEM_STRCAT==NO then the macro op_strcat need not be defined.

	Group    : library
	Defines  : HAVE_STRCAT

SYSTEM_UNI_STRCAT							peter

	The system has the following function:

	uni_char* wcscat(uni_char* s1, const uni_char* s2)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRCAT==NO then the macro uni_strcat need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRCAT

SYSTEM_STRNCAT								peter

	The system has the following function:

	char* strncat(char* s1, const char* s2, size_t n)

	If SYSTEM_STRNCAT==NO then the macro op_strncat need not be defined.

	Group    : library
	Defines  : HAVE_STRNCAT

SYSTEM_UNI_STRNCAT							peter

	The system has the following function:

	uni_char* wcsncat(uni_char* s1, const uni_char* s2, size_t n)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRNCAT==NO then the macro uni_strncat need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRNCAT

SYSTEM_STRLCAT								peter

	The system has the following function:

	size_t strlcat(char* s1, const char* s2, size_t n)

	If SYSTEM_STRLCAT==NO then the macro op_strlcat need not be defined.

	Group    : library
	Defines  : HAVE_STRLCAT

SYSTEM_UNI_STRLCAT							peter

	The system has the following function:

	size_t wcslcat(uni_char* s1, const uni_char* s2, size_t n)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRLCAT==NO then the macro uni_strlcat need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRLCAT

SYSTEM_STRCMP								peter

	The system has the following function:

	int strcmp(const char *s1, const char *s2)

	If SYSTEM_STRCMP==NO then the macro op_strcmp need not be defined.

	Group    : library
	Defines  : HAVE_STRCMP

SYSTEM_UNI_STRCMP							peter

	The system has the following function:

	int wcscmp(const uni_char *s1, const uni_char *s2)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRCMP==NO then the macro real_uni_strcmp need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRCMP

SYSTEM_STRNCMP								peter

	The system has the following function:

	int strncmp(const char *s1, const char *s2, size_t n)

	If SYSTEM_STRNCMP==NO then the macro op_strncmp need not be defined.

	Group    : library
	Defines  : HAVE_STRNCMP

SYSTEM_UNI_STRNCMP							peter

	The system has the following function:

	int wcsncmp(const uni_char *s1, const uni_char *s2, size_t n)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRNCMP==NO then the macro real_uni_strncmp need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRNCMP

SYSTEM_STRICMP								peter

	The system has the following functions available:

	int stricmp(const char *s1, const char *s2);

	If SYSTEM_STRICMP==NO then the macro op_stricmp need not be defined.

	Group    : library
	Defines  : HAVE_STRICMP

SYSTEM_UNI_STRICMP							peter

	The system has the following functions available:

	int wcsicmp(const uni_char *s1, const uni_char *s2);
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRICMP==NO then the macro real_uni_stricmp need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRICMP

SYSTEM_STRNICMP								peter

	The system has the following function:

	int strnicmp(const char* s1, const char* s2, size_t n);

	If SYSTEM_STRNICMP==NO then the macro op_strnicmp need not be defined.

	Group    : library
	Defines  : HAVE_STRNICMP

SYSTEM_UNI_STRNICMP							peter

	The system has the following function:

	int wcsnicmp(const uni_char* s1, const uni_char* s2, size_t n);
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRNICMP==NO then the macro real_uni_strnicmp need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRNICMP

SYSTEM_STRCHR								peter

	The system has the following function:

	char* strchr(const char* s, int c)

	If SYSTEM_STRCHR==NO then the macro op_strchr need not be defined.

	Group    : library
	Defines  : HAVE_STRCHR

SYSTEM_UNI_STRCHR							peter

	The system has the following function:

	uni_char* wcschr(const uni_char* s, uni_char c)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRCHR==NO then the macro uni_strchr need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRCHR

SYSTEM_STRRCHR								peter

	The system has the following function:

	char* strrchr(const char* s, int c)

	If SYSTEM_STRRCHR==NO then the macro op_strrchr need not be defined.

	Group    : library
	Defines  : HAVE_STRRCHR

SYSTEM_UNI_STRRCHR							peter

	The system has the following function:

	uni_char* wcsrchr(const uni_char* s, uni_char c)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRRCHR==NO then the macro uni_strrchr need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRRCHR

SYSTEM_STRDUP								mortenro

	If SYSTEM_STRDUP==YES, the system has the following function or
	equivalent available:

	char* strdup(const char* s)

	And it can be accessed through a macro as op_lowlevel_strdup.

	Note that this function for traditional reasons uses malloc() or
	op_malloc() to allocate its memory, not 'operator new'.  Thus you
	should free it with op_free(), not with 'operator delete'.

	If SYSTEM_STRDUP==NO then the macro op_lowlevel_strdup need not be
	defined.

	Group    : library
	Defines  : HAVE_STRDUP

SYSTEM_UNI_STRDUP							mortenro

	If SYSTEM_UNI_STRDUP==YES, the system has the following function
	or equivalent available:

	uni_char* wcsdup(const uni_char* s)

	And it can be accessed through a macro as uni_lowlevel_strdup.
	The uni_char* represents a UTF-16 string.

    Note that this function for traditional reasons uses malloc() or
	op_malloc() to allocate its memory, not 'operator new'.  Thus you
	should free it with op_free(), not with 'operator delete'.

	If SYSTEM_UNI_STRDUP==NO then the macro uni_lowlevel_strdup need
	not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRDUP

SYSTEM_STRSTR								peter

	The system has the following function:

	char* strstr(const char *s1, const char *s2)

	If SYSTEM_STRSTR==NO then the macro op_strstr need not be defined.

	Group    : library
	Defines  : HAVE_STRSTR

SYSTEM_UNI_STRSTR							peter

	The system has the following function:

	uni_char* wcsstr(const uni_char *s1, const uni_char *s2)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRSTR==NO then the macro real_uni_strstr need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRSTR

SYSTEM_UNI_STRISTR							peter

	The system has the following function:

	uni_char* wcsistr(const uni_char *s1, const uni_char *s2)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRISTR==NO then the macro real_uni_stristr need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRISTR

SYSTEM_STRSPN								peter

	The system has the following function:

	size_t strspn(const char *s1, const char *s2)

	If SYSTEM_STRSPN==NO then the macro op_strspn need not be defined.

	Group    : library
	Defines  : HAVE_STRSPN

SYSTEM_UNI_STRSPN							peter

	The system has the following function:

	size_t wcsspn(const uni_char *s1, const uni_char *s2)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRSPN==NO then the macro uni_strspn need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRSPN

SYSTEM_STRCSPN								peter

	The system has the following function:

	size_t strcspn(const char *s1, const char *s2)

	If SYSTEM_STRCSPN==NO then the macro op_strcspn need not be defined.

	Group    : library
	Defines  : HAVE_STRCSPN

SYSTEM_UNI_STRCSPN							peter

	The system has the following function:

	size_t wcscspn(const uni_char *s1, const uni_char *s2)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRCSPN==NO then the macro uni_strcspn need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRCSPN

SYSTEM_STRPBRK								peter

	The system has the following function:

	char* strpbrk(const char *s1, const char *s2)

	If SYSTEM_STRPBRK==NO then the macro op_strpbrk need not be defined.

	Group    : library
	Defines  : HAVE_STRPBRK

SYSTEM_UNI_STRPBRK							peter

	The system has the following function:

	uni_char* wcspbrk(const uni_char *s1, const uni_char *s2)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRPBRK==NO then the macro uni_strpbrk need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRPBRK

SYSTEM_STRCASE								markus

	The system has the following functions available:

	void strupr(char* buffer)
	void strlwr(char* buffer)

	If SYSTEM_STRCASE==NO then the macros op_strupr and op_strlwr need
	not be defined.

	Group    : library
	Defines  : HAVE_STRCASE

SYSTEM_STRREV								peter

	The system has the following function:

	void strrev(char* buffer)

	If SYSTEM_STRREV==NO then the macro op_strrev need not be defined.

	Group    : library
	Defines  : HAVE_STRREV

SYSTEM_UNI_STRREV							peter

	The system has the following function:

	void wcsrev(uni_char* buffer)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRREV==NO then the macro uni_strrev need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRREV

SYSTEM_UNI_STRTOK							peter

	The system has the following function:

	uni_char* wcstok(uni_char* buffer, uni_char* delimiter)
	where uni_char* represents a UTF-16 string

	If SYSTEM_UNI_STRTOK==NO then the macro uni_strtok need not be defined.

	Group    : library
	Defines  : HAVE_UNI_STRTOK

SYSTEM_ATOI									peter

	The system has the following function:

	int atoi(const char* s)

	If SYSTEM_ATOI==NO then the macro op_atoi need not be defined.

	Group    : library
	Defines  : HAVE_ATOI

SYSTEM_STRTOL								peter

	The system has the following function:

	long strtol(const char* s)

	If SYSTEM_STRTOL==NO then the macro op_strtol need not be defined.

	Group    : library
	Defines  : HAVE_STRTOL

SYSTEM_STRTOUL								peter

	The system has the following function:

	unsigned long strtoul(const char *s)

	If SYSTEM_STRTOUL==NO then the macro op_strtoul need not be defined.

	Group    : library
	Defines  : HAVE_STRTOUL

SYSTEM_ABS									peter

	The system has the following function:

	int abs(int n)

	If SYSTEM_ABS==NO then the macro op_abs need not be defined.

	Group    : library
	Defines  : HAVE_ABS

SYSTEM_TOLOWER								deprecated

	SYSTEM_TOLOWER has been deprecated. Is implemented by modules/stdlib.

SYSTEM_TOUPPER								deprecated

	SYSTEM_TOUPPER has been deprecated. Is implemented by modules/stdlib.

SYSTEM_QSORT								peter

	The system has the following function:

	void op_qsort(void* base, size_t nmemb, size_t size,
	              int (*compar)(const void*, const void*));

	If SYSTEM_QSORT==NO then the macro op_qsort need not be defined.

	Group    : library
	Defines  : HAVE_QSORT

SYSTEM_QSORT_S								wonko

	The system provides a variant of qsort that takes an extra argument
	to allow passing arbitrary data to the comparison function. For
	simplicity (see http://critic.oslo.osa/showcomment?chain=64211)
	this function mimics Microsoft's qsort_s, which has the following
	signature:

	void qsort_s(
	   void *base,
	   size_t num,
	   size_t width,
	   int (*compare)(void *, const void *, const void *),
	   void * context
	);

	FreeBSD and Mac can map this to qsort_r by switching order of the
	last two params.

	For glibc-based systems, the comparison function has a different
	signature; see platforms/posix/sys/declare_libc.h for details of
	how to work around this.  Other platforms may also find this
	useful as an illustration of how to map this API onto similar
	system APIs with different signatures.

	If SYSTEM_QSORT_S==NO then the macro op_qsort_s need not be defined.

	Group    : library
	Defines  : HAVE_QSORT_S

SYSTEM_BSEARCH								peter

	The system has the following function:

	void* op_bsearch(const void* key, const void* base, size_t nmemb,
	                 size_t size, int (*compar)(const void*, const void*));

	If SYSTEM_BSEARCH==NO then the macro op_bsearch need not be defined.

	Group    : library
	Defines  : HAVE_BSEARCH

SYSTEM_RAND									peter

	The system has the following functions:

	void srand(int seed)
	int rand()

	If SYSTEM_RAND==NO then the macros op_rand and op_srand need not
	be defined.

	Group    : library
	Defines  : HAVE_RAND

SYSTEM_FLOOR								peter

	The system has the following function:

	double floor(double x)

	If SYSTEM_FLOOR==NO then the macro op_floor need not be defined.

	Group    : library
	Defines  : HAVE_FLOOR

SYSTEM_CEIL									peter

	The system has the following function:

	double ceil(double x)

	If SYSTEM_CEIL==NO then the macro op_ceil need not be defined.

	Group    : library
	Defines  : HAVE_CEIL

SYSTEM_MODF									peter

	The system has the following function:

	double modf(double x, double* intpart)

	If SYSTEM_MODF==NO then the macro op_modf need not be defined.

	Group    : library
	Defines  : HAVE_MODF

SYSTEM_FMOD									peter

	The system has the following function:

	double fmod(double x, double y)

	If SYSTEM_FMOD==NO then the macro op_fmod need not be defined.

	Group    : library
	Defines  : HAVE_FMOD

SYSTEM_FABS									peter

	The system has the following function:

	double fabs(double x)

	If SYSTEM_FABS==NO then the macro op_fabs need not be defined.

	Group    : library
	Defines  : HAVE_FABS

SYSTEM_LDEXP								peter

	The system has the following function:

	double ldexp(double significand, int exponent)

	If SYSTEM_LDEXP==NO then the macro op_ldexp need not be defined.

	Group    : library
	Defines  : HAVE_LDEXP

SYSTEM_FREXP								peter

	The system has the following function:

	double frexp(double d, int* intpart)

	If SYSTEM_FREXP==NO then the macro op_frexp need not be defined.

	Group    : library
	Defines  : HAVE_FREXP

SYSTEM_POW									peter

	The system has the following function:

	double pow(double x, double y)

	If SYSTEM_POW==NO then the macro op_pow need not be defined.

	Group    : library
	Defines  : HAVE_POW

SYSTEM_SQRT									peter

	The system has the following function:

	double sqrt(double x)

	If SYSTEM_SQRT==NO then the macro op_sqrt need not be defined.

	Group    : library
	Defines  : HAVE_SQRT

SYSTEM_EXP									peter

	The system has the following function:

	double exp(double x)

	If SYSTEM_EXP==NO then the macro op_exp need not be defined.

	Group    : library
	Defines  : HAVE_EXP

SYSTEM_LOG									peter

	The system has the following function:

	double log(double x)

	If SYSTEM_LOG==NO then the macro op_log need not be defined.

	Group    : library
	Defines  : HAVE_LOG

SYSTEM_SIN									peter

	The system has the following function:

	double sin(double x)

	If SYSTEM_SIN==NO then the macro op_sin need not be defined.

	Group    : library
	Defines  : HAVE_SIN

SYSTEM_COS									peter

	The system has the following function:

	double cos(double x)

	If SYSTEM_COS==NO then the macro op_cos need not be defined.

	Group    : library
	Defines  : HAVE_COS

SYSTEM_TAN									peter

	The system has the following function:

	double tan(double x)

	If SYSTEM_TAN==NO then the macro op_tan need not be defined.

	Group    : library
	Defines  : HAVE_TAN

SYSTEM_ASIN									peter

	The system has the following function:

	double asin(double x)

	If SYSTEM_ASIN==NO then the macro op_asin need not be defined.

	Group    : library
	Defines  : HAVE_ASIN

SYSTEM_ACOS									peter

	The system has the following function:

	double acos(double x)

	If SYSTEM_ACOS==NO then the macro op_acos need not be defined.

	Group    : library
	Defines  : HAVE_ACOS

SYSTEM_ATAN									peter

	The system has the following function:

	double atan(double x)

	If SYSTEM_ATAN==NO then the macro op_atan need not be defined.

	Group    : library
	Defines  : HAVE_ATAN

SYSTEM_ATAN2								peter

	The system has the following function:

	double atan2(double y, double x)

	If SYSTEM_ATAN2==NO then the macro op_atan2 need not be defined.

	Group    : library
	Defines  : HAVE_ATAN2

SYSTEM_MALLOC								mortenro

	If SYSTEM_MALLOC==YES, the system has the following functions or
	equivalent ones available:

	void* malloc(size_t nbytes)
	void  free(void* object)
	void* calloc(size_t nmemb, size_t size)
	void* realloc(void* object, size_t size)

	And they can be accessed through the macros op_lowlevel_malloc,
	op_lowlevel_free, op_lowlevel_calloc and op_lowlevel_realloc.

	If SYSTEM_MALLOC==NO, the macros op_lowlevel_malloc, op_lowlevel_free,
	op_lowlevel_calloc, and	op_lowlevel_realloc need not be defined.

	Group    : library
	Defines  : HAVE_MALLOC

SYSTEM_TIME									peter

	The system has the following function:

	time_t op_time(time_t* t)

	If SYSTEM_TIME==NO then the macro op_time need not be defined.

	Group    : library
	Defines  : HAVE_TIME

SYSTEM_LOCALTIME							peter

	The system has the following function:

	struct tm* op_localtime(const time_t* clock)

	If SYSTEM_LOCALTIME==NO then the macro op_localtime need not be defined.

	Group    : library
	Defines  : HAVE_LOCALTIME

SYSTEM_CLOCK								deprecated

	Core code should use g_op_time_info->GetRuntimeMS() instead of
	op_clock().

SYSTEM_MKTIME								peter

	The system has the following function:

	time_t op_mktime(struct tm* timeptr)

	If SYSTEM_MKTIME==NO then the macro op_mktime need not be defined.

	Group    : library
	Defines  : HAVE_MKTIME

SYSTEM_GMTIME								peter

	The system has the following function:

	struct tm* op_gmtime(const time_t* clock)

	If SYSTEM_GMTIME==NO then the macro op_gmtime need not be defined.

	Group    : library
	Defines  : HAVE_GMTIME

SYSTEM_SETLOCALE							lth

	The system has the following function:

	char* op_setlocale(int category, const char* locale)

	If SYSTEM_SETLOCALE==NO then the macro op_setlocale need not be defined.

	Group    : library
	Defines  : HAVE_SETLOCALE

SYSTEM_SPRINTF								peter

	The system has the following function:

	int sprintf(char *buf, const char* fmt, ...)

	If SYSTEM_SPRINTF==NO then the macro op_sprintf need not be defined.

	Group    : library
	Defines  : HAVE_SPRINTF

SYSTEM_UNI_SPRINTF							peter

	The system has the following function:

	int swprintf(uni_char *buf, const uni_char* fmt, ...)

	Please note that the behaviour of this version must match what Opera
	expects from it, i.e it must pass the stdlib module's selftests.

	If SYSTEM_UNI_SPRINTF==NO then the macro uni_sprintf need not be defined.

	Group    : library
	Defines  : HAVE_UNI_SPRINTF

SYSTEM_SNPRINTF								peter

	The system has the following function:

	int snprintf(char *buf, size_t nbytes, const char* fmt, ...)

	If SYSTEM_SNPRINTF==NO then the macro op_snprintf need not be defined.

	Group    : library
	Defines  : HAVE_SNPRINTF

SYSTEM_UNI_SNPRINTF							peter

	The system has the following function:

	int snwprintf(uni_char *buf, size_t nbytes, const uni_char* fmt, ...)

	Please note that the behaviour of this version must match what Opera
	expects from it, i.e it must pass the stdlib module's selftests.

	If SYSTEM_UNI_SNPRINTF==NO then the macro uni_snprintf need not be defined.

	Group    : library
	Defines  : HAVE_UNI_SNPRINTF

SYSTEM_VSPRINTF								peter

	The system has the following function:

	int vsprintf(char *buf, const char* fmt, va_list args)

	If SYSTEM_VSPRINTF==NO then the macro op_vsprintf need not be defined.

	Group    : library
	Defines  : HAVE_VSPRINTF

SYSTEM_UNI_VSPRINTF							peter

	The system has the following function:

	int vswprintf(uni_char *buf, const uni_char* fmt, va_list args)

	Please note that the behaviour of this version must match what Opera
	expects from it, i.e it must pass the stdlib module's selftests.

	If SYSTEM_UNI_VSPRINTF==NO then the macro uni_vsprintf need not be defined.

	Group    : library
	Defines  : HAVE_UNI_VSPRINTF

SYSTEM_VSNPRINTF							peter

	The system has the following function:

	int vsnprintf(char *buf, size_t nbytes, const char* fmt, va_list args)

	If SYSTEM_VSNPRINTF==NO then the macro op_vsnprintf need not be defined.

	Group    : library
	Defines  : HAVE_VSNPRINTF

SYSTEM_UNI_VSNPRINTF						peter

	The system has the following function:

	int vsnwprintf(uni_char *buf, size_t nbytes, const uni_char* fmt, va_list args)

	Please note that the behaviour of this version must match what Opera
	expects from it, i.e it must pass the stdlib module's selftests.

	If SYSTEM_UNI_VSNPRINTF==NO then the macro uni_vsnprintf need not be defined.

	Group    : library
	Defines  : HAVE_UNI_VSNPRINTF

SYSTEM_SSCANF								peter

	The system has the following function:

	int sscanf(const char *s, const char *fmt, ...)

	If SYSTEM_SSCANF==NO then the macro op_sscanf need not be defined.

	Group    : library
	Defines  : HAVE_SSCANF

SYSTEM_UNI_SSCANF							peter

	The system has the following function:

	int swscanf(const uni_char *s, const uni_char *fmt, ...)

	Please note that the behaviour of this version must match what Opera
	expects from it, i.e it must pass the stdlib module's selftests.

	If SYSTEM_UNI_SSCANF==NO then the macro uni_sscanf need not be defined.

	Group    : library
	Defines  : HAVE_UNI_SSCANF

SYSTEM_VSSCANF								roarl

	The system has the following function:

	int vsscanf(const char *s, const char *fmt, va_list args)

	If SYSTEM_VSSCANF==NO then the macro op_vsscanf need not be defined.
	If SYSTEM_VSSCANF==NO the stdlib module provides an implementation for op_vsscanf() if FEATURE_3P_PRINTF_SCANF is enabled.

	Group    : library
	Defines  : HAVE_VSSCANF

SYSTEM_NTOHS								jl

	The system has the following function:

	int UINT16 ntohs(UINT16 netshort)

	If SYSTEM_NTOHS==NO then the macro op_ntohs need not be defined.

	Group    : library
	Defines  : HAVE_NTOHS

SYSTEM_NTOHL								jl

	The system has the following function:

	int UINT32 ntohl(UINT32 netlong)

	If SYSTEM_NTOHL==NO then the macro op_ntohl need not be defined.

	Group    : library
	Defines  : HAVE_NTOHL

SYSTEM_HTONS								jl

	The system has the following function:

	int UINT16 htons(UINT16 hostshort)

	If SYSTEM_HTONS==NO then the macro op_htons need not be defined.

	Group    : library
	Defines  : HAVE_HTONS

SYSTEM_HTONL								jl

	The system has the following function:

	int UINT32 htonl(UINT32 hostlong)

	If SYSTEM_HTONL==NO then the macro op_htonl need not be defined.

	Group    : library
	Defines  : HAVE_HTONL

SYSTEM_GETENV								simonb

	The system has the following function:

	const char* getenv(const char* name);

	If SYSTEM_GETENV==NO then the macro op_getenv need not be defined.

	Group    : library
	Defines  : HAVE_GETENV

SYSTEM_PUTENV								simonb

	The system has the following function:

	int putenv(char* string);

	If SYSTEM_PUTENV==NO then the macro op_putenv need not be defined.

	Group    : library
	Defines  : HAVE_PUTENV

SYSTEM_ERRNO								peter

	The system defines the integer variable errno, which is set to a
	non-zero value by some system calls and library functions. errno might
	be a macro.

	If the system library does not define such a variable or macro to
	retrieve the error code, SYSTEM_ERRNO should be set to NO. In this case
	the Opera core will not attempt reading or writing it.

	Group    : library
	Defines  : HAVE_ERRNO

SYSTEM_FORCE_INLINE							axel

	The system's compiler supports forced inlining for cases where
	we really know better.

	If SYSTEM_FORCE_INLINE==YES then you need to define the macro
	op_force_inline.
	If SYSTEM_FORCE_INLINE==NO then the macro op_force_inline is
	automatically defined as inline and the compiler decides whether
	or not to inline a function.

    The macro is op_force_inline is used in front of a function
    definition but after "static" or "virtual" keyword, like:

      op_force_inline char* my_inline_function(int foo, char* bar);
      static op_force_inline void MyClass::MyMethod() const;
      virtual op_force_inline int MyClass::Foo(int bar);

    * Note: gcc 4.1 and older does not support forced inline
      elements. With gcc you can however add the attribure
      "always_inline" to inline a function even if no optimization
      level was specified. To use that attribute, enable this system
      setting and define op_force_inline like

        #define op_force_inline inline __attribute__((always_inline))

      gcc will nevertheless decide whether or not it is wise to
      actually inline a function.

      Compiling core-2-gogi with the desktop-profile on gcc 4.3.3
      showed that using force-inline costs approximately 4KB
      footprint.

      See also
      - http://gcc.gnu.org/onlinedocs/gcc/Attribute-Syntax.htm
      - http://gcc.gnu.org/onlinedocs/gcc-3.4.3/gcc/Inline.html

    * Note: platforms using Visual Studio can set this system to yes
      and define op_force_inline like:

        #define op_force_inline __forceinline

      Compiling core-2-gogi with the desktop-profile on Visual Studio
      2005 showed no difference in footprint on toggling the
      force-inline system.

      See also
      - http://msdn.microsoft.com/en-us/library/z8y1yy88(VS.80).aspx

    * Warning: Currently there is no empiric data about footprint loss
      or performance gain on enabling this system. Using the forced
      inline overrides the cost/benefit analysis of the compiler and
      relies on the judgment of the programmer. Fore-inline can result
      in larger code with only marginal performance gain - or in same
      cases even performance losses (due to increased paging of a
      larger executable, for example). If you decide to enable this
      system it is advisable to run a cost/benefit analysis on each
      core-upgrade to monitor any changes.

    * Recommendation: Set SYSTEM_FORCE_INLINE==NO to not override the
      compiler inline strategy. Only enable it if benchmark tests show
      that the performance gain is more valuable than the increased
      footprint.

	Defines  : HAVE_FORCE_INLINE

SYSTEM_OPFILELENGTH_IS_SIGNED					haavardm
	Set to YES if OpFileLength is a signed type.

	Defines : OPFILE_LENGTH_IS_SIGNED

SYSTEM_NAMESPACE							arjanl

	The system's compiler supports C++ namespaces.

	Defines  : HAVE_NAMESPACE

SYSTEM_NOTHROW								mstensho

	The system's compiler supports "throw()" (declare that a method
	won't throw any exceptions). If you're building with support for
	C++ exceptions, you want to say YES here. It is mainly used with
	operator new(), to tell the compiler that they may return NULL, so
	that it needs to generate code that checks for NULL.

	Defines  : OP_NOTHROW = "throw()" / ""

SYSTEM_CAN_DELETE_OPEN_FILE					wdzierzanowski

	Set to YES if the system allows a process to delete a file currently open
	in another process.

	On *nix systems, the fact that a file is opened by some process will not
	prevent another process from successfully executing OpFile::Delete() on
	that file.

	This needs to be set to NO on Windows, where an open file is locked and
	cannot be deleted.

	Defines  : CAN_DELETE_OPEN_FILE

SYSTEM_TEMPLATE_ARG_DEDUCTION				wdzierzanowski

	The system's compiler supports template argument deduction. When
	enabled, a safer, template-based version of ARRAY_SIZE is enabled, by
	having the compiler deduce the size of the data type at compile time.
	This also stops mistakes like using ARRAY_SIZE on a pointer type.

	This is known to work with recent versions of GCC and Visual C++.

	Defines  : HAVE_TEMPLATE_ARG_DEDUCTION

SYSTEM_LOCAL_TYPE_AS_TEMPLATE_ARG			wdzierzanowski

	The system's compiler supports template argument deduction using local
	types as template arguments. When enabled, a safer, template-based
	version of LOCAL_ARRAY_SIZE is enabled, by having the compiler deduce
	the size of the data type at compile time. This also stops mistakes like
	using LOCAL_ARRAY_SIZE on a pointer type.

	This is beyond what the C++ standard mandates, and is known to work with
	recent versions of Visual C++, but not with GCC (at least version 4.4).

	Defines  : HAVE_LOCAL_TEMPLATE_ARG_DEDUCTION

type BOOL									markus

	 Needs to be at least 1 byte since a BOOL is used
	 incorrectly in the doc module. This may change in
	 the future. Also requires TRUE and FALSE to be set.

type uni_char								markus

	 The unicode character type.
	 Probably needs to be exactly 2 bytes. Has to be unsigned.

type INT64									markus

	A signed 64-bit integer. Only available if SYSTEM_INT64 is set to
	YES.

	Check if: SYSTEM_INT64

type UINT64									jl

	 An unsigned 64-bit integer.  Only available if SYSTEM_UINT64 is
	 set to YES.

	 Check if: SYSTEM_UINT64

type UINT32									markus

	 An unsigned 32-bit integer.

type UINT16									markus

	 An unsigned 16-bit integer.

type UINT8									markus

	 An unsigned 8-bit integer.

type INT32									markus

	 A signed 32-bit integer.

type INT16									markus

	 A signed 16-bit integer.

type uint32									deprecated

	 An unsigned 32-bit integer. Equivalent to UINT32.

type uint16									deprecated

	 An unsigned 16-bit integer. Equivalent to UINT16.

type uint8									deprecated

	 An unsigned 8-bit integer. Equivalent to UINT8.

type int32									deprecated

	 A signed 32-bit integer. Equivalent to INT32.

type int16									deprecated

	 A signed 16-bit integer. Equivalent to INT16.

type int8									deprecated

	 A signed 8-bit integer.

type UINT									markus

	 An unsigned integer. At least 32 bits.

type INT									markus

	 A signed integer. At least 32 bits.

type UCHAR									markus

	 An unsigned 8-bit integer. Equivalent to UINT8.

type BYTE									deprecated

	 An unsigned 8-bit integer. Equivalent to UINT8.

type LONG									deprecated

	 A signed integer. At least 32 bits.

type byte									deprecated

	 An unsigned 8-bit integer. Equivalent to UINT8.

type DWORD									deprecated

	 An unsigned 32-bit integer. Equivalent to UINT32.

type WORD									deprecated

	 An unsigned 16-bit integer. Equivalent to UINT16.

type INTPTR									markus

	 A signed integer. At least 32 bits. Equivalent to INT.

type UINTPTR								markus

	 An unsigned integer. At least 32 bits. Equivalent to UINT.

type OpFileLength                           markus

	 Used for file lengths. If OpFileLength is signed,
	 SYSTEM_OPFILELENGTH_IS_SIGNED must be set accordingly.

type ptrdiff_t								markus

	 An integer descirbing the result of subtraction of two pointers.
	 On 32-bit systems this is a 32-bit integer and on 64-bit
	 systems this is a 64-bit integer.

macro _MAX_PATH								markus

	  Defines the maximum length of a fully qualified filename (including path).

macro min									deprecated, unchecked
macro max									deprecated, unchecked

macro MIN									markus

	  MIN(a,b) should return the smallest value of a and b

macro MAX									markus

	  MAX(a,b) should return the largest value of a and b

macro PATHSEP								markus

	  Defines the path separator used on this platform as a string.

macro PATHSEPCHAR							markus

	  Defines the path separator used on this platform as a char.

macro CLASSPATHSEP							markus

	  Defines the class path separator used on this platform as a string.

macro CLASSPATHSEPCHAR						markus

	  Defines the class path separator used on this platform as a char.

macro NEWLINE								lasse

	  Defines the string used for the system's newline. This string is
	  used to write text files (e.g. for SaveCurrentDocAsText()).

	  Example for linux systems: #define NEWLINE "\n"
	  Example for windows systems: #define NEWLINE "\r\n"

macro FILE_LENGTH_NONE						jl

	  Defines a OpFileLength value that represents an undefined file
	  length or file position.  If OpFileLength is a signed type, a
	  negative value is appropriate.  If OpFileLength is an unsigned
	  type, that type's maximum value is appropriate.

macro FILE_LENGTH_MAX					haavardm

	  Defines the largest number which can be put in an OpFileLength.
	  This macro is used to detect integer overflow in string to OpFileLength
	  conversions.

macro SYS_CAP_WILDCARD_SEARCH				yngve

	  Defines the a search string used to search for all files in a directory.
	  For Windows systems this is normally "*.*" and for UNIX systems
	  this is normally "*".

macro UCHAR_MAX								markus

	  Defines the largest number which can be put in an unsigned char.
	  Normally defined in <limits.h>.

macro INT_MIN								markus

	  Defines the smallest number which can be put in an int. Normally
	  defined in <limits.h>.

macro INT_MAX								markus

	  Defines the largest number which can be put in an int. Normally
	  defined in <limits.h>.

macro UINT_MAX								markus

	  Defines the largest number which can be put in an  unsigned int.
	  Normally defined in <limits.h>.

macro SHRT_MIN								markus

	  Defines the smallest number which can be put in a short. Normally
	  defined in <limits.h>.

macro SHRT_MAX								markus

	  Defines the largest number which can be put in a short. Normally
	  defined in <limits.h>.

macro USHRT_MAX								markus

	  Defines the largest number which can be put in an unsigned short.
	  Normally defined in <limits.h>.

macro LONG_MIN								markus

	  Defines the smallest number which can be put in a long. Normally
	  defined in <limits.h>

macro LONG_MAX								markus

	  Defines the largest number which can be put in a long. Normally
	  defined in <limits.h>

macro ULONG_MAX								markus

	  Defines the largest number which can be put in an unsigned long.
	  Normally defined in <limits.h>.

macro LLONG_MIN								peter

	  Defines the smallest number which can be put in a long long. Normally
	  defined in <limits.h>

	  Check if: SYSTEM_LONGLONG

macro LLONG_MAX								peter

	  Defines the largest number which can be put in a long long. Normally
	  defined in <limits.h>

	  Check if: SYSTEM_LONGLONG

macro ULLONG_MAX							peter

	  Defines the largest number which can be put in an unsigned long long.
	  Normally defined in <limits.h>.

	  Check if: SYSTEM_LONGLONG

macro INT64_MIN								jl

	  Like INT_MIN, but for the INT64 type, if SYSTEM_INT64 is enabled.

	  Check if: SYSTEM_INT64

macro INT64_MAX								jl

	  Like INT_MAX, but for the INT64 type, if SYSTEM_INT64 is enabled.

	  Check if: SYSTEM_INT64

macro UINT64_MAX								jl

	  Like UINT_MAX, but for the UINT64 type, if SYSTEM_UINT64 is enabled.

	  Check if: SYSTEM_UINT64

macro CHAR_BIT								peter

	  Defines the number of bits in a byte.
	  Normally defined in <limits.h>

macro DBL_MIN								markus

	  Defines the smallest number which can be put in a double.
	  Normally defined in <float.h>.

macro DBL_MAX								markus

	  Defines the largest number which can be put in a double.
	  Normally defined in <float.h>.

macro DBL_MAX_EXP							markus

	  The macro yields the maximum integer X, such that
	  FLT_RADIX^(X - 1) is a finite representable value of type double.

macro DBL_MAX_10_EXP						markus

	  The macro yields the maximum integer X, such that
	  10^X is a finite representable value of type double.

macro DBL_DIG								markus

	  The macro yields the precision in decimal digits for type double.

macro FLT_DIG								markus

	  The macro yields the precision in decimal digits for type float.

macro FLT_RADIX								markus

	  The macro yields the radix of all floating-point representations.

macro OP_INT64								arjanl

	  OP_INT64(x) yields a 64-bit literal for integer literal x.
	  A system which accepts the C99-style syntax (like gcc or Visual Studio
	  2010) may define this macro as "#define OP_INT64(x) x ## LL".
	  A system with an older Visual Studio version on windows may define this
	  macro as "#define OP_UINT64(x) x ## i64".

	  Check if: SYSTEM_INT64_LITERAL

macro OP_UINT64								arjanl

	  OP_UINT64(x) yields an unsigned 64-bit literal for integer literal x.
	  A system which accepts the C99-style syntax (like gcc or Visual Studio
	  2010) may define this macro as "#define OP_INT64(x) x ## ULL".
	  A system with an older Visual Studio version on windows may define this
	  macro as "#define OP_UINT64(x) x ## ui64".

	  Check if: SYSTEM_UINT64_LITERAL

macro op_lowlevel_malloc					mortenro

	  Defines a macro which allocates size bytes and returns a pointer
	  to the allocated memory. The memory is not cleared.  NULL is
	  returned on failure.

	  void* op_lowlevel_malloc(size_t size);

      Check if: SYSTEM_MALLOC

macro op_lowlevel_free						mortenro

	  Defines a macro which frees the memory space pointed to by ptr,
	  which must have been returned by a previous call to
	  op_lowlevel_malloc(), op_lowlevel_calloc() or
	  op_lowlevel_realloc().

	  Please note that op_lowlevel_free(NULL) is a valid case.

	  void op_lowlevel_free(void* ptr);

      Check if: SYSTEM_MALLOC

macro op_lowlevel_calloc					mortenro

	  Defines a macro which allocates memory for an array of nmemb
	  elements of size bytes each and returns a pointer to the
	  allocated memory. The memory is set to zero.

	  void* op_lowlevel_calloc(size_t nmemb, size_t size);

      Check if: SYSTEM_MALLOC

macro op_lowlevel_realloc					mortenro

	  Defines a macro which changes the size of the memory block
	  pointed to by ptr to size bytes. The contents will be unchanged
	  to the minimum of the old and new sizes; newly allocated memory
	  will be uninitialized. If ptr is NULL, the call is equivalent to
	  op_lowlevel_malloc(size); if size is equal to zero, the call is
	  equivalent to op_lowlevel_free(ptr). Unless ptr is NULL, it must
	  have been returned by an earlier call to op_lowlevel_malloc(),
	  op_lowlevel_calloc() or op_lowlevel_realloc().

	  void* op_lowlevel_realloc(void* ptr, size_t size);

      Check if: SYSTEM_MALLOC

macro op_malloc								deprecated

	  Deprecated: Defined in memory/memory_fundamentals.h

macro op_calloc								deprecated

	  Deprecated: Defined in memory/memory_fundamentals.h

macro op_realloc							deprecated

	  Deprecated: Defined in memory/memory_fundamentals.h

macro op_free								deprecated

	  Deprecated: Defined in memory/memory_fundamentals.h

macro op_strtod								peter

	  Defines a macro converts a string to a double-precision value.

	  double op_strtod(const char *nptr, char **endptr);

	  Check if: SYSTEM_STRTOD

macro op_memmem								peter

	  Defines a macro which finds the first occurrence of the
	  substring needle of length needlelen in the memory area haystack
	  of length haystacklen, and returns a pointer to it or NULL
	  if the substring was not found.

	  void *op_memmem(const void *haystack, size_t haystacklen, const void *needle, size_t needlelen);

	  Check if: SYSTEM_MEMMEM

macro op_memmove							markus

	  Defines a macro which copies n bytes from memory area src to
	  memory area dst. The memory areas may overlap. Returns a
	  pointer to dest.

	  void* op_memmove(void* dest, const void* src, size_t n);

      Check if: SYSTEM_MEMMOVE

macro op_memset								markus

	  Defines a macro which fills the first n bytes of the memory
	  area pointed by s with the constant byte c.

	  void* op_memset(void* s, int c, size_t n);

      Check if: SYSTEM_MEMSET

macro op_memcpy								markus

	  Defines a macro which copies n bytes from meory area src to
	  memory area dst. The memory areas may not overlap. Use op_memmove
	  if the memory areas overlap.

	  void* op_memcpy(void* dest, const void* src, size_t n);

      Check if: SYSTEM_MEMCPY

macro op_memcmp								markus

	  Defines a macro which compares the first n bytes of the
	  memory areas s1 and s2. It returns an integer less than,
	  equal to, or greater than zero if s1 is found, respectively,
	  to be less than, to match, or be greater than s2.

	  int op_memcmp(const void* s1, const void* s2, size_t n);

      Check if: SYSTEM_MEMCMP

macro op_memchr								markus

	  Defines a macro which scans the first n bytes of the memory
	  area pointed to by s for the character c. The first byte
	  to match c (interpreted as an unsigned character)
	  stops the operation.

	  void* op_memchr(const void* s, int c, size_t n);

      Check if: SYSTEM_MEMCHR

macro uni_memchr							johanh

	  Defines a macro which scans the first n characters of the memory
	  area pointed to by s for the character c. The first character
	  to match c stops the operation.

	  uni_char* uni_memchr(const uni_char* s, uni_char c, size_t n);

      Check if: SYSTEM_UNI_MEMCHR

macro op_strlen								markus

	  Defines a macro which calculates the length of the string s,
	  not including the terminating '\0' character.

	  size_t op_strlen(const char* s);

      Check if: SYSTEM_STRLEN

macro uni_strlen							markus

	  Defines a macro which calculates the length of the string s,
	  not including the terminating '\0' character.

	  size_t uni_strlen(const uni_char* s);

      Check if: SYSTEM_UNI_STRLEN

macro op_strcpy								markus

	  Defines a macro which copies the string pointed to by src
	  (including the terminating '\0' character) to the array
	  pointed to by dest. The strings may not overlap, and the
	  destination string dest must be large enough to receive
	  the copy.

	  char* op_strcpy(char* dest, const char* src);

      Check if: SYSTEM_STRCPY

macro uni_strcpy							markus

	  Defines a macro which copies the string pointed to by src
	  (including the terminating '\0' character) to the array
	  pointed to by dest. The strings may not overlap, and the
	  destination string dest must be large enough to receive
	  the copy.

	  uni_char* uni_strcpy(uni_char* dest, const uni_char* src);

      Check if: SYSTEM_UNI_STRCPY

macro op_strncpy							markus

	  Defines a macro which is similar to op_strcpy, except that
	  not more than n bytes of src are copied. Thus, if there is
	  no null byte among the first n bytes of src, the result
	  will not be null-terminated.

	  In the case where the length of src is less than that of
	  n, the remainder of dest will be padded with nulls.

	  char* op_strncpy(char* dest, const char* src, size_t n);

      Check if: SYSTEM_STRNCPY

macro uni_strncpy							markus

	  Defines a macro which is similar to uni_strcpy, except that
	  not more than n character of src are copied. Thus, if there is
	  no null character among the first n bytes of src, the result
	  will not be null-terminated.

	  In the case where the length of src is less than that of
	  n, the remainder of dest will be padded with nulls.

	  uni_char* uni_strncpy(uni_char* dest, const uni_char* src, size_t n);

      Check if: SYSTEM_UNI_STRNCPY

macro op_strlcpy							peter

	  Defines a macro which is similar to op_strcpy, except that
	  not more than n-1 bytes of src are copied, and the nul
	  termination of the resulting string is always guaranteed.

	  The return value is the size of the string it tried to
	  create, i.e the length of src.

	  size_t op_strlcpy(char* dest, const char* src, size_t n);

      Check if: SYSTEM_STRLCPY

macro uni_strlcpy							peter

	  Defines a macro which is similar to uni_strcpy, except that
	  not more than n-1 characters of src are copied, and the nul
	  termination of the resulting string is always guaranteed.

	  The return value is the size of the string it tried to
	  create, i.e the length of src.

	  size_t uni_strlcpy(uni_char* dest, const uni_char* src, size_t n);

      Check if: SYSTEM_UNI_STRLCPY

macro op_strcat								markus

	  Defines a macro which appends the src string to the dest
	  string overwriting the `\0' character at the end of dest,
	  and then adds a terminating `\0' character. The strings
	  may not overlap, and the dest string must have enough
	  space for the result.

	  char* op_strcat(char* dest, const char* src);

      Check if: SYSTEM_STRCAT

macro uni_strcat							markus

	  Defines a macro which appends the src string to the dest
	  string overwriting the `\0' character at the end of dest,
	  and then adds a terminating `\0' character. The strings
	  may not overlap, and the dest string must have enough
	  space for the result.

	  uni_char* uni_strcat(uni_char* dest, const uni_char* src);

      Check if: SYSTEM_UNI_STRCAT

macro op_strncat							markus

	  Defines a macro which is similar to op_strcat, except that
	  only the first n characters of src are appended to dest.

	  char* op_strncat(char* dest, const char* src, size_t n);

      Check if: SYSTEM_STRNCAT

macro uni_strncat							markus

	  Defines a macro which is similar to op_strcat, except that
	  only the first n characters of src are appended to dest.

	  char* uni_strncat(uni_char* dest, const uni_char* src, size_t n);

      Check if: SYSTEM_UNI_STRNCAT

macro op_strlcat							markus

	  Defines a macro which is similar to op_strcat, except that
	  no more characters of src are appended to dest than to
	  make the total length of dest n, including the terminating
	  nul character, which is always added.

	  The return value is the size of the strings it tried to
	  create, i.e the initial length of dest plus the length of
	  src.

	  size_t op_strlcat(char* dest, const char* src, size_t n);

      Check if: SYSTEM_STRLCAT

macro uni_strlcat							markus

	  Defines a macro which is similar to uni_strcat, except that
	  no more characters of src are appended to dest than to
	  make the total length of dest n, including the terminating
	  nul character, which is always added.

	  The return value is the size of the strings it tried to
	  create, i.e the initial length of dest plus the length of
	  src.

	  size_t uni_strlcat(uni_char* dest, const uni_char* src, size_t n);

      Check if: SYSTEM_UNI_STRLCAT

macro op_strcmp								markus

	  Defines a macro which compares the two strings s1 and s2.
	  It returns an integer less than, equal to, or greater than
	  zero if s1 is found, respectively, to be less than, to
	  match, or be greater than s2.

	  int op_strcmp(const char* s1, const char* s2);

      Check if: SYSTEM_STRCMP

macro real_uni_strcmp						markus

	  Defines a macro which compares the two strings s1 and s2.
	  It returns an integer less than, equal to, or greater than
	  zero if s1 is found, respectively, to be less than, to
	  match, or be greater than s2.

	  int real_uni_strcmp(const uni_char* s1, const uni_char* s2);

      Check if: SYSTEM_UNI_STRCMP

macro op_strncmp							markus

	  Defines a macro which is similar to op_strcmp except it
	  only compares the first n characters of s1.

	  int op_strncmp(const char* s1, const char* s2, size_t n);

      Check if: SYSTEM_STRNCMP

macro real_uni_strncmp						markus

	  Defines a macro which is similar to uni_strcmp except it
	  only compares the first n characters of s1.

	  int real_uni_strncmp(const uni_char* s1, const uni_char* s2, size_t n);

      Check if: SYSTEM_UNI_STRNCMP

macro op_stricmp							markus

	  Defines a macro which lexicographically compare
	  the null-terminated strings s1 and s2.

	  int op_stricmp(const char* s1, const char* s2);

      Check if: SYSTEM_STRICMP

macro real_uni_stricmp						markus

	  Defines a macro which lexicographically compare
	  the null-terminated strings s1 and s2.

	  int real_uni_stricmp(const uni_char* s1, const uni_char* s2);

      Check if: SYSTEM_UNI_STRICMP

macro op_strnicmp							markus

	  Defines a macro which is the equivalent of op_stricmp
	  but n is the maximum number of characters to compare.

	  int op_strnicmp(const char* s1, const char* s2, size_t n);

      Check if: SYSTEM_STRNICMP

macro real_uni_strnicmp						markus

	  Defines a macro which is the equivalent of uni_stricmp
	  but n is the maximum number of characters to compare.

	  int real_uni_strnicmp(const uni_char* s1, const uni_char* s2, size_t n);

      Check if: SYSTEM_UNI_STRNICMP

macro op_strchr								markus

	  Defines a macro which returns a pointer to the first
	  occurrence of the character c in the string s.

	  char* op_strchr(const char* s, int c);

      Check if: SYSTEM_STRCHR

macro uni_strchr							markus

	  Defines a macro which returns a pointer to the first
	  occurrence of the character c in the string s.

	  uni_char* uni_strchr(const uni_char* s, uni_char c);

      Check if: SYSTEM_UNI_STRCHR

macro op_strrchr							markus

	  Defines a macro which returns a pointer to the last
	  occurrence of the character c in the string s.

	  char* op_strrchr(const char* s, int c);

      Check if: SYSTEM_STRRCHR

macro uni_strrchr							markus

	  Defines a macro which returns a pointer to the last
	  occurrence of the character c in the string s.

	  uni_char* uni_strrchr(const uni_char* s, uni_char c);

      Check if: SYSTEM_UNI_STRRCHR

macro op_strstr								markus

	  Defines a macro which finds the first occurrence of the
	  substring needle in the string haystack. The terminating
	  `\0' characters are not compared.

	  char* op_strstr(const char* haystack, const char* needle);

      Check if: SYSTEM_STRSTR

macro real_uni_strstr						markus

	  Defines a macro which finds the first occurrence of the
	  substring needle in the string haystack. The terminating
	  `\0' characters are not compared.

	  uni_char* real_uni_strstr(const uni_char* haystack, const uni_char* needle);

      Check if: SYSTEM_UNI_STRSTR

macro real_uni_stristr						markus

	  Defines a macro which is similar to uni_strstr, but compares
	  the strings case-insensitively.

	  uni_char* real_uni_stristr(const uni_char* haystack, const uni_char* needle);

      Check if: SYSTEM_UNI_STRISTR

macro op_strspn								markus

	  Defines a macro which calculates the length of the initial
	  segment of s which consists entirely of characters in accept.

	  size_t op_strspn(const char* s, const char* accept);

      Check if: SYSTEM_STRSPN

macro uni_strspn							markus

	  Defines a macro which calculates the length of the initial
	  segment of s which consists entirely of characters in accept.

	  size_t uni_strspn(const uni_char* s, const uni_char* accept);

      Check if: SYSTEM_UNI_STRSPN

macro op_strcspn							markus

	  Defines a macro which calculates the length of the initial
	  segment of s which consists entirely of characters not in reject.

	  size_t op_strcspn(const char* s, const char* reject);

	  Check if: SYSTEM_STRCSPN

macro uni_strcspn							markus

	  Defines a macro which calculates the length of the initial
	  segment of s which consists entirely of characters not in reject.

	  size_t uni_strcspn(const uni_char* s, const uni_char* reject);

	  Check if: SYSTEM_UNI_STRCSPN

macro op_strpbrk							markus

	  Defines a macro which locates the first occurrence in the
	  string s of any of the characters in the string accept.

	  char* op_strpbrk(const char *s, const char *accept);

      Check if: SYSTEM_STRPBRK

macro uni_strpbrk							markus

	  Defines a macro which locates the first occurrence in the
	  string s of any of the characters in the string accept.

	  uni_char* uni_strpbrk(const uni_char *s, const uni_char *accept);

      Check if: SYSTEM_UNI_STRPBRK

macro op_strupr								markus

	  Defines a macro which converts an ASCII string to uppercase.
	  Behaviour on characters outside of the ASCII repertoire is
	  undefined.

	  char* op_strupr(char* buffer)

	  Check if: SYSTEM_STRCASE

macro op_strlwr								markus

	  Defines a macro which converts an ASCII string to lowercase.
	  Behaviour on characters outside of the ASCII repertoire is
	  undefined.

	  char* op_strlwr(char* buffer)

	  Check if: SYSTEM_STRCASE

macro op_strrev								markus

	  Defines a macro which reverses a string in-place.

	  void op_strrev(char* buffer)

	  Check if: SYSTEM_STRREV

macro uni_strrev							markus

	  Defines a macro which reverses a string in-place.

	  void uni_strrev(uni_char* buffer)

	  Check if: SYSTEM_UNI_STRREV

macro uni_strtok							peter

	  Defines a macro which splits a string into tokens. When called
	  with a non-NULL buffer, it locates the first occurance of one
	  of the characters in the delimiter string, and replaces it with
	  a null. It then returns a pointer to the first character that
	  is not part of that token.

	  On a subsequent call, with buffer set to NULL, it will repeat
	  the search for the subsequent occurance of the token separator,
	  and return a pointer to the start of the token following the
	  previous returned.

	  If a token separator character is followed by another token
	  separator, all separator characters will be ignored before
	  returning the next token.

	  uni_char* uni_strtok(uni_char* buffer, uni_char* delimiter)

	  Check if: SYSTEM_UNI_STRTOK

macro op_lowlevel_strdup					mortenro

	  Defines a macro which returns a pointer to a new string
	  which is a duplicate of the string s. Memory for the new
	  string is obtained with op_malloc, and can be freed with
	  op_free.

	  char* op_lowlevel_strdup(const char* s);

      Check if: SYSTEM_STRDUP

macro uni_lowlevel_strdup					mortenro

	  Defines a macro which returns a pointer to a new string
	  which is a duplicate of the string s. Memory for the new
	  string is obtained with op_malloc, and can be freed with
	  op_free.

	  uni_char* uni_lowlevel_strdup(const uni_char* s);

      Check if: SYSTEM_UNI_STRDUP

macro op_strdup							deprecated

	  Deprecated: Defined in memory/memory_fundamentals.h

macro uni_strdup								deprecated

	  Deprecated: Defined in memory/memory_fundamentals.h

macro op_strtol								markus

	  Defines a macro which converts the string in nptr to a long value.

	  long op_strtol(const char* restrict_nptr, char** restrict_endptr, int base);

      Check if: SYSTEM_STRTOL

macro op_strtoul							markus

	  Defines a macro which converts the string in nptr to an unsigned long value.

	  unsigned long op_strtoul(const char* restrict_nptr, char** restrict_endptr, int base);

      Check if: SYSTEM_STRTOUL

macro op_atoi								markus

	  Defines a macro which converts the initial portion of the
	  string pointed to by nptr to int. The behaviour is the
	  same as

			op_strtol(nptr, (char**)NULL, 10);

	  except that op_atoi() does not detect errors.

	  int op_atoi(const char* nptr);

      Check if: SYSTEM_ATOI

macro op_itoa								markus

	  Defines a macro which converts an integer to a string.

	  char* op_itoa(int value, char* string, int radix);

      Check if: SYSTEM_ITOA

macro uni_itoa								markus

	  Defines a macro which converts an integer to a string.

	  uni_char* uni_itoa(int value, uni_char* string, int radix);

      Check if: SYSTEM_UNI_ITOA

macro op_ltoa								markus

	  Defines a macro which converts a long integer to a string.

	  char* op_ltoa(long value, char* string, int radix);

      Check if: SYSTEM_LTOA

macro uni_ltoa								markus

	  Defines a macro which converts a long integer to a string.

	  uni_char* uni_ltoa(long value, uni_char* string, int radix);

      Check if: SYSTEM_UNI_LTOA

macro op_abs								markus

	  Defines a macro which computes the absolute value of the
	  integer argument j.

	  int op_abs(int j);

      Check if: SYSTEM_ABS

macro op_floor								markus

	  Defines a macro which rounds x downwards to the nearest
	  integer, returning that value as a double.

	  double op_floor(double x);

      Check if: SYSTEM_FLOOR

macro op_ceil								markus

	  Defines a macro which rounds x upwards to the nearest
	  integer, returning that value as a double.

	  double op_ceil(double x);

      Check if: SYSTEM_CEIL

macro op_modf								markus

	  Defines a macro which breaks the argument x into an integral
	  part and a fractional part, each of which has the same
	  sign as x. The integral part is stored in iptr.

	  double op_modf(double x, double* iptr)

      Check if: SYSTEM_MODF

macro op_fmod								markus

	  Defines a macro which computes the remainder of dividing x
	  by y. The return value is x - n * y, where n is the quotient
	  of x / y, rounded towards zero to an integer.

	  double op_fmod(double x, double y);

      Check if: SYSTEM_FMOD

macro op_fabs								markus

	  Defines a macro which returns the absolute value of the
	  floating-point number x.

	  double op_fabs(double x);

      Check if: SYSTEM_FABS

macro op_pow								markus

	  Defines a macro which returns the value of x raised
	  to thepower of y.

	  double op_pow(double x, double y);

      Check if: SYSTEM_POW

macro op_exp								markus

	  Defines a macro which returns the value of e (the base of
	  natural logarithms) raised to the power of x.

	  double op_exp(double x);

      Check if: SYSTEM_EXP

macro op_log								markus

	  Defines a macro which returns the natural logarithm of x.

	  double op_log(double x);

      Check if: SYSTEM_LOG

macro op_sqrt								markus

	  Defines a macro which returns the non-negative square root
	  of x.

	  double op_sqrt(double x);

      Check if: SYSTEM_SQRT

macro op_sin								markus

	  Defines a macro which returns the sine of x, where x is
	  given in radians.

	  double op_sin(double x);

      Check if: SYSTEM_SIN

macro op_cos								markus

	  Defines a macro which returns  the cosine of x, where x is
	  given in radians.

	  double op_cos(double x);

      Check if: SYSTEM_COS

macro op_tan								markus

	  Defines a macro which returns the tangent of x, where x is
	  given in radians.

	  double op_tan(double x);

      Check if: SYSTEM_TAN

macro op_asin								markus

	  Defines a macro which calculates the arc sine of x; that
	  is the value whose sine is x.

	  double op_asin(double x);

      Check if: SYSTEM_ASIN

macro op_acos								markus

	  Defines a macro which calculates the arc cosine of x; that
	  is the value whose cosine is x.

	  double op_acos(double x);

      Check if: SYSTEM_ACOS

macro op_atan								markus

	  Defines a macro which calculates the arc tangent of x; that
	  is the value whose tangent is x.

	  double op_atan(double x);

      Check if: SYSTEM_ATAN

macro op_atan2								markus

	  Defines a macro which calculates the arc tangent of the two
	  variables x and y. It is similar to calculating the arc
	  tangent of y / x, except that the signs of both arguments
	  are used to determine the quadrant of the result.

	  double op_atan2(double y, double x);

      Check if: SYSTEM_ATAN2

macro op_srand								markus

	  Defines a macro which sets its argument as the seed for a
	  new sequence of pseudo-random integers to be returned by
	  op_rand().

	  void op_srand(unsigned int seed);

      Check if: SYSTEM_RAND

macro op_rand								markus

	  Defines a macro which function returns a pseudo-random integer
	  between 0 and RAND_MAX.

	  int op_rand();

      Check if: SYSTEM_RAND

macro op_isdigit							deprecated

	  Deprecated: Defined in modules/stdlib/include/opera_stdlib.h
	  Defines a macro which checks for a digit (0 through 9).

	  int op_isdigit(int c);

macro op_isxdigit							deprecated

	  Deprecated: Defined in modules/stdlib/include/opera_stdlib.h
	  Defines a macro which checks for a hexadecimal digits,
	  i.e. one of 0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F.

	  int op_isxdigit(int c);

macro op_isspace							deprecated

	  Deprecated: Defined in modules/stdlib/include/opera_stdlib.h
	  Defines a macro which checks for white-space characters.
	  In the "C" and "POSIX" locales, these are: space, form-feed
	  ('\f'), newline ('\n'), carriage return ('\r'),
	  horizontal tab ('\t'), and vertical tab ('\v').

	  int op_isspace(int c);

macro op_isupper							deprecated

	  Deprecated: Defined in modules/stdlib/include/opera_stdlib.h
	  Defines a macro which checks for an uppercase letter.

	  int op_isupper(int c);

macro op_isalnum							deprecated

	  Deprecated: Defined in modules/stdlib/include/opera_stdlib.h
	  Defines a macro which checks for an alphanumeric character.

	  int op_isalnum(int c);

macro op_isalpha							deprecated

	  Deprecated: Defined in modules/stdlib/include/opera_stdlib.h
	  Defines a macro which checks checks for an alphabetic character.

	  int op_isalpha(int c);

macro op_isprint							deprecated

	  Deprecated: Defined in modules/stdlib/include/opera_stdlib.h
	  Defines a macro which checks for any printable character including space.

	  int op_isprint(int c);

macro op_iscntrl							deprecated

	  Deprecated: Defined in modules/stdlib/include/opera_stdlib.h
	  Defines a macro which checks for a control character.

	  int op_iscntrl(int c);

macro op_ispunct							deprecated

	  Deprecated: Defined in modules/stdlib/include/opera_stdlib.h
	  Defines a macro which checks for any printable character which is not a
	  space or an alphanumeric character.

	  int op_ispunct(int c);

macro op_sprintf							markus

	  Defines a macro which produces output according to a format.

	  int op_sprintf(char* str, const char* format, ...);

      Check if: SYSTEM_SPRINTF

macro uni_sprintf						markus

	  Defines a macro which produces output according to a format.

	  int uni_sprintf(uni_char* str, const uni_char* format, ...);

      Check if: SYSTEM_UNI_SPRINTF

macro op_snprintf							markus

	  Defines a macro which writes output to the string str, under control of
	  the format string that specifies how subsequent arguments
	  are converted for output. It is similar to op_sprintf,
	  except that n specifies the maximum number of characters
	  to produce. The trailing null character is counted
	  towards this limit, so you should allocate at least n
	  characters for the string str.

	  int op_snprintf(char* str, size_t n, const char *format, ... );

	  Check if: SYSTEM_SNPRINTF

macro uni_snprintf							markus

	  Defines a macro which writes output to the string str, under control of
	  the format string that specifies how subsequent arguments
	  are converted for output. It is similar to uni_sprintf,
	  except that n specifies the maximum number of characters
	  to produce. The trailing null character is counted
	  towards this limit, so you should allocate at least n
	  characters for the string str.

	  int uni_snprintf(uni_char* str, size_t n, const uni_char *format, ... );

	  Check if: SYSTEM_UNI_SNPRINTF

macro op_vsprintf							markus

	  Defines a macro which is the equivalent of op_sprintf with the variable
	  argument list specified directly as for vprintf.

	  int op_vsprintf(char* str, const char* format, va_list ap);

      Check if: SYSTEM_VSPRINTF

macro uni_vsprintf							markus

	  Defines a macro which is the equivalent of uni_sprintf with the variable
	  argument list specified directly as for vprintf.

	  int uni_vsprintf(uni_char* str, const uni_char* format, va_list ap);

      Check if: SYSTEM_UNI_VSPRINTF

macro op_vsnprintf							markus

	  Defines a macro which is the equivalent of op_snprintf with the variable
	  argument list specified directly as for vprintf.

	  int op_vsnprintf(char* str, size_t n, const char* format, va_list ap);

      Check if: SYSTEM_VSNPRINTF

macro uni_vsnprintf							markus

	  Defines a macro which is the equivalent of uni_snprintf with the variable
	  argument list specified directly as for vprintf.

	  int uni_vsnprintf(uni_char* str, size_t n, const uni_char* format, va_list ap);

      Check if: SYSTEM_UNI_VSNPRINTF

macro op_sscanf								markus

	  Defines a macro which scans input according to a format.

	  int op_sscanf(const char* str, const char* format, ...);

      Check if: SYSTEM_SSCANF

macro uni_sscanf							markus

	  Defines a macro which scans input according to a format.

	  int uni_sscanf(const uni_char* str, const uni_char* format, ...);

      Check if: SYSTEM_UNI_SSCANF

macro op_vsscanf							roarl

	  Defines a macro which scans input according to a format.

	  int op_vsscanf(const char* str, const char* format, va_list ap);

	  Check if: SYSTEM_VSSCANF

macro op_tolower							deprecated

	  op_tolower is deprecated and provided by modules/stdlib.

macro op_toupper							deprecated

	  op_toupper is deprecated and provided by modules/stdlib.

macro op_time								markus

	  Defines a macro which returns the time since the Epoch (00:00:00 UTC,
	  January 1, 1970), measured in seconds. If t is non-NULL, the return
	  value is also stored in the memory pointed to by t.

	  time_t op_time(time_t* t);

      Check if: SYSTEM_TIME

macro op_localtime							markus

	  Defines a macro which returns the current time.
	  It corrects for the main time zone and possible alternate
	  ("daylight savings") time zone;

	  struct tm* op_localtime(const time_t* clock);

      Check if: SYSTEM_LOCALTIME

macro op_gmtime								markus

	  Defines a macro which converts the calendar time timep to broken-down
	  time representation, expressed in Coordinated Universal Time (UTC). It
	  may return NULL when the year does not fit into an integer.

	  struct tm* op_gmtime(const time_t* clock);

      Check if: SYSTEM_GMTIME

macro op_clock								deprecated

	  Core code should use g_op_time_info->GetRuntimeMS() instead of
	  op_clock().

macro CLOCKS_PER_SEC						deprecated

	  Core code should use g_op_time_info->GetRuntimeMS() instead of
	  op_clock().

macro op_mktime								markus

	  Defines a macro which converts a broken-down time structure,
	  expressed as local time, to calendar time representation.

	  time_t op_mktime(struct tm* timeptr);

      Check if: SYSTEM_MKTIME

macro op_qsort								markus

	  Defines a macro which sorts an array with nmemb elements of
	  size size. The base argument points to the start of the
	  array.

	  The contents of the array are sorted in ascending order
	  according to a comparison function pointed to by compar,
	  which is called with two arguments that point to the
	  objects being compared.

	  The comparison function must return an integer less than,
	  equal to, or greater than zero if the first argument is
	  considered to be respectively less than, equal to, or
	  greater than the second. If two members compare as equal,
	  their order in the sorted array is undefined.

	  void op_qsort(void* base, size_t nmemb, size_t size,
	                int (*compar)(const void*, const void*));

      Check if: SYSTEM_QSORT

macro op_bsearch							markus

	  Defines a macro which searches an array of nmemb objects,
	  the initial member of which is pointed to by base, for a
	  member that matches the object pointed to by key. The
	  size of each member of the array is specified by size.

	  The contents of the array should be in ascending sorted
	  order according to the comparison function referenced by
	  compar. The compar routine is expected to have two arguments
	  which point to the key object and to an array member,
	  in that order, and should return an integer less
	  than, equal to, or greater than zero if the key object is
	  found, respectively, to be less than, to match, or be
	  greater than the array member.

	  void* op_bsearch(const void* key, const void* base, size_t nmemb,
	                   size_t size, int (*compar)(const void*, const void*));

      Check if: SYSTEM_BSEARCH

macro op_setlocale							markus

	  Defines a macro which is used to set or query the program's
	  current locale. If locale is "C" or "POSIX", the current
	  locale is set to the portable locale.

	  If locale is "", the locale is set to the default locale
	  which is selected from the environment variable LANG.

	  The argument category determines which functions are
	  influenced by the new locale:

	  LC_ALL for all of the locale.

	  LC_COLLATE for the functions strcoll() and strxfrm().

	  LC_CTYPE for the character classification and conversion routines.

	  LC_MONETARY for localeconv().

	  LC_NUMERIC for the decimal character.

	  LC_TIME for strftime().

	  char* op_setlocale(int category, const char* locale);

	  Check if: SYSTEM_SETLOCALE

macro op_yield									markus

	  Implemented by the system if SYSTEM_YIELD is set to YES.
	  Otherwise the macro does nothing.

      Check if: SYSTEM_YIELD

macro op_ntohs									jl

	  Defines a macro that converts a 16-bit unsigned integer from
	  network byte order to host byte order.

      Check if: SYSTEM_NTOHS

macro op_ntohl									jl

	  Defines a macro that converts a 32-bit unsigned integer from
	  network byte order to host byte order.

      Check if: SYSTEM_NTOHL

macro op_htons									jl

	  Defines a macro that converts a 16-bit unsigned integer from
	  host byte order to network byte order.

      Check if: SYSTEM_HTONS

macro op_htonl									jl

	  Defines a macro that converts a 32-bit unsigned integer from
	  host byte order to network byte order.

      Check if: SYSTEM_HTONL

macro op_getenv									simonb

	  Defines a macro that is used to search the environment list to
	  find a specified environment variable name and return a pointer
	  to the corresponding value string. The macro should be defined
	  such that it can be used as

      const char* op_getenv(const char* name);

      The function provided by the op_getenv() macro returns a pointer
      to the value in the environment, or NULL if there is no match.

      Notes:
      - The strings in the environment list are of the form name=value.

      - As typically implemented, getenv() returns a pointer to a string within
        the environment list. The caller must take care not to modify this
        string, since that would change the environment of the process.

      - The implementation of op_getenv() is not required to be reentrant. The
        string pointed to by the return value of op_getenv() may be statically
        allocated, and can be modified by a subsequent call to op_getenv(),
        or op_putenv().

      - The specified argument name and the return value is expected
        to be specified in native encoding.

      Example: On a posix system a platform can define this macro as

      #include <stdlib.h>
      #define op_getenv(name)	getenv(name)

      Note: The posix function getenv() returns the type "char*", i.e. the
      return type is not const-qualified. However the caller of this macro
      should always treat the return value as if const-qualified; in
      particular, the return value should not be saved in a local variable
      which lacks const-qualification.
      With the above declaration the compiler does not issue an error "invalid
      conversion from 'const char*' to 'char*'" for code like
        char* home = op_getenv("HOME");
      A type-safe declaration can be done as

      #include <stdlib.h>
      inline const char* my_getenv(const char* name) { return getenv(name); }
      #define op_getenv(name) my_getenv(name)

	  Check if: SYSTEM_GETENV

macro op_putenv									simonb

      The macro should be defined such that it can be used as:

      int op_putenv(char* string);

      The function provided by the op_putenv() macro adds or changes the
      value of environment variables. The argument string is of the form
      name=value. If name does not already exist in the environment, then
      string is added to the environment. If name does exist, then the
      value of name in the environment is changed to value. The string
      pointed to by string becomes part of the environment, so altering
      the string changes the environment.

      Return value: zero on success, or non-zero if an error occurs.

      Notes:
      - The implementation of op_putenv() is not required to be reentrant.

      - The string passed in as parameter must point to memory which
        shall remain available until either process termination or a
        later call to op_putenv() with the same "name=" prefix.

      Example: On a posix system a platform can define this macro as

      #include <stdlib.h>
      #define op_putenv(string)	putenv(string)

	  Check if: SYSTEM_PUTENV

macro op_force_inline							axel

	  Defines a macro that instructs the compiler to inline a function
	  no matter what. The macro is used before declaring the function
	  and after a possible "static" keyword.
	  Example:
		op_force_inline void MyFunction1(int foo);
		static op_force_inline int MyFunction2();
		class MyClass {
		public:
		  static op_force_inline char* MyMethod() { ... }
		  op_force_inline int* MyMethod2() const { ... }
		};

      Check if: SYSTEM_FORCE_INLINE

macro OP_PRODUCT_NAME							andersr

	  Define a short, lowercase name for the product (const char *).

	  Examples:

	   #define OP_PRODUCT_NAME "desktop"   // for regular Desktop builds
	   #define OP_PRODUCT_NAME "core-gogi" // for Core-GOGI builds,
	   #define OP_PRODUCT_NAME "mobile"    // for Opera Mobile builds

	  The string will be used only for display purposes, and as such
	  changing it from version to version (of the same product) will not
	  cause any catastrophic failures.

	  Nevertheless, the string should not include information about the
	  operating system, nor any version information. This information is
	  already available through other means (pi, UA).

	  It does also not need to state the fact that we are running Opera.
	  (I.e. define as "mobile", not "Opera Mobile").

	  One possible use case for this is a test system capable of
	  testing various different products. This system may wish to show
	  recent test results in a table, with columns for product name,
	  OS, and version. If OP_PRODUCT_NAME were inappropriately defined
	  as "Opera Desktop 11.10 (Win32)", for instance, this test system
	  would either have to show the redundant information as-is, or try
	  to guess which part is the product name and extract it. Neither
	  approach is optimal.

macro op_setjmp									arjanl

	  Defines a macro that saves the calling environment into a variable.

	  The macro should be defined such that it can be used as:

	    int op_setjmp(jmp_buf env);

	  On a C90-conformant system a platform can define this macro as:

	    #include <setjmp.h>
	    #define op_setjmp(env) setjmp(env)

	  Posix platforms may offer versions of this function that don't save the
	  signal mask. If available those versions are preferred, because their
	  performance is better, and Opera's core code doesn't change signal masks
	  inside leaving functions.

	  Check if: SYSTEM_SETJMP

macro op_longjmp								arjanl

	  Defines a macro that restores an environment saved by its most recent
	  invocation of the op_setjmp macro.

	  The macro should be defined such that it can be used as:

	    void op_longjmp(jmp_buf env, int val);

	  On a C90-conformant system a platform can define this macro as:

	    #include <setjmp.h>
	    #define op_longjmp(env, val) longjmp(env, val)

	  Posix platforms may offer versions of this function that don't restore
	  the signal mask. If available those versions are preferred, because their
	  performance is better, and Opera's core code doesn't change signal masks
	  inside leaving functions.

	  Check if: SYSTEM_SETJMP
