/* -*- mode: c++; tab-width: 4; c-basic-offset: 4 -*- */

group "layout.hit_testing_traversal_object";

require init;

include "modules/layout/traverse/traverse.h";
include "modules/layout/box/box.h";
include "modules/layout/box/inline.h";
include "modules/layout/box/tables.h";
include "modules/layout/content/scrollable.h";
include "modules/doc/frm_doc.h";
include "modules/logdoc/htm_elm.h";
include "modules/dochand/win.h";
include "modules/pi/OpWindow.h";

global
{
	class ElementID : public Link
	{
	public:
		ElementID(const uni_char* _id) : Link(), id(_id) {}
		const uni_char* id;
	};

	class ST_HitTestingTraversalObject : public HitTestingTraversalObject
	{
	public:

		ST_HitTestingTraversalObject(FramesDocument* doc, const OpRect& area, BOOL disable_clipping = FALSE) : HitTestingTraversalObject(doc, disable_clipping)
		{
			this->area.left = area.x;
			this->area.right = area.Right();
			this->area.top = area.y;
			this->area.bottom = area.Bottom();
			traverse_positioned_elm_call_count = 0;
		}

		virtual BOOL EnterVerticalBox(LayoutProperties* parent_lprops, LayoutProperties*& layout_props, VerticalBox* box, TraverseInfo& traverse_info)
		{
			BOOL result = HitTestingTraversalObject::EnterVerticalBox(parent_lprops, layout_props, box, traverse_info);

			if (result)
			{
				const uni_char* id = box->GetHtmlElement()->GetId();

				if (id)
				{
					ElementID* elm = OP_NEW(ElementID, (id));

					if (elm)
						elm->Into(&m_hit_elems);
					else
						SetOutOfMemory();
				}
			}

			return result;
		}

		virtual BOOL	EnterInlineBox(LayoutProperties* layout_props, InlineBox* box, const RECT& box_area, LineSegment& segment, BOOL start_of_box, BOOL end_of_box, LayoutCoord baseline, TraverseInfo& traverse_info)
		{
			BOOL result = HitTestingTraversalObject::EnterInlineBox(layout_props, box, box_area, segment, start_of_box, end_of_box, baseline, traverse_info);

			if (result)
			{
				const uni_char* id = box->GetHtmlElement()->GetId();

				if (id)
				{
					ElementID* elm = OP_NEW(ElementID, (id));

					if (elm)
						elm->Into(&m_hit_elems);
					else
						SetOutOfMemory();
				}
			}

			return result;
		}

		virtual BOOL	EnterTableRow(TableRowBox* row)
		{
			BOOL result = HitTestingTraversalObject::EnterTableRow(row);

			if (result)
			{
				const uni_char* id = row->GetHtmlElement()->GetId();

				if (id)
				{
					ElementID* elm = OP_NEW(ElementID, (id));

					if (elm)
						elm->Into(&m_hit_elems);
					else
						SetOutOfMemory();
				}
			}

			return result;
		}

		virtual BOOL	TraversePositionedElement(HTML_Element* element, HTML_Element* containing_element)
		{
			traverse_positioned_elm_call_count++;
			return HitTestingTraversalObject::TraversePositionedElement(element, containing_element);
		}

		BOOL			Exists(const char* id)
		{
			Link* cur =	m_hit_elems.First();

			while (cur)
			{
				if (static_cast<ElementID*>(cur)->id && uni_strcmp(id, static_cast<ElementID*>(cur)->id) == 0)
					return TRUE;

				cur = cur->Suc();
			}

			return FALSE;
		}

		unsigned int GetTraversePositionedElementCallCount() { return traverse_positioned_elm_call_count; }

	private:
		AutoDeleteHead m_hit_elems;

		/** Used to check that we don't return to z root during the traverse
			more often than expected. */

		unsigned int traverse_positioned_elm_call_count;
	};
}

test("PRECONDITION: Window big enough.")
{
	OpWindow* op_win = state.GetWindow() ?  state.GetWindow()->GetOpWindow() : NULL;
	UINT32 w, h;

	verify(op_win);
	op_win->GetInnerSize(&w, &h);

	/* Magic numbers. Too small layout viewport affects the layout of the tested documents in various situations,
	   in a way that boxes do not have the sizes that are expected in particular tests.
	   Adjust if needed and make the tests depend on that precondition if needed. */
	verify(w >= 400 && h >= 300);
}

html
{
//! <!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;}
//!</style>
//!</head>
//!<body>
//!
//!<p style="height:30px; font-size:20px;"><b id="upper">upper</b></p>
//!
//!<div style="overflow:auto; width:100px; height:200px">
//!
//!<table style="border-spacing:0px">
//!<tr>
//!<td>
//!<div id="red" style="width:100px; height:100px; background-color:red;"></div>
//!</td>
//!<td>
//!<div id="blue" style="width:100px; height:100px; background-color:blue;"></div>
//!</td>
//!</tr>
//!
//!<tr>
//!<td>
//!<div id="green" style="width:100px; height:100px; background-color:green;"></div>
//!</td>
//!<td>
//!<div id="yellow" style="width:100px; height:100px; background-color:yellow;"></div>
//!</td>
//!</tr>
//!
//!<tr>
//!<td>
//!<div id="black" style="width:100px; height:100px; background-color:black;"></div>
//!</td>
//!<td>
//!<div id="gray" style="width:100px; height:100px; background-color:gray;"></div>
//!</td>
//!</tr>
//!
//!</table>
//!
//!</div>
//!
//!<p style="height:30px; font-size:20px;"><b id="bottom">bottom</b></p>
//!
//!</body>
//!</html>
}
test ("scrollable clipping, different areas")
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10000, 10000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("upper") == TRUE);
	verify(hit_testing_obj.Exists("bottom") == TRUE);

	verify(hit_testing_obj.Exists("blue") == FALSE);
	verify(hit_testing_obj.Exists("yellow") == FALSE);
	verify(hit_testing_obj.Exists("black") == FALSE);
	verify(hit_testing_obj.Exists("gray") == FALSE);
	verify(hit_testing_obj.Exists("red") == TRUE);
	verify(hit_testing_obj.Exists("green") == TRUE);

	ST_HitTestingTraversalObject hit_testing_obj1(state.doc, OpRect(0, 131, 200, 200));

	stat = hit_testing_obj1.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj1.Exists("upper") == FALSE);
	verify(hit_testing_obj1.Exists("bottom") == TRUE);

	verify(hit_testing_obj1.Exists("red") == FALSE);
	verify(hit_testing_obj1.Exists("blue") == FALSE);
	verify(hit_testing_obj1.Exists("yellow") == FALSE);
	verify(hit_testing_obj1.Exists("black") == FALSE);
	verify(hit_testing_obj1.Exists("gray") == FALSE);
	verify(hit_testing_obj1.Exists("green") == TRUE);

	ST_HitTestingTraversalObject hit_testing_obj2(state.doc, OpRect(0, 231, 200, 200));

	stat = hit_testing_obj2.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj2.Exists("upper") == FALSE);
	verify(hit_testing_obj2.Exists("bottom") == TRUE);

	verify(hit_testing_obj2.Exists("red") == FALSE);
	verify(hit_testing_obj2.Exists("blue") == FALSE);
	verify(hit_testing_obj2.Exists("yellow") == FALSE);
	verify(hit_testing_obj2.Exists("black") == FALSE);
	verify(hit_testing_obj2.Exists("gray") == FALSE);
	verify(hit_testing_obj2.Exists("green") == FALSE);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;}
//!a {width:60px; height:30px; font-size:20px; background-color:green;
//!			display:block; position:absolute; }
//!#not_clipped1 {left:150px; top:150px;}
//!#not_clipped2 {left:150px; top:250px;}
//!</style>
//!</head>
//!<body>
//!
//!<div style="overflow:hidden; width:100px; height:100px">
//!
//!<a href="#" id="not_clipped1">Link</a>
//!
//!<div id="red1" style="width:100px; height:100px; background-color:red;"></div>
//!<div id="blue1" style="width:100px; height:100px; background-color:blue;"></div>
//!
//!</div>
//!
//!<div style="overflow:auto; width:100px; height:100px">
//!
//!<a href="#" id="not_clipped2">Link</a>
//!
//!<div id="red2" style="width:100px; height:100px; background-color:red;"></div>
//!<div id="blue2" style="width:100px; height:100px; background-color:blue;"></div>
//!
//!</div>
//!
//!</body>
//!</html>
}
test ("clipping affects/doesn't affect target")
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(-1000, -1000, 10000, 10000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("red1") == TRUE);
	verify(hit_testing_obj.Exists("blue1") == FALSE);
	verify(hit_testing_obj.Exists("not_clipped1") == TRUE);
	verify(hit_testing_obj.Exists("red2") == TRUE);
	verify(hit_testing_obj.Exists("blue2") == FALSE);
	verify(hit_testing_obj.Exists("not_clipped2") == TRUE);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;}
//!table { border-spacing:0px; }
//!</style>
//!</head>
//!<body>
//!
//!<div style="overflow:auto; width:200px; height:200px">
//!
//!<table>
//!<tr>
//!<td>
//!<div id="red" style="width:100px; height:100px; background-color:red;"></div>
//!</td>
//!<td>
//!<div id="green" style="width:100px; height:100px; background-color:green;"></div>
//!</td>
//!<td>
//!<div id="blue" style="width:100px; height:100px; background-color:blue;"></div>
//!</td>
//!</tr>
//!</table>
//!
//!<div style="overflow:hidden; width:150px; height:200px;">
//!<table>
//!<tr>
//!<td>
//!<div id="yellow" style="width:100px; height:100px; background-color:yellow;"></div>
//!</td>
//!<td>
//!<div id="lime" style="width:50px; height:100px; background-color:lime;"></div>
//!</td>
//!<td>
//!<div id="teal" style="width:100px; height:100px; background-color:teal;"></div>
//!</td>
//!</tr>
//!<tr>
//!<td>
//!<div id="orange" style="width:100px; height:100px; background-color:orange;"></div>
//!</td>
//!<td>
//!<div id="olive" style="width:50px; height:100px; background-color:olive;"></div>
//!</td>
//!<td>
//!<div id="black" style="width:100px; height:100px; background-color:black;"></div>
//!</td>
//!</tr>
//!</table>
//!</div>
//!
//!</div>
//!
//!</body>
//!</html>
}
test ("clip rects stacking")
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(101, 0, 1000, 1000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("red") == FALSE);
	verify(hit_testing_obj.Exists("green") == TRUE);
	verify(hit_testing_obj.Exists("blue") == FALSE);
	verify(hit_testing_obj.Exists("yellow") == FALSE);
	verify(hit_testing_obj.Exists("lime") == TRUE);
	verify(hit_testing_obj.Exists("teal") == FALSE);
	verify(hit_testing_obj.Exists("orange") == FALSE);
	verify(hit_testing_obj.Exists("olive") == FALSE);
	verify(hit_testing_obj.Exists("black") == FALSE);
}

test ("clipping disabled")
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(101, 0, 1000, 1000), TRUE);

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("red") == FALSE);
	verify(hit_testing_obj.Exists("green") == TRUE);
	verify(hit_testing_obj.Exists("blue") == TRUE);
	verify(hit_testing_obj.Exists("yellow") == FALSE);
	verify(hit_testing_obj.Exists("lime") == TRUE);
	verify(hit_testing_obj.Exists("teal") == TRUE);
	verify(hit_testing_obj.Exists("orange") == FALSE);
	verify(hit_testing_obj.Exists("olive") == TRUE);
	verify(hit_testing_obj.Exists("black") == TRUE);
}

test("AHEM")
{
	short font_number = styleManager->GetFontNumber(UNI_L("AHEM"));
	verify(font_number != -1);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;
//!	font-family:'AHEM';
//!}
//!
//!#transformed
//!{
//!	width:282px;
//!	height:282px;
//!	transform:translate(59px,59px) rotate(-45deg);
//!}
//!
//!#container
//!{
//!	overflow:hidden;
//!	width:200px;
//!	height:200px;
//!	background-color:red;
//!}
//!</style>
//!</head>
//!<body>
//!<div id="container">
//!
//!<div id="transformed">
//!
//!<div style="width:282px; height:141px; max-height:141px; background-color:yellow;">
//!<p style="height:25px; font-size:16px;"><b id="not_clipped">not clipped</b></p>
//!<p style="margin-top: 40px; height:20px; font-size:12px;"><b id="clipped_but_line_too_long">Incli</b></p>
//!<p style="margin-top: 20px; margin-left: 210px; height:20px; font-size:12px;">
//!<b id="clipped_with_new_method">Incli</b></p>
//!</div>
//!
//!<div style="width:282px; height:141px; background-color:lime">
//!<p style="height:25px; font-size:16px;"><b id="clipped">Clipped fully</b></p>
//!</div>
//!
//!</div>
//!
//!<p style="height:25px; font-size:16px;"><b id="not_transformed">xxx</b></p>
//!
//!</div>
//!
//!<p style="height:25px; font-size:16px;"><b id="outside_container">xxx</b></p>
//!
//!</body>
//!</html>
}
test ("clip rect after transform")
	require CSS_TRANSFORMS;
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 1000, 1000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("not_clipped") == TRUE);

	/** The below two are outside the area intersected with clipping rect, but they are distinguished
		from the 'clipped' <b>, because they would yield false positive, if we would make an intersection
		check only againts the halfplanes of the local rect of the element against the area intersected
		with the previous clip rect, that is in doc coordinates. See VisualDeviceTransform::TestIntersection. */
	verify(hit_testing_obj.Exists("clipped_with_new_method") == FALSE);

	/** Although, the inline box of the <b> element does not intersect the clipping rect here,
		the line, that it belongs to do. And because AreaTraversalObject does not make intersection checks on
		inline boxes, we will enter here. */
	verify(hit_testing_obj.Exists("clipped_but_line_too_long") == TRUE);

	verify(hit_testing_obj.Exists("clipped") == FALSE);
	verify(hit_testing_obj.Exists("not_transformed") == FALSE);
	verify(hit_testing_obj.Exists("outside_container") == TRUE);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;
//!	font-family:'AHEM';
//!}
//!
//!#container
//!{
//!	overflow:auto;
//!	width:100px;
//!	height:100px;
//!	background-color:red;
//!}
//!</style>
//!</head>
//!<body>
//!<div id="container">
//!
//!<span id="first_line" style="font-size:20px">xxxxxxxxxx</span> <br/> <br />
//!
//!<span id="second_line" style="font-size:20px">xxxxxxxxxx</span>
//!
//!</div>
//!
//!</body>
//!</html>
}
test ("single point area in and outside clip rect")
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(10, 10, 10, 10));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first_line") == TRUE);
	verify(hit_testing_obj.Exists("second_line") == FALSE);

	ST_HitTestingTraversalObject hit_testing_obj1(state.doc, OpRect(150, 10, 150, 10));

	stat = hit_testing_obj1.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	//The area is within the line, but outside the clipping rect pushed after scrollable entering
	verify(hit_testing_obj1.Exists("first_line") == FALSE);
	verify(hit_testing_obj1.Exists("second_line") == FALSE);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;}
//!
//!#transformed
//!{
//!	width:200px;
//!	height:50px;
//!	transform:translate(0px,80px) rotate(-45deg);
//!	background-color:red;
//!	overflow:auto;
//!}
//!
//!#clipped
//!{
//!	margin-left:30px;
//!	width:50px;
//!	height:150px;
//!	background-color:yellow;
//!}
//!
//!</style>
//!</head>
//!<body>
//!
//!<div id="transformed">
//!
//!<div id="clipped">
//!</div>
//!
//!</div>
//!
//!<!--<div style="width:50px; height:100px; position:absolute; left:110px; top:80px; background-color:black;">
//!</div>-->
//!
//!</body>
//!</html>
}
test ("a box, the area and clip rect triple in 45deg transform")
	require CSS_TRANSFORMS;
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(110, 80, 50, 100));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("clipped") == FALSE);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;
//!	font-family:'AHEM';
//!}
//!table
//!{
//!	border-spacing : 0px;
//!}
//!#absolute_div
//!{
//!	position:absolute;
//!	left:300px;
//!	top:200px;
//!	width:200px;
//!	height:100px;
//!	background-color:red;
//!	clip: rect(40px, 200px, 100px, 0px);
//!}
//!
//!tr.collapse
//!{
//!	visibility:collapse;
//!}
//!
//!td.single
//!{
//!	width:100px;
//!	height:100px;
//!	background-color:blue;
//!}
//!
//!td.double
//!{
//!	width:100px;
//!	height:200px;
//!	background-color:red;
//!}
//!
//!</style>
//!</head>
//!<body>
//!
//!<div id="absolute_div">
//!<span id="first_line" style="font-size:20px">xxxxxxxx</span> <br/> <br /> <br />
//!
//!<span id="second_line" style="font-size:20px">xxxxxxxx</span>
//!</div>
//!
//!<table>
//!
//!<tr>
//!<td class="single">
//!</td>
//!<td rowspan="2" class="double">
//!<span id="collapsed1" style="font-size:20px">xxxx</span> <br/> <br /> <br />
//!
//!<span id="collapsed2" style="font-size:20px">xxxx</span>
//!</td>
//!</tr>
//!
//!<tr class="collapse">
//!<td class="single">
//!</td>
//!</tr>
//!
//!</table>
//!
//!</body>
//!</html>
}
test ("absolute positioned box clipping")
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(300, 200, 200, 100));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first_line") == FALSE);
	verify(hit_testing_obj.Exists("second_line") == TRUE);
}

test ("partially collapsed table cell clipping")
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 200, 200));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("collapsed1") == TRUE);
	verify(hit_testing_obj.Exists("collapsed2") == FALSE);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;
//!	font-family:'AHEM';
//!}
//!
//!#transformed
//!{
//!	width:282px;
//!	height:70px;
//!	transform-origin: top left;
//!	transform:translate(0px,200px) rotate(-45deg);
//!	background-color:red;
//!	overflow:auto;
//!}
//!
//!#second_transformed
//!{
//!	width:50px;
//!	height:280px;
//!	transform-origin: top left;
//!	transform:translate(230px,20px) rotate(45deg);
//!	background-color:yellow;
//!}
//!</style>
//!</head>
//!<body>
//!
//!<div style="width:400px; height:400px;">
//!<div id="transformed">
//!
//!<div id="second_transformed">
//!<span id="not_clipped" style="font-size:20px">xx</span>
//!
//!<p style="height:25px; margin-top:80px;"><span style="font-size:20px;" id="in_area">xx</span></p>
//!<p style="height:25px; margin-top:100px;"><span style="font-size:20px;" id="clipped">xx</span></p>
//!</div>
//!
//!<p style="position:relative; top:-1px; height:25px; font-size:20px;"><b id="outside_second_transformed">xxxx</b></p>
//!
//!</div>
//!</div>
//!
//!<p style="position:relative; top:-1px; height:25px; font-size:20px;"><b id="outside_transformed">xxxx</b></p>
//!
//!</body>
//!</html>
}
test ("two transforms, clip rect after first")
	require CSS_TRANSFORMS;
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10000, 10000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("not_clipped") == TRUE);

	/* NOTE: This one is actually outside the clip rect. The fact it is TRUE, is because when
	we intersect the area with the clip rect before pushing the second transform, the clip rect
	is BBoxed before that (area is in coords before the first transform), so it is too big */
	verify(hit_testing_obj.Exists("in_area") == TRUE);

	verify(hit_testing_obj.Exists("clipped") == FALSE);

	verify(hit_testing_obj.Exists("outside_second_transformed") == FALSE);
	verify(hit_testing_obj.Exists("outside_transformed") == TRUE);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;
//!	font-family:'AHEM';
//!	line-height:20px;
//!}
//!table
//!{
//!	border-spacing : 0px;
//!	transform-origin: top left;
//!	transform: translate(100px,150px) rotate(-15deg);
//!	max-height:400px;
//!}
//!
//!tr.collapse
//!{
//!	visibility:collapse;
//!}
//!
//!td.single
//!{
//!	width:200px;
//!	height:200px;
//!	background-color:blue;
//!}
//!
//!td.double
//!{
//!	background-color:red;
//!	overflow:visible;
//!	vertical-align:top;
//!}
//!
//!div.inside_double
//!{
//!	width:200px;
//!	height:400px;
//!	max-height:400px;
//!}
//!
//!div.second_transform
//!{
//!	margin-top:105px;
//!	width:100px;
//!	height:150px;
//!	background-color:lime;
//!	transform: skewX(15deg) scaleY(2) translate(200px,20px);
//!}
//!
//!</style>
//!</head>
//!<body>
//!
//!<table>
//!
//!<tr>
//!<td class="single">
//!</td>
//!<td rowspan="2" class="double">
//!<div class="inside_double">
//!<span id="text_visible" style="font-size:20px">xxxxxxxxxxxx</span>  <br/>
//!
//!<div class="second_transform">
//!<p style="margin-left:60px;"><span id="in_clip_rect" style="font-size:20px">xx</span></p>
//!<br /> <br />
//!<span id="false_positive" style="font-size:20px">xxxx</span>
//!<br /> <br /> <br /> <br /> <br /> <br />
//!<span id="outside_clip_rect" style="font-size:20px">xxxx</span>
//!</div>
//!
//!<br/> <br/> <br/> <br/> <br/>
//!<span id="text_collapsed" style="font-size:20px">xxxxxxxxxxx</span>
//!</div>
//!</td>
//!</tr>
//!
//!<tr class="collapse">
//!<td class="single">
//!</td>
//!</tr>
//!
//!</table>
//!
//!<!--<div style="position:absolute; top:130px; left:560px; width:10px; height:10px; background-color:yellow"></div>-->
//!<!--<div style="position:absolute; top:470px; left:690px; width:10px; height:10px; background-color:yellow"></div>-->
//!
//!</body>
//!
//!</html>
}
test ("transforming clip rect of row collapsed table cell")
	require CSS_TRANSFORMS;
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10000, 10000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("in_clip_rect") == TRUE);

	/* NOTE: This one is actually outside the clip rect. The fact it is TRUE, is because when
	we intersect the area with the clip rect before pushing the second transform, the clip rect
	is BBoxed before that (area is in coords before the first transform), so it is too big */
	verify(hit_testing_obj.Exists("false_positive") == TRUE);

	verify(hit_testing_obj.Exists("outside_clip_rect") == FALSE);

	verify(hit_testing_obj.Exists("text_collapsed") == FALSE);
	verify(hit_testing_obj.Exists("text_visible") == TRUE);
}

test ("single point area - going through clipping and transforms")
	require CSS_TRANSFORMS;
	require success "AHEM";
	require success "PRECONDITION: Window big enough.";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	/* Single point area, only on the "in_clip_rect" span with text. */
	ST_HitTestingTraversalObject hit_testing_obj1(state.doc, OpRect(560, 130, 1, 1));

	OP_STATUS stat = hit_testing_obj1.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj1.Exists("in_clip_rect") == TRUE);
	verify(hit_testing_obj1.Exists("false_positive") == FALSE);
	verify(hit_testing_obj1.Exists("outside_clip_rect") == FALSE);
	verify(hit_testing_obj1.Exists("text_collapsed") == FALSE);
	verify(hit_testing_obj1.Exists("text_visible") == FALSE);

	/* Single point area, only on the "outside_clip_rect" span with text. */
	ST_HitTestingTraversalObject hit_testing_obj2(state.doc, OpRect(690, 470, 1, 1));

	stat = hit_testing_obj2.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj2.Exists("in_clip_rect") == FALSE);
	verify(hit_testing_obj2.Exists("false_positive") == FALSE);
	verify(hit_testing_obj2.Exists("outside_clip_rect") == FALSE);
	verify(hit_testing_obj2.Exists("text_collapsed") == FALSE);
	verify(hit_testing_obj2.Exists("text_visible") == FALSE);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;
//!	font-family:'AHEM';
//!}
//!table
//!{
//!	border-spacing: 0px;
//!	transform-origin: top left;
//!	transform: translate(100px,100px) scaleX(2);
//!}
//!
//!col.collapsed
//!{
//!	visibility:collapse;
//!}
//!
//!td.single
//!{
//!	width:100px;
//!	height:100px;
//!	background-color:blue;
//!}
//!
//!td.double
//!{
//!	width:200px;
//!	height:100px;
//!
//!	background-color:red;
//!	vertical-align:top;
//!}
//!
//!div.second_transform
//!{
//!	width:170px;
//!	height:75px;
//!	background-color:lime;
//!	transform: translate(10px, 10px) rotate(5deg);
//!}
//!
//!</style>
//!</head>
//!<body>
//!
//!<table>
//!<col />
//!<col class="collapsed" />
//!
//!<tr>
//!<td colspan="2" class="double">
//!
//!<div class="second_transform">
//!<span id="in_clip_rect" style="font-size:20px">xxx</span>
//!<br />
//!<div style="margin-left:150px;"><span id="outside_clip_rect" style="font-size:20px;">x</span></div>
//!</div>
//!
//!</td>
//!</tr>
//!
//!<tr>
//!<td class="single">
//!</td>
//!<td class="single">
//!</td>
//!</tr>
//!
//!</table>
//!
//!</body>
//!
//!</html>
}
test ("transforming clip rect of column collapsed table cell")
	require CSS_TRANSFORMS;
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10000, 10000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("in_clip_rect") == TRUE);
	verify(hit_testing_obj.Exists("outside_clip_rect") == FALSE);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;
//!	font-family:'AHEM';
//!}
//!
//!#container
//!{
//!	width:100px;
//!	height:100px;
//!}
//!
//!#empty_transform
//!{
//!	transform:scale(0);
//!}
//!
//!</style>
//!</head>
//!<body>
//!<div id="container">
//!
//!<span id="empty_transform">xxx</span>
//!
//!</div>
//!
//!</body>
//!
//!</html>
}
test ("empty transform")
	require CSS_TRANSFORMS;
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 1, 1));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("container") == TRUE);

	// Should not enter any box which is in the transform context, that empties rectangles
	verify(hit_testing_obj.Exists("empty_transform") == FALSE);
}

html
{
//!<!DOCTYPE html>
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;
//!}
//!
//!#transformed
//!{
//!	width:200px;
//!	height:200px;
//!	transform-origin: top left;
//!	transform:skewX(89.99999deg);
//!	background-color:yellow;
//!}
//!
//!#second_transform
//!{
//!	width:100px;
//!	height:100px;
//!	transform-origin: top left;
//!	transform:scaleX(1);
//!	background-color:green;
//!}
//!
//!</style>
//!</head>
//!<body>
//!
//!<div id="transformed">
//!<div id="second_transform">
//!</div>
//!</div>
//!
//!</body>
//!</html>
}
test ("infinite transform")
	require CSS_TRANSFORMS;
	disabled;
	/** This test is about a known bug - in case of a transform, which matrix has very big values (it 'infinitely'
		enlarges rects on at least one axis), the int overflow may occur. That is what happens here. This test
		fails and triggers asserts. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10000, 10000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	/** Should not enter any box which is in an 'infinite' transform. Due to precision issues and integer pixel representation,
		such box is not visible at all after painting. */
	verify(hit_testing_obj.Exists("transformed") == FALSE);
	verify(hit_testing_obj.Exists("second_transform") == FALSE);
}

html
{
//!<html>
//!<head>
//!<style>
//!* { margin:0;padding:0;
//!}
//!
//!#transformed
//!{
//!	width:200px;
//!	height:200px;
//!	transform-origin: top left;
//!	transform:skewX(89.99999deg);
//!	background-color:yellow;
//! overflow:auto;
//!}
//!
//!#second_transform
//!{
//!	width:100px;
//!	height:100px;
//!	transform-origin: top left;
//!	transform:scaleX(1);
//!	background-color:green;
//!}
//!
//!div.clipping_container
//!{
//!	width:10000px;
//!	height:10000px;
//!	max-height:10000px;
//!	overflow:hidden;
//!}
//!
//!</style>
//!</head>
//!<body>
//!
//!<div class="clipping_container">
//!<div id="transformed">
//!<div id="second_transform">
//!</div>
//!</div>
//!</div>
//!
//!</body>
//!</html>
}
test ("infinite transform clip rect pushed")
	require CSS_TRANSFORMS;
	disabled;
	/** Like the preceding test. Additionally it introduces clip rects - one before the first transform,
		second one after first transform, but before the second one. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10000, 10000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	/** Should not enter any box which is in an 'infinite' transform. Due to precision issues and integer pixel representation,
		such box is not visible at all after painting. */
	verify(hit_testing_obj.Exists("transformed") == FALSE);
	verify(hit_testing_obj.Exists("second_transform") == FALSE);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style type="text/css">
//!
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font-size:20px;
//!	font-family:'AHEM';
//!}
//!
//!table
//!{
//!	table-layout:fixed;
//!	width:100px;
//!	background:lime;
//!	overflow:hidden;
//!	display:table;
//!}
//!
//!td
//!{
//!	vertical-align:top;
//!	max-width:50px;
//!	height:30px;
//!}
//!
//!td.upper
//!{
//!	padding-left:60px;
//!}
//!</style>
//!</head>
//!
//!<body>
//!
//!<table>
//!	<tr>
//!		<td></td>
//!		<td class="upper"><div id="not_hit">X</div></td>
//!	</tr>
//!	<tr>
//!	<td>XX&nbsp;<span id="hit">X</span></td>
//!	<td></td>
//!	</tr>
//!</table>
//!
//!</body>
//!</html>
}
test ("block level table with overflow:hidden")
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10000, 10000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("not_hit") == FALSE);
	verify(hit_testing_obj.Exists("hit") == TRUE);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style type="text/css">
//!
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font-size:20px;
//!	font-family:'AHEM';
//!}
//!
//!table
//!{
//!	table-layout:fixed;
//!	width:100px;
//!	background:lime;
//!	overflow:hidden;
//!	display:inline-table;
//!}
//!
//!td
//!{
//!	vertical-align:top;
//!	max-width:50px;
//!	height:30px;
//!}
//!
//!td.upper
//!{
//!	padding-left:60px;
//!}
//!</style>
//!</head>
//!
//!<body>
//!X<table>
//!	<tr>
//!		<td></td>
//!		<td class="upper"><div id="not_hit">X</div></td>
//!	</tr>
//!	<tr>
//!	<td>XX&nbsp;<span id="hit">X</span></td>
//!	<td></td>
//!	</tr>
//!</table>
//!
//!</body>
//!</html>
}
test ("inline table with overflow:hidden")
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10000, 10000));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("not_hit") == FALSE);
	verify(hit_testing_obj.Exists("hit") == TRUE);
}

/* BEGIN: The subgroup of selftests inspired by CORE-45142 that covers the
   involved code.
   NOTE: Most of them are really testing just the AreaTraversalObject,
   but here we have all the useful utility code. */

subtest PositionedInlinesWithContainingBlock(const OpRect& area, BOOL hit_first)
{
	FramesDocument* doc = state.doc;
	verify(doc);
	HTML_Element* doc_root = doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(doc, area);

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first") == hit_first);
	verify(hit_testing_obj.Exists("outside_area") == FALSE);
	verify(hit_testing_obj.Exists("inside_area") == TRUE);
	verify(hit_testing_obj.GetTraversePositionedElementCallCount() == 1);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!#first
//!{
//!	position:relative;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!	margin-left:19px;
//!}
//!
//!span
//!{
//!	position:relative;
//!}
//!
//!#outside_area
//!{
//!	left:20px;
//!}
//!
//!#inside_area
//!{
//!	top:-11px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div id="first">
//!</div>
//!<span id="outside_area">X</span><br>
//!<span id="inside_area">X</span>
//!</body>
//!</html>
}
test("Positioned inlines with containing block calculated 1")
	// Positioned inlines in the same container.
	require success "AHEM";
{
	verify(PositionedInlinesWithContainingBlock(OpRect(0, 0, 20, 20), TRUE));
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!#first
//!{
//!	position:relative;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!span
//!{
//!	position:relative;
//!}
//!
//!#outside_area
//!{
//!	left:20px;
//!}
//!
//!#inside_area
//!{
//!	top:-11px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div id="first">
//!</div>
//!<div>
//!<span id="outside_area">X</span><br>
//!<span id="inside_area">X</span>
//!</div>
//!</body>
//!</html>
}
test("Positioned inlines with containing block calculated 2")
	// Positioned inlines in another, logically further container.
	require success "AHEM";
{
	verify(PositionedInlinesWithContainingBlock(OpRect(0, 0, 20, 20), TRUE));
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!div.outer
//!{
//!	margin-left:19px;
//!}
//!
//!#first
//!{
//!	position:relative;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!span
//!{
//!	position:relative;
//!}
//!
//!#outside_area
//!{
//!	left:20px;
//!}
//!
//!#inside_area
//!{
//!	top:-11px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div class="outer">
//!<div id="first">
//!</div>
//!</div>
//!<span id="outside_area">X</span><br>
//!<span id="inside_area">X</span>
//!</body>
//!</html>
}
test("Positioned inlines with containing block calculated 3")
	// Positioned inlines in the container that is a grand parent of the "first".
	require success "AHEM";
{
	verify(PositionedInlinesWithContainingBlock(OpRect(0, 0, 20, 20), TRUE));
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!div.outer
//!{
//!	display:inline-block;
//!}
//!
//!#first
//!{
//!	position:relative;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!span
//!{
//!	position:relative;
//!}
//!
//!#outside_area
//!{
//!	left:10px;
//!	top:-10px;
//!}
//!
//!#inside_area
//!{
//!	top:-11px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div id="first">
//!</div>
//!X<div class="outer">
//!<span id="outside_area">X</span><br>
//!<span id="inside_area">X</span>
//!</div>
//!</body>
//!</html>
}
test("Positioned inlines with containing block calculated 4")
	require success "AHEM";
	/* Positioned inlines in another, logically further container, whose placeholder
	   is an inline block. */
{
	verify(PositionedInlinesWithContainingBlock(OpRect(0, 0, 20, 20), TRUE));
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!	vertical-align:bottom;
//!}
//!
//!div.float
//!{
//!	float:left;
//!	width:10px;
//!	height:20px;
//!	background-color:lime;
//!}
//!
//!div.outer
//!{
//!	display:inline-block;
//!}
//!
//!#first
//!{
//!	position:relative;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!span
//!{
//!	position:relative;
//!}
//!
//!#outside_area
//!{
//!	left:20px;
//!	top:-10px;
//!}
//!
//!#inside_area
//!{
//!	top:-11px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div class="float"></div>
//!<div class="outer">
//!<div id="first">
//!</div>
//!</div>
//!<br>
//!<span id="outside_area">X</span><br>
//!<span id="inside_area">X</span>
//!</body>
//!</html>
}
test("Positioned inlines with containing block calculated 5")
	require success "AHEM";
	/* Positioned inlines in the container that is a grand parent of the "first".
	   The "first" container's placeholder is an inline block. */
{
	verify(PositionedInlinesWithContainingBlock(OpRect(0, 0, 20, 20), TRUE));
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!#first
//!{
//!	transform:translate(30px,30px) rotate(30deg);
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!span
//!{
//!	position:relative;
//!}
//!
//!#outside_area
//!{
//!	left:20px;
//!}
//!
//!#inside_area
//!{
//!	top:-11px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div id="first">
//!</div>
//!<span id="outside_area">X</span><br>
//!<span id="inside_area">X</span>
//!</body>
//!</html>
}
test("Positioned inlines with containing block calculated 6")
	require CSS_TRANSFORMS;
	require success "AHEM";
	// Positioned inlines in the same container, but leaving a transformed box.
{
	verify(PositionedInlinesWithContainingBlock(OpRect(0, 0, 20, 20), FALSE));
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!	line-height:10px;
//!}
//!
//!#first
//!{
//!	position:relative;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!#overflow
//!{
//!	overflow:hidden;
//!	width:40px;
//!	height:20px;
//!}
//!
//!span
//!{
//!	position:relative;
//!}
//!
//!#outside_area
//!{
//!	left:10px;
//!	top:-9px;
//!}
//!</style>
//!</head>
//!
//!<body>
//!<div id="first">
//!</div>
//!<div id="overflow">
//!<br>
//!<span id="inside_area">X</span><br>
//!<span id="outside_area">X</span>
//!</div>
//!</body>
//!</html>
}
test("Positioned inlines with containing block calculated 7")
	require success "AHEM";
	// Positioned inlines in the ScrollableContainer with changes scroll position.
{
	verify(state.doc);
	HTML_Element* root = state.doc->GetDocRoot();
	verify(root);

	HTML_Element* scr_elm = root->GetElmById(UNI_L("overflow"));
	verify(scr_elm);

	ScrollableArea* scrollable = scr_elm->GetLayoutBox() ? scr_elm->GetLayoutBox()->GetScrollable() : NULL;
	verify(scrollable);

	scrollable->SetViewY(LayoutCoord(10), FALSE);

	verify(PositionedInlinesWithContainingBlock(OpRect(0, 0, 20, 21), TRUE));
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!	vertical-align:bottom;
//!}
//!
//!#first
//!{
//!	position:relative;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!span { position:relative; }
//!
//!table { display:inline-table; }
//!
//!#outside_area
//!{
//!	left:20px;
//!}
//!
//!#inside_area
//!{
//!	top:-11px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<table><tr><td>
//!<div id="first"></div>
//!</td></tr></table>
//!<br>
//!<span id="outside_area">X</span><br>
//!<span id="inside_area">X</span>
//!</body>
//!</html>
}
test("Positioned inlines with containing block calculated 8")
	require success "AHEM";
	// Switching to positioned inlines after "first" target being in a table.
{
	verify(PositionedInlinesWithContainingBlock(OpRect(0, 0, 20, 20), TRUE));
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!#transform
//!{
//!	background-color:yellow;
//!	transform:translate(-30px,-41px);
//!}
//!
//!span span
//!{
//!	position:relative;
//!	top:50px;
//!	left:30px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<span id="transform"><span id="first">X</span> <span id="second">X</span></span>
//!</body>
//!</html>
}
test("Positioned inlines inside transformed inline")
	require CSS_TRANSFORMS;
	require success "AHEM";
	/* Reaching positioned inline boxes that are children of a transformed inline
	   box. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 30, 10));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first") == TRUE);
	verify(hit_testing_obj.Exists("second") == TRUE);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!div
//!{
//!	position:absolute;
//!	width:10px;
//!	height:10px;
//!}
//!
//!#first
//!{
//!	top:-30px;
//!	left:-21px;
//!	background-color:yellow;
//!}
//!
//!#second
//!{
//!	top:-20px;
//!	left:-30px;
//!	background-color:lime;
//!}
//!
//!span
//!{
//!	position:relative;
//!	z-index:1;
//!	top:30px;
//!	left:30px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<span>X<div id="first"></div><div id="second"></div></span>
//!</body>
//!</html>
}
test("Absolute positioned descendants of inline positioned z-root")
	require success "AHEM";
	/* Having two absolute positioned descendants of an inline positioned box
	   with z-index. One of them is intersecting the area, the other isn't. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10, 10));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first") == TRUE);
	verify(hit_testing_obj.Exists("second") == FALSE);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!#first
//!{
//!	position:relative;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!span, #skipped1 { position:relative; }
//!
//!#hit
//!{
//!	left:10px;
//!	top:-21px;
//!}
//!
//!#skipped3
//!{
//!	position:absolute;
//!	width:10px;
//!	height:10px;
//!	background-color:lime;
//!	top:30px;
//!	left:10px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div id="first">
//!</div>
//!<div>
//!<div id="skipped1">X</div>
//!<span id="skipped2">X</span>
//!<div id="skipped3"></div>
//!</div>
//!<span id="hit">X</span>
//!</body>
//!</html>
}
test("Skipping z-elm targets, descendants of not entered block box")
	require success "AHEM";
	/* Tests whether we correctly skip all the Z elements that are descendants
	   of a block box that failed the intersection check and do not try to reach
	   them again from the stacking context. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 20, 20));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first") == TRUE);
	verify(hit_testing_obj.Exists("skipped1") == FALSE);
	verify(hit_testing_obj.Exists("skipped2") == FALSE);
	verify(hit_testing_obj.Exists("skipped3") == FALSE);
	verify(hit_testing_obj.Exists("hit") == TRUE);
	verify(hit_testing_obj.GetTraversePositionedElementCallCount() == 1);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!#first
//!{
//!	position:relative;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!span, #skipped1 { position:relative; }
//!
//!#hit
//!{
//!	left:10px;
//!	top:-30px;
//!}
//!
//!#skipped3
//!{
//!	position:relative;
//!	width:10px;
//!	height:10px;
//!	background-color:lime;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div id="first">
//!</div>
//!<table>
//!	<tr>
//!		<td>X</td>
//!	</tr>
//!	<tr>
//!		<td>
//!			<div id="skipped1">X</div>
//!			<span id="skipped2">X</span>
//!		</td>
//!		<td id="skipped3">
//!		</td>
//!	</tr>
//!</table>
//!<span id="hit">X</span>
//!</body>
//!</html>
}
test("Skipping z-elm targets, descendants of not entered table row")
	require success "AHEM";
	/* Tests whether we correctly skip all the Z elements that are descendants
	   of a table row that failed the intersection check and do not try to reach
	   them again from the stacking context. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 20, 21));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first") == TRUE);
	verify(hit_testing_obj.Exists("skipped1") == FALSE);
	verify(hit_testing_obj.Exists("skipped2") == FALSE);
	verify(hit_testing_obj.Exists("skipped3") == FALSE);
	verify(hit_testing_obj.Exists("hit") == TRUE);
	verify(hit_testing_obj.GetTraversePositionedElementCallCount() == 1);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!body > div
//!{
//!	overflow:hidden;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!#relative
//!{
//!	position:relative;
//!	width:21px;
//!	height:10px;
//!	background-color:black;
//!}
//!
//!#absolute
//!{
//!	position:absolute;
//!	width:20px;
//!	height:20px;
//!	top:0px;
//!	left:20px;
//!	background-color:lime;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div>
//!<div id="relative"></div>
//!<div id="absolute"></div>
//!</div>
//!</body>
//!</html>
}
test("Elements with different clip stack 1")
	/* Shouldn't reach the relative one, because of the clip rect, but should
	   reach the absolute one, because the clip rect of the parent div
	   doesn't apply. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(20, 0, 20, 20));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("relative") == FALSE);
	verify(hit_testing_obj.Exists("absolute") == TRUE);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!body > div
//!{
//!	overflow:hidden;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!#relative
//!{
//!	position:relative;
//!	top:20px;
//!}
//!
//!div > div
//!{
//!	display:inline-block;
//!}
//!
//!#absolute
//!{
//!	position:absolute;
//!	display:block;
//!	width:20px;
//!	height:20px;
//!	top:0px;
//!	left:20px;
//!	background-color:lime;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div>
//!<div id="absolute"></div>
//!<div><span id="relative">X</span></div>
//!</div>
//!</body>
//!</html>
}
test("Elements with different clip stack 2")
	require success "AHEM";
	/* Should reach the absolute positioned div, but then shouldn't reach the
	   relative one (which is a descendant of an inline block), because of
	   the clip rect from div with overflow:hidden. If the ancestor of the
	   relative span had display:block, we would get a false positive and
	   reach the span, despite being totally clipped. That is because
	   AreaTraversalObject::TraversePositionedElement doesn't take any clip rects,
	   that will be pushed later, into account. Having display:inline-block on
	   the ancestor however, makes the method to result with the need of
	   intersections check on the traverse path. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 21, 30));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("absolute") == TRUE);
	verify(hit_testing_obj.Exists("relative") == FALSE);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!div, span, td {	position:relative; }
//!
//!#inl_block { display:inline-block; }
//!#float { float:left; }
//!
//!#table_cell
//!{
//!	top:-10px;
//!	left:10px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<div id="float"><span id="descendant1">X</span></div>
//!<div id="inl_block"><span id="descendant2">X</span></div>
//!<div id="block"><span id="descendant3">X</span></div>
//!<table><tr><td id="table_cell"><span id="descendant4">X</span></td></tr></table>
//!</body>
//!</html>
}
test("Quick target switch to a descendant")
	require success "AHEM";
	/* Tests whether the quick target switch optimization works correctly
	   when switching to the Z Element that is a descendant of the previous
	   one. We've got four cases covered in this ST. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 20, 20));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("float") == TRUE);
	verify(hit_testing_obj.Exists("inl_block") == TRUE);
	verify(hit_testing_obj.Exists("block") == TRUE);
	verify(hit_testing_obj.Exists("table_cell") == TRUE);
	verify(hit_testing_obj.Exists("descendant1") == TRUE);
	verify(hit_testing_obj.Exists("descendant2") == TRUE);
	verify(hit_testing_obj.Exists("descendant3") == TRUE);
	verify(hit_testing_obj.Exists("descendant4") == TRUE);
	verify(hit_testing_obj.GetTraversePositionedElementCallCount() == 1);
}

/* For the three following selftests, in which it is not possible to calculate
   the offset to the target being on a stacking context, but the target is
   outside of the area and that fact turns out later. */

subtest TraversePositionedElementTest()
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10, 10));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("not_hit") == FALSE);
	verify(hit_testing_obj.GetTraversePositionedElementCallCount() == 1);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!span
//!{
//!	position:relative;
//!	left:10px;
//!}
//!
//!body > div { display:inline-block; }
//!
//!</style>
//!</head>
//!
//!<body>
//!<div>
//!<span id="not_hit">X</span>
//!</div>
//!</body>
//!</html>
}
test("Not reaching a positioned element out of area 1")
	require success "AHEM";
	// A child of an inline block.
{
	verify(TraversePositionedElementTest());
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!div > div
//!{
//!	transform:translate(20px,20px) rotate(30deg);
//!	transform-origin:top left;
//!}
//!
//!body > div { margin-left:10px; }
//!
//!</style>
//!</head>
//!
//!<body>
//!<div>
//!<div id="not_hit">X</div>
//!</div>
//!</body>
//!</html>
}
test("Not reaching a positioned element out of area 2")
	require success "AHEM";
	require CSS_TRANSFORMS;
	// A transformed block box.
{
	verify(TraversePositionedElementTest());
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!span { opacity:0.9; }
//!
//!div { margin-left:10px; }
//!
//!</style>
//!</head>
//!
//!<body>
//!<div><span id="not_hit">X</span></div>
//!</body>
//!</html>
}
test("Not reaching a positioned element out of area 3")
	require success "AHEM";
	// z root, but not positioned inline.
{
	verify(TraversePositionedElementTest());
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!#first
//!{
//!	position:relative;
//!	background-color:yellow;
//!	width:20px;
//!	height:20px;
//!}
//!
//!#fixed
//!{
//!	position:fixed;
//!	left:19px;
//!	top:0px;
//!	width:20px;
//!	height:20px;
//!	background-color:lime;
//!}
//!</style>
//!</head>
//!
//!<body>
//!<div id="first">
//!</div>
//!<div>
//!<div id="fixed"></div>
//!</div>
//!</body>
//!</html>
}
test("Reaching fixed positioned element after quick target switch")
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 20, 20));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first") == TRUE);
	verify(hit_testing_obj.Exists("fixed") == TRUE);
	verify(hit_testing_obj.GetTraversePositionedElementCallCount() == 1);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!#first
//!{
//!	position:relative;
//!	background-color:yellow;
//!	width:20px;
//!	height:20px;
//!}
//!
//!#fixed
//!{
//!	position:fixed;
//!	left:19px;
//!	top:0px;
//!	background-color:lime;
//!	width:20px;
//!	height:20px;
//!}
//!
//!span { position:relative; }
//!
//!</style>
//!</head>
//!
//!<body>
//!<div id="first">
//!</div>
//!<div>
//!<span id="skipped">X</span>
//!<div id="fixed"></div>
//!</div>
//!</body>
//!</html>
}
test("Reaching fixed positioned element after skipping a subtree")
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 20, 20));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first") == TRUE);
	verify(hit_testing_obj.Exists("fixed") == TRUE);
	verify(hit_testing_obj.Exists("skipped") == FALSE);
	verify(hit_testing_obj.GetTraversePositionedElementCallCount() == 1);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!}
//!
//!div { width:20px; height:20px; }
//!
//!#relative
//!{
//!	position:relative;
//!	background-color:yellow;
//!}
//!
//!#fixed
//!{
//!	position:fixed;
//!	left:0px;
//!	top:0px;
//!	width:20px;
//!	height:20px;
//!}
//!</style>
//!</head>
//!
//!<body>
//!<div id="fixed">
//!	<div id="relative"></div>
//!</div>
//!</body>
//!</html>
}
test("Reaching relative positioned descendant of fixed positioned")
	// Also checks whether quick target switch optimization works.
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 20, 20));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("fixed") == TRUE);
	verify(hit_testing_obj.Exists("relative") == TRUE);
	verify(hit_testing_obj.GetTraversePositionedElementCallCount() == 1);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!}
//!
//!#overflow {overflow:hidden; }
//!
//!div div div, #overflow { width:20px; height:20px; }
//!
//!#relative
//!{
//!	position:relative;
//!	background-color:yellow;
//!}
//!
//!#absolute
//!{
//!	position:absolute;
//!	background-color:lime;
//!	top:20px;
//!	left:0px;
//!}
//!
//!#fixed
//!{
//!	position:fixed;
//!	left:0px;
//!	top:0px;
//!}
//!</style>
//!</head>
//!
//!<body>
//!<div id="fixed">
//!	<div id="overflow">
//!		<div id="absolute"></div>
//!		<div id="relative"></div>
//!	</div>
//!</div>
//!</body>
//!</html>
}
test("Reaching relative pos descendant of fixed (clipping involved)")
	/* Tests whether we reach the relative div, which is a descendant of
	   a fixed positioned element and also the div shares the parent that
	   introduces a clip rect with the absolute positioned element (this one
	   is outside the area). Currently we can't quickly switch the target
	   after finishing the 'absolute' one traverse, because of the different
	   clipping stack. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 20, 20));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("fixed") == TRUE);
	verify(hit_testing_obj.Exists("absolute") == FALSE);
	verify(hit_testing_obj.Exists("relative") == TRUE);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!#first
//!{
//!	position:absolute;
//!	width:20px;
//!	height:30px;
//!	background-color:yellow;
//!}
//!
//!div.multicol
//!{
//!	column-count:2;
//!	column-gap:0;
//!	width:40px;
//!	height:40px;
//!	margin-left:20px;
//!}
//!
//!#inside_multicol_static
//!{
//!	width:20px;
//!	height:30px;
//!	background-color:blue;
//!}
//!
//!#inside_multicol_positioned
//!{
//!	position:relative;
//!	background-color:lime;
//!	width:20px;
//!	height:20px;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!	<div id="first">
//!	</div>
//!	<div class="multicol">
//!		XX XX XX
//!		<div id="inside_multicol_static">
//!			<div id="inside_multicol_positioned"></div>
//!		</div>
//!		XX XX
//!	</div>
//!</body>
//!</html>
}
test("Not reaching a positioned block in multicol")
	require success "AHEM";
	/* Tests not only that we don't reach a positioned block inside a multicol,
	   but also that we don't reach its static positioned parent (inside a multicol
	   too). The area is not intersecting the static positioned one and that
	   should be reflected in the way of traversing this doc. */
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 20, 60, 10));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first") == TRUE);
	verify(hit_testing_obj.Exists("inside_multicol_static") == FALSE);
	verify(hit_testing_obj.Exists("inside_multicol_positioned") == FALSE);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!#first
//!{
//!	position:relative;
//!	width:20px;
//!	height:20px;
//!	background-color:yellow;
//!}
//!
//!div.multicol
//!{
//!	column-count:3;
//!	column-gap:0;
//!	width:60px;
//!	height:20px;
//!}
//!
//!#pos_inl_inside_multicol
//!{
//!	position:relative;
//!	color:lime;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!	<div id="first">
//!	</div>
//!	<div class="multicol">
//!		XX XX XX <span id="pos_inl_inside_multicol">XX XX</span> XX
//!	</div>
//!</body>
//!</html>
}
test("Reaching a positioned inline that is in more than one column")
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 60, 21));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("first") == TRUE);
	verify(hit_testing_obj.Exists("pos_inl_inside_multicol") == TRUE);
}

html
{
//!<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
//!<html>
//!<head>
//!<style>
//!*
//!{
//!	margin:0;padding:0;
//!	border-spacing: 0;
//!	font:10px 'Ahem';
//!}
//!
//!div, .positioned
//!{
//!	position:relative;
//!}
//!
//!</style>
//!</head>
//!
//!<body>
//!<table>
//!	<tbody>
//!		<tr>
//!			<td>
//!				<div id="in_first_row">X</div>
//!			</td>
//!		</tr>
//!	</tbody>
//!	<tbody>
//!		<tr>
//!			<td>
//!				<div id="in_second_row">X</div>
//!			</td>
//!		</tr>
//!		<tr class="positioned" id="positioned_row">
//!			<td class="positioned" id="positioned_cell1">X</td>
//!		</tr>
//!		<tr>
//!			<td class="positioned" id="positioned_cell2">X</td>
//!		</tr>
//!	</tbody>
//!</table>
//!</body>
//!</html>
}
test("Reaching positioned targets inside same table")
	require success "AHEM";
{
	verify(state.doc);
	HTML_Element* doc_root = state.doc->GetDocRoot();
	verify(doc_root);

	ST_HitTestingTraversalObject hit_testing_obj(state.doc, OpRect(0, 0, 10, 40));

	OP_STATUS stat = hit_testing_obj.Traverse(doc_root);
	verify(OpStatus::IsSuccess(stat));

	verify(hit_testing_obj.Exists("in_first_row") == TRUE);
	verify(hit_testing_obj.Exists("in_second_row") == TRUE);
	verify(hit_testing_obj.Exists("positioned_row") == TRUE);
	verify(hit_testing_obj.Exists("positioned_cell1") == TRUE);
	verify(hit_testing_obj.Exists("positioned_cell2") == TRUE);
	verify(hit_testing_obj.GetTraversePositionedElementCallCount() == 1);
}

// END: The subgroup of selftests introduced from CORE-45142
