/* -*- Mode: c++; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*-
 *
 * Copyright (C) 2011 Opera Software ASA.  All rights reserved.
 *
 * This file is part of the Opera web browser.
 * It may not be distributed under any circumstances.
 */
group "opdata.UniString";

include "modules/opdata/UniString.h";
include "modules/otl/list.h";
include "modules/opdata/UniStringFragmentIterator.h";

test("UniString always uses aligned uni_char pointers")
require OPDATA_UNI_CHAR_ALIGNMENT;
{
	UniString d;
	const uni_char *buf = d.Data(false);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	buf = d.Data(true);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	verify(!buf[d.Length()]);

	verify_success(d.SetConstData(UNI_L("")));
	buf = d.Data(false);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	buf = d.Data(true);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	verify(!buf[d.Length()]);

	verify_success(d.SetConstData(UNI_L("a")));
	buf = d.Data(false);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	buf = d.Data(true);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	verify(!buf[d.Length()]);

	verify_success(d.SetConstData(UNI_L("ab")));
	buf = d.Data(false);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	buf = d.Data(true);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	verify(!buf[d.Length()]);

	verify_success(d.SetConstData(UNI_L("abc")));
	buf = d.Data(false);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	buf = d.Data(true);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	verify(!buf[d.Length()]);

	verify_success(d.SetConstData(UNI_L("01234567891123456789212345678931234567894123456789")));
	verify_success(d.AppendConstData(UNI_L("01234567891123456789212345678931234567894123456789")));
	verify(d.Length() == 100);
	buf = d.Data(false);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	buf = d.Data(true);
	verify(buf);
	verify(reinterpret_cast<UINTPTR>(buf) % UNICODE_SIZE(1) == 0);
	verify(!buf[d.Length()]);
}

test("UniString::FindFirst(uni_char needle)")
{
	// embedded mode
	UniString d;
	const uni_char NUL = '\0';
	verify(d.FindFirst(NUL) == OpDataNotFound);
	verify(d.FindFirst('0') == OpDataNotFound);
	verify(d.FindFirst('0', 17) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("")));
	verify(d.FindFirst(NUL) == OpDataNotFound);
	verify(d.FindFirst('0') == OpDataNotFound);
	verify(d.FindFirst('0', 17) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("0")));
	verify(d.FindFirst(NUL) == OpDataNotFound);
	verify(d.FindFirst('0') == 0);
	verify(d.FindFirst('0', 0) == 0);
	verify(d.FindFirst('0', 0, 1) == 0);
	verify(d.FindFirst('0', 1) == OpDataNotFound);
	verify(d.FindFirst('0', 0, 0) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("110")));
	verify(d.FindFirst(NUL) == OpDataNotFound);
	verify(d.FindFirst('0') == 2);
	verify(d.FindFirst('0', 1) == 2);
	verify(d.FindFirst('0', 2) == 2);
	verify(d.FindFirst('0', 3) == OpDataNotFound);
	verify(d.FindFirst('0', 17) == OpDataNotFound);
	verify(d.FindFirst('0', 0, 3) == 2);
	verify(d.FindFirst('0', 0, 2) == OpDataNotFound);
	verify(d.FindFirst('0', 1, 2) == 2);
	verify(d.FindFirst('0', 1, 1) == OpDataNotFound);
	verify(d.FindFirst('0', 2, 1) == 2);
	verify(d.FindFirst('0', 2, 0) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("110"), 4)); // including '\0'-terminator
	verify(d.FindFirst(NUL) == 3);
	verify(d.FindFirst(NUL, 0) == 3);
	verify(d.FindFirst(NUL, 0, 4) == 3);
	verify(d.FindFirst(NUL, 0, 3) == OpDataNotFound);
	verify(d.FindFirst(NUL, 1, 3) == 3);

	verify_success(d.AppendConstData(UNI_L("098"))); // d is now "110\0098"
	verify(d.FindFirst(NUL) == 3);
	verify(d.FindFirst(NUL, 2) == 3);
	verify(d.FindFirst('0', 0) == 2);
	verify(d.FindFirst('0', 3) == 4);
	verify(d.FindFirst('9') == 5);

	// embeddable mode appended to normal mode
	verify_success(d.SetConstData(UNI_L("0123456789012345678901234567890123456789012345")));
	verify_success(d.AppendConstData(UNI_L("6789X123")));
	verify(d.Length() == 54);
	verify(d.FindFirst(NUL) == OpDataNotFound);
	verify(d.FindFirst('0') == 0);
	verify(d.FindFirst('0', 1) == 10);
	verify(d.FindFirst('0', 10) == 10);
	verify(d.FindFirst('0', 11) == 20);
	verify(d.FindFirst('0', 20) == 20);
	verify(d.FindFirst('0', 21) == 30);
	verify(d.FindFirst('0', 30) == 30);
	verify(d.FindFirst('0', 31) == 40);
	verify(d.FindFirst('0', 31, 9) == OpDataNotFound);
	verify(d.FindFirst('0', 31, 10) == 40);
	verify(d.FindFirst('0', 40) == 40);
	verify(d.FindFirst('0', 41) == OpDataNotFound);
	verify(d.FindFirst('0', 50) == OpDataNotFound);
	verify(d.FindFirst('0', 53) == OpDataNotFound);
	verify(d.FindFirst('0', 54) == OpDataNotFound);
	verify(d.FindFirst('0', 60) == OpDataNotFound);
	verify(d.FindFirst('X') == 50);
	verify(d.FindFirst('X', 2) == 50);
	verify(d.FindFirst('X', 49) == 50);
	verify(d.FindFirst('X', 50) == 50);
	verify(d.FindFirst('X', 51) == OpDataNotFound);
	verify(d.FindFirst('F') == OpDataNotFound);

	// normal mode appended to normal mode
	verify_success(d.SetConstData(UNI_L("012345678901234567890123456789012345678901")));
	verify_success(d.AppendConstData(UNI_L("23456789X12345678901234567890123456789012345")));
	verify(d.Length() == 86);
	verify(d.FindFirst('X') == 50);
	verify(d.FindFirst('X', 2) == 50);
	verify(d.FindFirst('X', 2, 48) == OpDataNotFound);
	verify(d.FindFirst('X', 2, 49) == 50);
	verify(d.FindFirst('X', 49) == 50);
	verify(d.FindFirst('X', 50) == 50);
	verify(d.FindFirst('X', 51) == OpDataNotFound);
	verify(d.FindFirst('F') == OpDataNotFound);

	// normal mode, appended to truncated normal mode
	verify_success(d.SetConstData(UNI_L("01234567890123456789012345678901234567890123456789")));
	d.Trunc(42);
	verify_success(d.AppendConstData(UNI_L("23456789X12345678901234567890123456789012345")));
	verify(d.Length() == 86);
	verify(d.FindFirst('X') == 50);
	verify(d.FindFirst('X', 2) == 50);
	verify(d.FindFirst('X', 2, 48) == OpDataNotFound);
	verify(d.FindFirst('X', 2, 49) == 50);
	verify(d.FindFirst('X', 49) == 50);
	verify(d.FindFirst('X', 50) == 50);
	verify(d.FindFirst('X', 51) == OpDataNotFound);
	verify(d.FindFirst('F') == OpDataNotFound);

	// normal mode appended to embedded mode
	verify_success(d.SetConstData(UNI_L("01")));
	verify_success(d.AppendConstData(UNI_L("23456789X12345678901234567890123456789012345")));
	verify(d.Length() == 46);
	verify(d.FindFirst('X') == 10);
	verify(d.FindFirst('X', 2) == 10);
	verify(d.FindFirst('X', 2, 8) == OpDataNotFound);
	verify(d.FindFirst('X', 2, 9) == 10);
	verify(d.FindFirst('X', 9) == 10);
	verify(d.FindFirst('X', 10) == 10);
	verify(d.FindFirst('X', 11) == OpDataNotFound);
	verify(d.FindFirst('F') == OpDataNotFound);
}

test("UniString::FindFirst(const uni_char *needle)")
{
	// embedded mode
	UniString d;
	verify(d.FindFirst(UNI_L("")) == 0);
	verify(d.FindFirst(UNI_L(""), 0, 0, 0) == 0);
	verify(d.FindFirst(UNI_L(""), 0, 0, 1) == 0);
	verify(d.FindFirst(UNI_L(""), 0, 1, 0) == OpDataNotFound);
	verify(d.FindFirst(UNI_L(""), 0, 1, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("0")) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("0"), 1, 17) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("")));
	verify(d.FindFirst(UNI_L("")) == 0);
	verify(d.FindFirst(UNI_L(""), 0, 0, 0) == 0);
	verify(d.FindFirst(UNI_L(""), 0, 0, 1) == 0);
	verify(d.FindFirst(UNI_L(""), 0, 1, 0) == OpDataNotFound);
	verify(d.FindFirst(UNI_L(""), 0, 1, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("0")) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("0"), 1, 17) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("0")));
	verify(d.FindFirst(UNI_L("")) == 0);
	verify(d.FindFirst(UNI_L(""), 0, 0, 0) == 0);
	verify(d.FindFirst(UNI_L(""), 0, 0, 1) == 0);
	verify(d.FindFirst(UNI_L(""), 0, 1, 0) == 1);
	verify(d.FindFirst(UNI_L(""), 0, 1, 1) == 1);
	verify(d.FindFirst(UNI_L(""), 0, 2, 0) == OpDataNotFound);
	verify(d.FindFirst(UNI_L(""), 0, 2, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("0")) == 0);
	verify(d.FindFirst(UNI_L("0"), 1, 0) == 0);
	verify(d.FindFirst(UNI_L("0"), 1, 0, 1) == 0);
	verify(d.FindFirst(UNI_L("0"), 1, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("0"), 1, 0, 0) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("00")) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("00"), 2) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("00"), 1) == 0);
	verify(d.FindFirst(UNI_L("00"), 1, 0) == 0);
	verify(d.FindFirst(UNI_L("00"), 1, 0, 1) == 0);
	verify(d.FindFirst(UNI_L("00"), 1, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("00"), 1, 0, 0) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("110")));
	verify(d.FindFirst(UNI_L("1")) == 0);
	verify(d.FindFirst(UNI_L("1"), 1, 1) == 1);
	verify(d.FindFirst(UNI_L("11")) == 0);
	verify(d.FindFirst(UNI_L("11"), 2, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110")) == 0);
	verify(d.FindFirst(UNI_L("110"), 3, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 3, 0) == 0);
	verify(d.FindFirst(UNI_L("110"), 3, 0, 0) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 3, 0, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 3, 0, 2) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 3, 0, 3) == 0);
	verify(d.FindFirst(UNI_L("110"), 4, 0, 0) == OpDataNotFound); // with '\0'
	verify(d.FindFirst(UNI_L("110"), 4, 0, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 4, 0, 2) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 4, 0, 3) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 4, 0, 4) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("10"), 2, 0, 3) == 1);
	verify(d.FindFirst(UNI_L("10"), 2, 0, 2) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("10"), 2, 1, 2) == 1);
	verify(d.FindFirst(UNI_L("10"), 2, 1, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("10"), 3, 0, 0) == OpDataNotFound); // with '\0'

	verify_success(d.SetConstData(UNI_L("110"), 4)); // including '\0'-terminator
	verify(d.FindFirst(UNI_L("1")) == 0);
	verify(d.FindFirst(UNI_L("110")) == 0);
	verify(d.FindFirst(UNI_L("110"), 3, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 3, 0) == 0);
	verify(d.FindFirst(UNI_L("110"), 4, 1) == OpDataNotFound); // with '\0'
	verify(d.FindFirst(UNI_L("110"), 4, 0) == 0);
	verify(d.FindFirst(UNI_L("110"), 4, 0, 0) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 4, 0, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 4, 0, 2) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 4, 0, 3) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("110"), 4, 0, 4) == 0);
	verify(d.FindFirst(UNI_L("10"), 2, 0, 3) == 1);
	verify(d.FindFirst(UNI_L("10"), 2, 0, 2) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("10"), 2, 1, 2) == 1);
	verify(d.FindFirst(UNI_L("10"), 2, 1, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("10"), 3, 0, 4) == 1);
	verify(d.FindFirst(UNI_L("10"), 3, 0, 3) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("10"), 3, 1, 3) == 1);
	verify(d.FindFirst(UNI_L("10"), 3, 1, 2) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("10"), 3, 2, 2) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("10"), 3, 2, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("10"), 3, 3, 1) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("10"), 3, 3, 0) == OpDataNotFound);

	verify_success(d.AppendConstData(UNI_L("098"))); // d is now "110\0098"
	verify(d.FindFirst(UNI_L(""), 1) == 3);
	verify(d.FindFirst(UNI_L(""), 1, 2) == 3);
	verify(d.FindFirst(UNI_L("0"), 2, 0) == 2);
	verify(d.FindFirst(UNI_L("0"), 2, 3) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("0"), 1, 3) == 4);
	const uni_char s[] = {'\0', '0'};
	verify(d.FindFirst(s, 2) == 3);
	verify(d.FindFirst(UNI_L("9")) == 5);
	const uni_char s2[] = {'0', '\0', '0'};
	verify(d.FindFirst(s2, 3) == 2);

	// normal mode
	verify_success(d.SetConstData(UNI_L("0123456789012345678901234567890123456789012345")));
	verify_success(d.AppendConstData(UNI_L("6789X123")));
	verify(d.Length() == 54);
	verify(d.FindFirst(UNI_L("0123456789")) == 0);
	verify(d.FindFirst(UNI_L("0123456789"), 10) == 0);
	verify(d.FindFirst(UNI_L("0123456789"), 10, 1) == 10);
	verify(d.FindFirst(UNI_L("0123456789"), 10, 9) == 10);
	verify(d.FindFirst(UNI_L("0123456789"), 10, 10) == 10);
	verify(d.FindFirst(UNI_L("0123456789"), 10, 11) == 20);
	verify(d.FindFirst(UNI_L("0123456789"), 10, 31) == 40);
	verify(d.FindFirst(UNI_L("0123456789"), 10, 41) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("X123"), 4, 41) == 50);
	verify(d.FindFirst(UNI_L("X123"), 4, 41, 10) == OpDataNotFound);
	verify(d.FindFirst(UNI_L("X123"), 4, 41, 13) == 50);
}

test("UniString::FindFirstOf()")
{
	// embedded mode
	UniString d;
	verify(d.FindFirstOf(UNI_L("")) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("foo")) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("")));
	verify(d.FindFirstOf(UNI_L("")) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("foo")) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("123")));
	verify(d.FindFirstOf(UNI_L("")) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("foo")) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("123")) == 0);
	verify(d.FindFirstOf(UNI_L("23")) == 1);
	verify(d.FindFirstOf(UNI_L("3")) == 2);
	verify(d.FindFirstOf(UNI_L("123"), 3, 0) == 0);
	verify(d.FindFirstOf(UNI_L("123"), 3, 1) == 1);
	verify(d.FindFirstOf(UNI_L("123"), 3, 2) == 2);
	verify(d.FindFirstOf(UNI_L("123"), 3, 3) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("1"), 1, 0) == 0);
	verify(d.FindFirstOf(UNI_L("1"), 1, 1) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("3"), 1, 2) == 2);
	verify(d.FindFirstOf(UNI_L("3"), 1, 2, 0) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("3"), 1, 2, 1) == 2);
	verify(d.FindFirstOf(UNI_L("3"), 1, 1, 1) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("3"), 1, 1, 2) == 2);
	verify(d.FindFirstOf(UNI_L("3"), 1, 0, 2) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("3"), 1, 0, 3) == 2);
	verify(d.FindFirstOf(UNI_L("foofoofoospamspamspamX3X")) == 2);

	verify_success(d.SetConstData(UNI_L("123"), 4)); // including '\0'-terminator
	verify(d.FindFirstOf(UNI_L("")) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L(""), 1) == 3); // with '\0'
	verify(d.FindFirstOf(UNI_L(""), 1, 0, 4) == 3);
	verify(d.FindFirstOf(UNI_L(""), 1, 0, 3) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L(""), 1, 1, 3) == 3);
	verify(d.FindFirstOf(UNI_L(""), 1, 1, 2) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L(""), 1, 2, 2) == 3);
	verify(d.FindFirstOf(UNI_L(""), 1, 2, 1) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L(""), 1, 3, 1) == 3);
	verify(d.FindFirstOf(UNI_L(""), 1, 3, 0) == OpDataNotFound);

	verify_success(d.AppendConstData(UNI_L("098"))); // d is now "123\0098"
	verify(d.FindFirstOf(UNI_L(""), 1) == 3);
	verify(d.FindFirstOf(UNI_L(""), 1, 2) == 3);
	verify(d.FindFirstOf(UNI_L("0")) == 4);
	verify(d.FindFirstOf(UNI_L("0"), 1) == 4);
	verify(d.FindFirstOf(UNI_L("0"), 2) == 3);
	verify(d.FindFirstOf(UNI_L("9")) == 5);

	// normal mode
	verify_success(d.SetConstData(UNI_L("0123456789012345678901234567890123456789012345")));
	verify_success(d.AppendConstData(UNI_L("6789X123")));
	verify(d.Length() == 54);
	verify(d.FindFirstOf(UNI_L("0123456789")) == 0);
	verify(d.FindFirstOf(UNI_L("0123456789"), 10, 0) == 0);
	verify(d.FindFirstOf(UNI_L("0123456789"), 10, 1) == 1);
	verify(d.FindFirstOf(UNI_L("0123456789"), 10, 2) == 2);
	verify(d.FindFirstOf(UNI_L("0123456789"), 10, 3) == 3);
	verify(d.FindFirstOf(UNI_L("0123456789"), 10, 4) == 4);
	verify(d.FindFirstOf(UNI_L("foox")) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("fooX")) == 50);
	verify(d.FindFirstOf(UNI_L("foox"), 5) == OpDataNotFound); // with '\0'
	verify(d.FindFirstOf(UNI_L("fooX"), 4, 10) == 50);
	verify(d.FindFirstOf(UNI_L("fooX"), 4, 49) == 50);
	verify(d.FindFirstOf(UNI_L("fooX"), 4, 50) == 50);
	verify(d.FindFirstOf(UNI_L("fooX"), 4, 51) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("0123456789"), 10, 50) == 51);

	// uni_char values >= 256
	uni_char *fill = d.GetAppendPtr(256);
	verify(fill);
	for (int i = 0; i < 256; i++)
		fill[i] = static_cast<uni_char>((i << 8) + i);
	verify_success(d.AppendConstData(UNI_L("foobar")));
	verify(d.Length() == 316);
	uni_char c = '\0';
	verify(d.FindFirstOf(&c, 1) == 54);
	c = 0x0101;
	verify(d.FindFirstOf(&c, 1) == 55);
	c = 0x0202;
	verify(d.FindFirstOf(&c, 1) == 56);
	c = 0x0303;
	verify(d.FindFirstOf(&c, 1) == 57);
	c = 0xffff;
	verify(d.FindFirstOf(&c, 1) == 309);
	verify(d.FindFirstOf(&c, 1, 309) == 309);
	verify(d.FindFirstOf(&c, 1, 310) == OpDataNotFound);
	verify(d.FindFirstOf(UNI_L("foobar")) == 310);
}

test("UniString::FindEndOf()")
{
	// embedded mode
	UniString d;
	verify(d.FindEndOf(UNI_L("")) == OpDataNotFound);
	verify(d.FindEndOf(UNI_L("foo")) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("")));
	verify(d.FindEndOf(UNI_L("")) == OpDataNotFound);
	verify(d.FindEndOf(UNI_L("foo")) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L(""), 1));
	verify(d.FindEndOf(UNI_L("")) == 0);
	verify(d.FindEndOf(UNI_L(""), 1) == OpDataNotFound);
	verify(d.FindEndOf(UNI_L("foo")) == 0);
	verify(d.FindEndOf(UNI_L("foo"), 4) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("123")));
	verify(d.FindEndOf(UNI_L("")) == 0);
	verify(d.FindEndOf(UNI_L("foo")) == 0);
	verify(d.FindEndOf(UNI_L("123")) == OpDataNotFound);
	verify(d.FindEndOf(UNI_L("12")) == 2);
	verify(d.FindEndOf(UNI_L("1")) == 1);
	verify(d.FindEndOf(UNI_L("2")) == 0);
	verify(d.FindEndOf(UNI_L("2"), 1, 1) == 2);
	verify(d.FindEndOf(UNI_L("foofoofoospamspamspamX12X")) == 2);

	verify_success(d.SetConstData(UNI_L("321"), 4)); // including '\0'-terminator
	verify(d.FindEndOf(UNI_L("123"), 3) == 3);
	verify(d.FindEndOf(UNI_L("123"), 4) == OpDataNotFound);

	verify_success(d.AppendConstData(UNI_L("098"))); // d is now "321\0098)
	verify(d.FindEndOf(UNI_L("123"), 3) == 3);
	verify(d.FindEndOf(UNI_L("123"), 4) == 4);
	verify(d.FindEndOf(UNI_L("0123"), 5, 2) == 5);
	verify(d.FindEndOf(UNI_L("90123"), 6) == 6);
	verify(d.FindEndOf(UNI_L("890123"), 7) == OpDataNotFound);
	verify(d.FindEndOf(UNI_L("0"), 2, 3, 3) == 5);
	verify(d.FindEndOf(UNI_L("0"), 2, 3, 2) == OpDataNotFound);

	// normal mode
	verify_success(d.SetConstData(UNI_L("0123456789012345678901234567890123456789012345")));
	verify_success(d.AppendConstData(UNI_L("6789X123")));
	verify(d.Length() == 54);
	verify(d.FindEndOf(UNI_L("X")) == 0);
	verify(d.FindEndOf(UNI_L("X0")) == 1);
	verify(d.FindEndOf(UNI_L("X01")) == 2);
	verify(d.FindEndOf(UNI_L("X012")) == 3);
	verify(d.FindEndOf(UNI_L("X0123")) == 4);
	verify(d.FindEndOf(UNI_L("X01234")) == 5);
	verify(d.FindEndOf(UNI_L("X012345")) == 6);
	verify(d.FindEndOf(UNI_L("X0123456")) == 7);
	verify(d.FindEndOf(UNI_L("X01234567")) == 8);
	verify(d.FindEndOf(UNI_L("X012345678")) == 9);
	verify(d.FindEndOf(UNI_L("X0123456789")) == OpDataNotFound);
	verify(d.FindEndOf(UNI_L("0123456789")) == 50);
	verify(d.FindEndOf(UNI_L("6789X12"), 7, 46) == 53);
	verify(d.FindEndOf(UNI_L("6789X12"), 7, 46, 7) == OpDataNotFound);
	verify(d.FindEndOf(UNI_L("6789X12"), 7, 46, 8) == 53);
	verify(d.FindEndOf(UNI_L("0123456789"), 10, 50) == 50);

	// uni_char values >= 256
	uni_char *fill = d.GetAppendPtr(256);
	verify(fill);
	for (int i = 0; i < 256; i++)
		fill[i] = static_cast<uni_char>((i << 8) + i);
	verify_success(d.AppendConstData(UNI_L("foobar")));
	verify(d.Length() == 316);
	UniString needle;
	needle.AppendConstData(UNI_L("0123456789X"));
	verify(d.FindEndOf(needle.Data(), needle.Length()) == 54);
	needle.Append('\0');
	verify(d.FindEndOf(needle.Data(), needle.Length()) == 55);
	needle.Append(0x0101);
	verify(d.FindEndOf(needle.Data(), needle.Length()) == 56);
	needle.Append(0xffff);
	needle.Append(0xfefe);
	verify(d.FindEndOf(needle.Data(), needle.Length(), 308) == 310);
	needle.AppendConstData(UNI_L("abfor"));
	verify(d.FindEndOf(needle.Data(), needle.Length(), 308) == OpDataNotFound);
}

test("UniString::FindLast(uni_char needle)")
{
	// embedded mode
	UniString d;
	const uni_char NUL = '\0';
	verify(d.FindLast(NUL) == OpDataNotFound);
	verify(d.FindLast('0') == OpDataNotFound);
	verify(d.FindLast('0', 17) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("")));
	verify(d.FindLast(NUL) == OpDataNotFound);
	verify(d.FindLast('0') == OpDataNotFound);
	verify(d.FindLast('0', 17) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("0")));
	verify(d.FindLast(NUL) == OpDataNotFound);
	verify(d.FindLast('0') == 0);
	verify(d.FindLast('0', 0) == 0);
	verify(d.FindLast('0', 0, 1) == 0);
	verify(d.FindLast('0', 1) == OpDataNotFound);
	verify(d.FindLast('0', 0, 0) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("00")));
	verify(d.FindLast('0') == 1);
	verify(d.FindLast('0', 0) == 1);
	verify(d.FindLast('0', 0, 1) == 0);
	verify(d.FindLast('0', 2) == OpDataNotFound);
	verify(d.FindLast('0', 1, 0) == OpDataNotFound);
	verify(d.FindLast('0', 0, 0) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("110")));
	verify(d.FindLast(NUL) == OpDataNotFound);
	verify(d.FindLast('1') == 1);
	verify(d.FindLast('1', 1) == 1);
	verify(d.FindLast('1', 2) == OpDataNotFound);
	verify(d.FindLast('1', 0, 1) == 0);
	verify(d.FindLast('1', 17) == OpDataNotFound);
	verify(d.FindLast('1', 0, 2) == 1);
	verify(d.FindLast('1', 0, 1) == 0);
	verify(d.FindLast('1', 1, 1) == 1);
	verify(d.FindLast('1', 1, 0) == OpDataNotFound);
	verify(d.FindLast('1', 2, 1) == OpDataNotFound);
	verify(d.FindLast('1', 2, 0) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("110"), 4)); // including '\0'-terminator
	verify(d.FindLast(NUL) == 3);
	verify(d.FindLast(NUL, 0) == 3);
	verify(d.FindLast(NUL, 0, 4) == 3);
	verify(d.FindLast(NUL, 0, 3) == OpDataNotFound);
	verify(d.FindLast(NUL, 1, 3) == 3);

	verify_success(d.AppendConstData(UNI_L("098"))); // d is now UNI_L("110\0098")
	verify(d.FindLast(NUL) == 3);
	verify(d.FindLast(NUL, 2) == 3);
	verify(d.FindLast('0', 0) == 4);
	verify(d.FindLast('0', 0, 3) == 2);
	verify(d.FindLast('9') == 5);

	// embeddable mode appended to normal mode
	verify_success(d.SetConstData(UNI_L("0123456789012345678901234567890123456789012345")));
	verify_success(d.AppendConstData(UNI_L("6789X123")));
	verify(d.Length() == 54);
	verify(d.FindLast(NUL) == OpDataNotFound);
	verify(d.FindLast('0') == 40);
	verify(d.FindLast('0', 0, 40) == 30);
	verify(d.FindLast('0', 0, 30) == 20);
	verify(d.FindLast('0', 0, 20) == 10);
	verify(d.FindLast('0', 0, 10) == 0);
	verify(d.FindLast('0', 0, 0) == OpDataNotFound);
	verify(d.FindLast('X') == 50);
	verify(d.FindLast('X', 2) == 50);
	verify(d.FindLast('X', 49) == 50);
	verify(d.FindLast('X', 50) == 50);
	verify(d.FindLast('X', 51) == OpDataNotFound);
	verify(d.FindLast('F') == OpDataNotFound);

	// normal mode appended to normal mode
	verify_success(d.SetConstData(UNI_L("0123456789X1234567890123456789012345678901")));
	verify_success(d.AppendConstData(UNI_L("23456789012345678901234567890123456789012345")));
	verify(d.Length() == 86);
	verify(d.FindLast('5') == 85);
	verify(d.FindLast('4') == 84);
	verify(d.FindLast('3') == 83);
	verify(d.FindLast('2') == 82);
	verify(d.FindLast('1') == 81);
	verify(d.FindLast('0') == 80);
	verify(d.FindLast('X') == 10);
	verify(d.FindLast('X', 2) == 10);
	verify(d.FindLast('X', 2, 8) == OpDataNotFound);
	verify(d.FindLast('X', 2, 9) == 10);
	verify(d.FindLast('X', 9) == 10);
	verify(d.FindLast('X', 10) == 10);
	verify(d.FindLast('X', 11) == OpDataNotFound);
	verify(d.FindLast('F') == OpDataNotFound);

	// normal mode, appended to truncated normal mode
	verify_success(d.SetConstData(UNI_L("0123456789X123456789012345678901234567890123456789")));
	d.Trunc(42);
	verify_success(d.AppendConstData(UNI_L("23456789012345678901234567890123456789012345")));
	d.Trunc(80);
	verify(d.Length() == 80);
	verify(d.FindLast('5') == 75);
	verify(d.FindLast('4') == 74);
	verify(d.FindLast('3') == 73);
	verify(d.FindLast('2') == 72);
	verify(d.FindLast('1') == 71);
	verify(d.FindLast('0') == 70);
	verify(d.FindLast('9', 0, 50) == 49);
	verify(d.FindLast('8', 0, 50) == 48);
	verify(d.FindLast('7', 0, 50) == 47);
	verify(d.FindLast('6', 0, 50) == 46);
	verify(d.FindLast('5', 0, 50) == 45);
	verify(d.FindLast('4', 0, 50) == 44);
	verify(d.FindLast('3', 0, 50) == 43);
	verify(d.FindLast('2', 0, 50) == 42);
	verify(d.FindLast('1', 0, 50) == 41);
	verify(d.FindLast('0', 0, 50) == 40);
	verify(d.FindLast('X') == 10);
	verify(d.FindLast('X', 2) == 10);
	verify(d.FindLast('X', 2, 8) == OpDataNotFound);
	verify(d.FindLast('X', 2, 9) == 10);
	verify(d.FindLast('X', 9) == 10);
	verify(d.FindLast('X', 10) == 10);
	verify(d.FindLast('X', 11) == OpDataNotFound);
	verify(d.FindLast('F') == OpDataNotFound);

	// normal mode appended to embedded mode
	verify_success(d.SetConstData(UNI_L("01")));
	verify_success(d.AppendConstData(UNI_L("23456789X12345678901234567890123456789012345")));
	verify(d.Length() == 46);
	verify(d.FindLast('X') == 10);
	verify(d.FindLast('X', 2) == 10);
	verify(d.FindLast('X', 2, 8) == OpDataNotFound);
	verify(d.FindLast('X', 2, 9) == 10);
	verify(d.FindLast('X', 9) == 10);
	verify(d.FindLast('X', 10) == 10);
	verify(d.FindLast('X', 11) == OpDataNotFound);
	verify(d.FindLast('F') == OpDataNotFound);
}

test("UniString::FindLast(const uni_char *needle)")
{
	// embedded mode
	UniString d;
	verify(d.FindLast(UNI_L("")) == 0);
	verify(d.FindLast(UNI_L(""), 0, 0, 0) == 0);
	verify(d.FindLast(UNI_L(""), 0, 0, 1) == 0);
	verify(d.FindLast(UNI_L(""), 0, 1, 0) == OpDataNotFound);
	verify(d.FindLast(UNI_L(""), 0, 1, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("0")) == OpDataNotFound);
	verify(d.FindLast(UNI_L("0"), 1, 17) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("")));
	verify(d.FindLast(UNI_L("")) == 0);
	verify(d.FindLast(UNI_L(""), 0, 0, 0) == 0);
	verify(d.FindLast(UNI_L(""), 0, 0, 1) == 0);
	verify(d.FindLast(UNI_L(""), 0, 1, 0) == OpDataNotFound);
	verify(d.FindLast(UNI_L(""), 0, 1, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("0")) == OpDataNotFound);
	verify(d.FindLast(UNI_L("0"), 1, 17) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("0")));
	verify(d.FindLast(UNI_L("")) == 1);
	verify(d.FindLast(UNI_L(""), 0, 0, 0) == 0);
	verify(d.FindLast(UNI_L(""), 0, 0, 1) == 1);
	verify(d.FindLast(UNI_L(""), 0, 1, 0) == 1);
	verify(d.FindLast(UNI_L(""), 0, 1, 1) == 1);
	verify(d.FindLast(UNI_L(""), 0, 2, 0) == OpDataNotFound);
	verify(d.FindLast(UNI_L(""), 0, 2, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("0")) == 0);
	verify(d.FindLast(UNI_L("0"), 1, 0) == 0);
	verify(d.FindLast(UNI_L("0"), 1, 0, 1) == 0);
	verify(d.FindLast(UNI_L("0"), 1, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("0"), 1, 0, 0) == OpDataNotFound);
	verify(d.FindLast(UNI_L("00")) == OpDataNotFound);
	verify(d.FindLast(UNI_L("00"), 2) == OpDataNotFound);
	verify(d.FindLast(UNI_L("00"), 1) == 0);
	verify(d.FindLast(UNI_L("00"), 1, 0) == 0);
	verify(d.FindLast(UNI_L("00"), 1, 0, 1) == 0);
	verify(d.FindLast(UNI_L("00"), 1, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("00"), 1, 0, 0) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("00")));
	verify(d.FindLast(UNI_L("0")) == 1);
	verify(d.FindLast(UNI_L("0"), 1, 0) == 1);
	verify(d.FindLast(UNI_L("0"), 1, 0, 1) == 0);
	verify(d.FindLast(UNI_L("0"), 1, 2) == OpDataNotFound);
	verify(d.FindLast(UNI_L("0"), 1, 1, 0) == OpDataNotFound);
	verify(d.FindLast(UNI_L("0"), 1, 0, 0) == OpDataNotFound);
	verify(d.FindLast(UNI_L("00")) == 0);
	verify(d.FindLast(UNI_L("00"), 2, 0, 2) == 0);
	verify(d.FindLast(UNI_L("00"), 2, 0, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("00"), 2, 1, 2) == OpDataNotFound);

	verify_success(d.SetConstData(UNI_L("110")));
	verify(d.FindLast(UNI_L("1")) == 1);
	verify(d.FindLast(UNI_L("1"), 1, 1) == 1);
	verify(d.FindLast(UNI_L("11")) == 0);
	verify(d.FindLast(UNI_L("11"), 2, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110")) == 0);
	verify(d.FindLast(UNI_L("110"), 3, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 3, 0) == 0);
	verify(d.FindLast(UNI_L("110"), 3, 0, 0) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 3, 0, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 3, 0, 2) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 3, 0, 3) == 0);
	verify(d.FindLast(UNI_L("110"), 4, 0, 0) == OpDataNotFound); // with '\0'
	verify(d.FindLast(UNI_L("110"), 4, 0, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 4, 0, 2) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 4, 0, 3) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 4, 0, 4) == OpDataNotFound);
	verify(d.FindLast(UNI_L("10"), 2, 0, 3) == 1);
	verify(d.FindLast(UNI_L("10"), 2, 0, 2) == OpDataNotFound);
	verify(d.FindLast(UNI_L("10"), 2, 1, 2) == 1);
	verify(d.FindLast(UNI_L("10"), 2, 1, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("10"), 3, 0, 17) == OpDataNotFound); // with '\0'

	verify_success(d.SetConstData(UNI_L("110"), 4)); // including '\0'-terminator
	verify(d.FindLast(UNI_L("1")) == 1);
	verify(d.FindLast(UNI_L("110")) == 0);
	verify(d.FindLast(UNI_L("110"), 3, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 3, 0) == 0);
	verify(d.FindLast(UNI_L("110"), 4, 1) == OpDataNotFound); // with '\0'
	verify(d.FindLast(UNI_L("110"), 4, 0) == 0);
	verify(d.FindLast(UNI_L("110"), 4, 0, 0) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 4, 0, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 4, 0, 2) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 4, 0, 3) == OpDataNotFound);
	verify(d.FindLast(UNI_L("110"), 4, 0, 4) == 0);
	verify(d.FindLast(UNI_L("10"), 2, 0, 3) == 1);
	verify(d.FindLast(UNI_L("10"), 2, 0, 2) == OpDataNotFound);
	verify(d.FindLast(UNI_L("10"), 2, 1, 2) == 1);
	verify(d.FindLast(UNI_L("10"), 2, 1, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("10"), 3, 0, 4) == 1);
	verify(d.FindLast(UNI_L("10"), 3, 0, 3) == OpDataNotFound);
	verify(d.FindLast(UNI_L("10"), 3, 1, 3) == 1);
	verify(d.FindLast(UNI_L("10"), 3, 1, 2) == OpDataNotFound);
	verify(d.FindLast(UNI_L("10"), 3, 2, 2) == OpDataNotFound);
	verify(d.FindLast(UNI_L("10"), 3, 2, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("10"), 3, 3, 1) == OpDataNotFound);
	verify(d.FindLast(UNI_L("10"), 3, 3, 0) == OpDataNotFound);

	verify_success(d.AppendConstData(UNI_L("098"))); // d is now UNI_L("110\0098")
	verify(d.FindLast(UNI_L(""), 1) == 3);
	verify(d.FindLast(UNI_L(""), 1, 2) == 3);
	verify(d.FindLast(UNI_L("0"), 2, 0) == 2);
	verify(d.FindLast(UNI_L("0"), 2, 3) == OpDataNotFound);
	verify(d.FindLast(UNI_L("0"), 1, 0) == 4);
	verify(d.FindLast(UNI_L("0"), 1, 0, 3) == 2);
	const uni_char s[] = {'\0', '0'};
	verify(d.FindLast(s, 2) == 3);
	verify(d.FindLast(UNI_L("9")) == 5);
	const uni_char s2[] = {'0', '\0', '0'};
	verify(d.FindLast(s2, 3) == 2);

	// normal mode
	verify_success(d.SetConstData(UNI_L("0123456789X12345678901234567890123456789012345")));
	verify_success(d.AppendConstData(UNI_L("67890123")));
	verify(d.Length() == 54);
	verify(d.FindLast(UNI_L("0123456789")) == 40);
	verify(d.FindLast(UNI_L("0123456789"), 10) == 40);
	verify(d.FindLast(UNI_L("0123456789"), 10, 0, 50) == 40);
	verify(d.FindLast(UNI_L("0123456789"), 10, 0, 49) == 30);
	verify(d.FindLast(UNI_L("0123456789"), 10, 0, 39) == 20);
	verify(d.FindLast(UNI_L("0123456789"), 10, 0, 29) == 0);
	verify(d.FindLast(UNI_L("0123456789"), 10, 0, 19) == 0);
	verify(d.FindLast(UNI_L("0123456789"), 10, 0, 10) == 0);
	verify(d.FindLast(UNI_L("0123456789"), 10, 0, 9) == OpDataNotFound);
	verify(d.FindLast(UNI_L("X123"), 4) == 10);
	verify(d.FindLast(UNI_L("X123"), 4, 10) == 10);
	verify(d.FindLast(UNI_L("X123"), 4, 11) == OpDataNotFound);
}

test("UniString::FindLast(const uni_char *needle) with trickier needles and haystacks")
{
#define frag0 "A long text forcing this object into normal mode. "
#define fragN " trailing data..."
	char *s = NULL;
	UniString d;

	verify_success(d.SetConstData(UNI_L(frag0)));
	verify_success(d.AppendConstData(UNI_L("CO")));
	verify_success(d.AppendConstData(UNI_L("NUT")));
	verify_success(d.AppendConstData(UNI_L(fragN)));
#ifdef OPDATA_DEBUG
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['CO'] -> ['NUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast(UNI_L("COCONUT")) == OpDataNotFound);
	verify(d.FindLast(UNI_L("CONUT")) == op_strlen(frag0));

	verify_success(d.SetConstData(UNI_L(frag0)));
	verify_success(d.AppendConstData(UNI_L("CO")));
	verify_success(d.AppendConstData(UNI_L("CONUT")));
	verify_success(d.AppendConstData(UNI_L(fragN)));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['CO'] -> ['CONUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast(UNI_L("COCONUT")) == op_strlen(frag0));
	verify(d.FindLast(UNI_L("CONUT")) == op_strlen(frag0) + 2);

	verify_success(d.SetConstData(UNI_L(frag0)));
	verify_success(d.AppendConstData(UNI_L("CO")));
	verify_success(d.AppendConstData(UNI_L("CO")));
	verify_success(d.AppendConstData(UNI_L("NUT")));
	verify_success(d.AppendConstData(UNI_L(fragN)));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['CO'] -> ['CO'] -> ['NUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast(UNI_L("COCONUT")) == op_strlen(frag0));
	verify(d.FindLast(UNI_L("CONUT")) == op_strlen(frag0) + 2);

	verify_success(d.SetConstData(UNI_L(frag0)));
	verify_success(d.AppendConstData(UNI_L("COCO")));
	verify_success(d.AppendConstData(UNI_L("NUT")));
	verify_success(d.AppendConstData(UNI_L(fragN)));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['COCO'] -> ['NUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast(UNI_L("COCONUT")) == op_strlen(frag0));
	verify(d.FindLast(UNI_L("CONUT")) == op_strlen(frag0) + 2);

	verify_success(d.SetConstData(UNI_L(frag0)));
	verify_success(d.AppendConstData(UNI_L("COCO")));
	verify_success(d.AppendConstData(UNI_L("CONUT")));
	verify_success(d.AppendConstData(UNI_L(fragN)));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['COCO'] -> ['CONUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast(UNI_L("COCOCONUT")) == op_strlen(frag0));
	verify(d.FindLast(UNI_L("COCONUT")) == op_strlen(frag0) + 2);
	verify(d.FindLast(UNI_L("CONUT")) == op_strlen(frag0) + 4);

	verify_success(d.SetConstData(UNI_L(frag0)));
	verify_success(d.AppendConstData(UNI_L("CO")));
	verify_success(d.AppendConstData(UNI_L("CO")));
	verify_success(d.AppendConstData(UNI_L("CONUT")));
	verify_success(d.AppendConstData(UNI_L(fragN)));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['CO'] -> ['CO'] -> ['CONUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast(UNI_L("COCOCONUT")) == op_strlen(frag0));
	verify(d.FindLast(UNI_L("COCONUT")) == op_strlen(frag0) + 2);
	verify(d.FindLast(UNI_L("CONUT")) == op_strlen(frag0) + 4);

	verify_success(d.SetConstData(UNI_L(frag0)));
	verify_success(d.AppendConstData(UNI_L("CO")));
	verify_success(d.AppendConstData(UNI_L("CO")));
	verify_success(d.AppendConstData(UNI_L("CO")));
	verify_success(d.AppendConstData(UNI_L("NUT")));
	verify_success(d.AppendConstData(UNI_L(fragN)));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['CO'] -> ['CO'] -> ['CO'] -> ['NUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast(UNI_L("COCOCONUT")) == op_strlen(frag0));
	verify(d.FindLast(UNI_L("COCONUT")) == op_strlen(frag0) + 2);
	verify(d.FindLast(UNI_L("CONUT")) == op_strlen(frag0) + 4);

	verify_success(d.SetConstData(UNI_L(frag0)));
	verify_success(d.AppendConstData(UNI_L("xxx")));
	verify_success(d.AppendConstData(UNI_L("x")));
	verify_success(d.AppendConstData(UNI_L("xx")));
	verify_success(d.AppendConstData(UNI_L(fragN)));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['xxx'] -> ['x'] -> ['xx'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast(UNI_L("x")) == op_strlen(frag0) + 5);
	verify(d.FindLast(UNI_L("xx")) == op_strlen(frag0) + 4);
	verify(d.FindLast(UNI_L("xxx")) == op_strlen(frag0) + 3);
	verify(d.FindLast(UNI_L("xxxx")) == op_strlen(frag0) + 2);
	verify(d.FindLast(UNI_L("xxxxx")) == op_strlen(frag0) + 1);
	verify(d.FindLast(UNI_L("xxxxxx")) == op_strlen(frag0) + 0);
	verify(d.FindLast(UNI_L("xxxxxxx")) == OpDataNotFound);
}
finally
{
	op_free(s);
}

table unistring_toint(const char* testname, const uni_char** string_data,
					  size_t base, size_t offset,
					  OP_STATUS expected_status, int expected_value,
					  size_t expected_length)
{
	{ "<empty>", { NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ " ", { UNI_L(" "), NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "1", { UNI_L("1"), NULL },
			10, 0, OpStatus::OK, 1, 1 },
	{ "+1234", { UNI_L(" +1234 "), NULL },
			10, 0, OpStatus::OK, 1234, 6 },
	{ "-1234", { UNI_L(" -1234 "), NULL },
			10, 0, OpStatus::OK, -1234, 6 },
	{ "foo-1-bar,4", { UNI_L("foo-1-bar"), NULL },
			10, 4, OpStatus::OK, 1, 1 },
	{ "foo-1-bar,3", { UNI_L("foo-1-bar"), NULL },
			10, 3, OpStatus::OK, -1, 2 },
	{ "foo-bar,3", { UNI_L("foo-bar"), NULL },
			10, 3, OpStatus::ERR, 0, 0 },
	{ "bacon + spam,5", { UNI_L("bacon + spam"), NULL },
			10, 5, OpStatus::ERR, 0, 0 },
	{ "bacon +2x spam,5", { UNI_L("bacon +2x spam"), NULL },
			10, 5, OpStatus::OK, 2, 3 },
	{ " -  + ", { UNI_L("\t - + - + \r\n"), NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "- 1", { UNI_L("- 1"), NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "+ 1", { UNI_L("+ 1"), NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "+-17", { UNI_L("+-17"), NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "+-17,1", { UNI_L("+-17"), NULL },
			10, 1, OpStatus::OK, -17, 3 },
	{ "-+17", { UNI_L("-+17"), NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "-+17,1", { UNI_L("-+17"), NULL },
			10, 1, OpStatus::OK, 17, 3 },
	{ " 1 ", { UNI_L(" 1 "), NULL },
			10, 0, OpStatus::OK, 1, 2 },
	{ " 666 ", { UNI_L(" 666 "), NULL },
			10, 0, OpStatus::OK, 666, 4 },
	{ " 12abcdeFoo123 ", { UNI_L(" 12abcdeFoo123 "), NULL },
			10, 0, OpStatus::OK, 12, 3 },
	{ " 12abcdeFoo123 ;base=2", { UNI_L(" 12abcdeFoo123 "), NULL },
			2, 0, OpStatus::OK, 1, 2 },
	{ " 12abcdeFoo123 ;base=3", { UNI_L(" 12abcdeFoo123 "), NULL },
			3, 0, OpStatus::OK, (3+2), 3 },
	{ "10000 x spam",
		{ UNI_L("Well, there's egg and bacon;"),
			UNI_L(" egg sausage and bacon;"),
			UNI_L(" egg and spam;"),
			UNI_L(" egg bacon and spam;"),
			UNI_L(" egg bacon sausage and spam; 10"),
			UNI_L("000 x spam bacon sausage and spam;"),
			UNI_L(" spam egg spam spam bacon and spam;"),
			UNI_L(" spam sausage spam spam bacon spam tomato and spam."),
			NULL },
		10, 113, OpStatus::OK, 10000, 6 },
	{ " 2147483647 ", { UNI_L("	2147483647 "), NULL },
			10, 0, OpStatus::OK, 2147483647, 11 },
	{ " -2147483648 ", { UNI_L("\r\n-2147483648 "), NULL },
			10, 0, OpStatus::OK, (-2147483647 - 1), 13 },
		// Same tests with base=16
	{ "<empty>;base=16", { NULL },
			16, 0, OpStatus::ERR, 0, 0 },
	{ "1;base=16", { UNI_L("1"), NULL },
			16, 0, OpStatus::OK, 1, 1 },
	{ "foo-1-bar,4;base=16", { UNI_L("foo-1-bar"), NULL },
			16, 4, OpStatus::OK, 1, 1 },
	{ "foo-1-bar,3;base=16", { UNI_L("foo-1-bar"), NULL },
			16, 3, OpStatus::OK, -1, 2 },
	{ "foo-bar,3;base=16", { UNI_L("foo-bar"), NULL },
			16, 3, OpStatus::OK, -186, 3 },
	{ "foo-bar,4;base=16", { UNI_L("foo-bar"), NULL },
			16, 4, OpStatus::OK, 186, 2 },
	{ " 1 ;base=16", { UNI_L(" 1 "), NULL },
			16, 0, OpStatus::OK, 1, 2 },
	{ " 666 ;base=16", { UNI_L(" 666 "), NULL },
			16, 0, OpStatus::OK, 0x666, 4 },
	{ " 12abcdeFoo123 ;base=16", { UNI_L(" 12abcdeFoo123 "), NULL },
			16, 0, OpStatus::OK, 0x12abcdef, 9 },
	{ "123 Foo 456;base=16", { UNI_L("123 Foo 456"), NULL },
			16, 0, OpStatus::OK, 0x123, 3 },
	{ "10000 x spam;base=16",
		{ UNI_L("Well, there's egg and bacon;"),
			UNI_L(" egg sausage and bacon;"),
			UNI_L(" egg and spam;"),
			UNI_L(" egg bacon and spam;"),
			UNI_L(" egg bacon sausage and spam; 10"),
			UNI_L("000 x spam bacon sausage and spam;"),
			UNI_L(" spam egg spam spam bacon and spam;"),
			UNI_L(" spam sausage spam spam bacon spam tomato and spam."),
			NULL },
		16, 113, OpStatus::OK, 0x10000, 6 },
	{ " 7fffffff ;base=16", { UNI_L("	7fffffff "), NULL },
			16, 0, OpStatus::OK, 0x7fffffff, 9 },
	{ " -80000000 ;base=16", { UNI_L(" -80000000 "), NULL },
			16, 0, OpStatus::OK, (-2147483647 - 1), 10 },
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from unistring_toint
{
	test("UniString::ToInt(" testname ")")
	{
		const uni_char* string_setup[] = string_data;
		UniString d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		int result;
		size_t parsed_length;
		OP_STATUS rc = d.ToInt(&result, &parsed_length, base, offset);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (int)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from unistring_toint
{
	test("UniString::ToUInt(" testname ")")
	{
		const uni_char* string_setup[] = string_data;
		UniString d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		unsigned int result;
		size_t parsed_length;
		OP_STATUS rc = d.ToUInt(&result, &parsed_length, base, offset);
		int value = expected_value;
		if (value < 0)
			/* Note: if the value is negative, then strtoul() returns the
			 * negation of the corresponding unsigned value (as unsigned long)
			 * which causes the unsigned int to overflow: */
			verify_status(OpStatus::ERR_OUT_OF_RANGE, rc);
		else
			verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (unsigned int)expected_value);
			verify(parsed_length == expected_length);
		}
	}
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from unistring_toint
{
	test("UniString::ToINT64(" testname ")")
		require STDLIB_64BIT_STRING_CONVERSIONS;
	{
		const uni_char* string_setup[] = string_data;
		UniString d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		INT64 result;
		size_t parsed_length;
		OP_STATUS rc = d.ToINT64(&result, &parsed_length, base, offset);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (INT64)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from unistring_toint
{
	test("UniString::ToUINT64(" testname ")")
		require STDLIB_64BIT_STRING_CONVERSIONS;
	{
		const uni_char* string_setup[] = string_data;
		UniString d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		UINT64 result;
		size_t parsed_length;
		OP_STATUS rc = d.ToUINT64(&result, &parsed_length, base, offset);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (UINT64)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from unistring_toint
{
	test("UniString::ToLong(" testname ")")
	{
		const uni_char* string_setup[] = string_data;
		UniString d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		long result;
		size_t parsed_length;
		OP_STATUS rc = d.ToLong(&result, &parsed_length, base, offset);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (long)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from unistring_toint
{
	test("UniString::ToULong(" testname ")")
	{
		const uni_char* string_setup[] = string_data;
		UniString d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		unsigned long result;
		size_t parsed_length;
		OP_STATUS rc = d.ToULong(&result, &parsed_length, base, offset);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (unsigned long)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

subtest test_UniString_ToInt(const UniString& d, int expect)
{
	int actual;
	verify_success(d.ToInt(&actual));
	verify(actual == expect);
}

test("UniString::Split()")
{
	UniString d;
	OpAutoPtr< OtlCountedList<UniString> >ret(d.Split('|'));
	verify(ret->Length() == 1);
	verify(ret->First().IsEmpty());

	verify_success(d.SetConstData(UNI_L("12|34|567|8||9|0|")));
	ret = d.Split('|');
	verify(ret->Length() == 8);
	verify(ret->PopFirst() == UNI_L("12"));
	verify(ret->PopFirst() == UNI_L("34"));
	verify(ret->PopFirst() == UNI_L("567"));
	verify(ret->PopFirst() == UNI_L("8"));
	verify(ret->PopFirst() == UNI_L(""));
	verify(ret->PopFirst() == UNI_L("9"));
	verify(ret->PopFirst() == UNI_L("0"));
	verify(ret->PopFirst() == UNI_L(""));
	verify(ret->IsEmpty());

	ret = d.Split('|', 3);
	verify(ret->Length() == 4);
	verify(ret->PopFirst() == UNI_L("12"));
	verify(ret->PopFirst() == UNI_L("34"));
	verify(ret->PopFirst() == UNI_L("567"));
	verify(ret->PopFirst() == UNI_L("8||9|0|"));
	verify(ret->IsEmpty());

	ret = d.Split('|', 6);
	verify(ret->Length() == 7);
	verify(ret->PopFirst() == UNI_L("12"));
	verify(ret->PopFirst() == UNI_L("34"));
	verify(ret->PopFirst() == UNI_L("567"));
	verify(ret->PopFirst() == UNI_L("8"));
	verify(ret->PopFirst() == UNI_L(""));
	verify(ret->PopFirst() == UNI_L("9"));
	verify(ret->PopFirst() == UNI_L("0|"));
	verify(ret->IsEmpty());

	ret = d.Split('|', 7);
	verify(ret->Length() == 8);
	verify(ret->PopFirst() == UNI_L("12"));
	verify(ret->PopFirst() == UNI_L("34"));
	verify(ret->PopFirst() == UNI_L("567"));
	verify(ret->PopFirst() == UNI_L("8"));
	verify(ret->PopFirst() == UNI_L(""));
	verify(ret->PopFirst() == UNI_L("9"));
	verify(ret->PopFirst() == UNI_L("0"));
	verify(ret->PopFirst() == UNI_L(""));
	verify(ret->IsEmpty());

	ret = d.Split('|', 0);
	verify(ret->Length() == 1);
	verify(ret->First() == UNI_L("12|34|567|8||9|0|"));
	verify(ret->First() == d);

	ret = d.Split('X');
	verify(ret->Length() == 1);
	verify(ret->First() == UNI_L("12|34|567|8||9|0|"));

	ret = d.Split('X', 6);
	verify(ret->Length() == 1);
	verify(ret->First() == UNI_L("12|34|567|8||9|0|"));

	verify_success(d.SetConstData(UNI_L("12|34|5averyveryveryveryveryveryveryverylongstring67|8||9|0|")));
	ret = d.Split('|');
	verify(ret->Length() == 8);
	verify(ret->PopFirst() == UNI_L("12"));
	verify(ret->PopFirst() == UNI_L("34"));
	verify(ret->PopFirst() == UNI_L("5averyveryveryveryveryveryveryverylongstring67"));
	verify(ret->PopFirst() == UNI_L("8"));
	verify(ret->PopFirst() == UNI_L(""));
	verify(ret->PopFirst() == UNI_L("9"));
	verify(ret->PopFirst() == UNI_L("0"));
	verify(ret->PopFirst() == UNI_L(""));
	verify(ret->IsEmpty());

	ret = d.Split('|', 3);
	verify(ret->Length() == 4);
	verify(ret->PopFirst() == UNI_L("12"));
	verify(ret->PopFirst() == UNI_L("34"));
	verify(ret->PopFirst() == UNI_L("5averyveryveryveryveryveryveryverylongstring67"));
	verify(ret->PopFirst() == UNI_L("8||9|0|"));
	verify(ret->IsEmpty());

	ret = d.Split('|', 6);
	verify(ret->Length() == 7);
	verify(ret->PopFirst() == UNI_L("12"));
	verify(ret->PopFirst() == UNI_L("34"));
	verify(ret->PopFirst() == UNI_L("5averyveryveryveryveryveryveryverylongstring67"));
	verify(ret->PopFirst() == UNI_L("8"));
	verify(ret->PopFirst() == UNI_L(""));
	verify(ret->PopFirst() == UNI_L("9"));
	verify(ret->PopFirst() == UNI_L("0|"));
	verify(ret->IsEmpty());

	ret = d.Split('|', 7);
	verify(ret->Length() == 8);
	verify(ret->PopFirst() == UNI_L("12"));
	verify(ret->PopFirst() == UNI_L("34"));
	verify(ret->PopFirst() == UNI_L("5averyveryveryveryveryveryveryverylongstring67"));
	verify(ret->PopFirst() == UNI_L("8"));
	verify(ret->PopFirst() == UNI_L(""));
	verify(ret->PopFirst() == UNI_L("9"));
	verify(ret->PopFirst() == UNI_L("0"));
	verify(ret->PopFirst() == UNI_L(""));
	verify(ret->IsEmpty());

	ret = d.Split('|', 0);
	verify(ret->Length() == 1);
	verify(ret->First() == UNI_L("12|34|5averyveryveryveryveryveryveryverylongstring67|8||9|0|"));

	ret = d.Split('X');
	verify(ret->Length() == 1);
	verify(ret->First() == UNI_L("12|34|5averyveryveryveryveryveryveryverylongstring67|8||9|0|"));

	ret = d.Split('X', 6);
	verify(ret->Length() == 1);
	verify(ret->First() == UNI_L("12|34|5averyveryveryveryveryveryveryverylongstring67|8||9|0|"));

	ret = d.Split('g', 6);
	verify(ret->Length() == 3);
	verify(ret->PopFirst() == UNI_L("12|34|5averyveryveryveryveryveryveryverylon"));
	verify(ret->PopFirst() == UNI_L("strin"));
	verify(ret->PopFirst() == UNI_L("67|8||9|0|"));
	verify(ret->IsEmpty());

	verify_success(d.SetConstData(UNI_L("1.0|0.0|OpComponentManagerResponseMessage|0|1#")));
	ret = d.Split('#');
	verify(ret->Length() == 2);
	verify(ret->First() == UNI_L("1.0|0.0|OpComponentManagerResponseMessage|0|1"));
	verify(ret->Last() == UNI_L(""));

	d = ret->First();
	ret = d.Split('|');

	verify(ret->Length() == 5);
	OtlList<UniString>::ConstIterator p = ret->Begin();
	verify_string(*p, UNI_L("1.0"));
	verify(++p != ret->End());
	verify_string(*p, UNI_L("0.0"));
	verify(++p != ret->End());
	verify_string(*p, UNI_L("OpComponentManagerResponseMessage"));
	verify(++p != ret->End());
	verify_string(*p, UNI_L("0"));
	verify(++p != ret->End());
	verify_string(*p, UNI_L("1"));
	verify(++p == ret->End());

	d = ret->PopFirst();
	UniString e = ret->PopFirst();
	verify(ret->First() == UNI_L("OpComponentManagerResponseMessage"));

	ret = d.Split('.', 1);
	verify(ret->Length() == 2);
	verify(ret->First() == UNI_L("1"));
	verify(ret->Last() == UNI_L("0"));

	verify(test_UniString_ToInt(ret->First(), 1));
	verify(test_UniString_ToInt(ret->Last(), 0));

	ret = e.Split('.', 1);
	verify(ret->Length() == 2);
	verify(ret->First() == UNI_L("0"));
	verify(ret->Last() == UNI_L("0"));

	verify(test_UniString_ToInt(ret->First(), 0));
	verify(test_UniString_ToInt(ret->Last(), 0));
}

test("UniString::Trunc() truncating to fragment boundary")
{
	UniString d;
	verify_success(d.SetConstData(UNI_L("012345678911234567892123456789312345678941")));
	verify_success(d.AppendConstData(UNI_L("012345678911234567892123456789312345678941")));
	verify(d.Length() == 84);
	verify(d == UNI_L("012345678911234567892123456789312345678941012345678911234567892123456789312345678941"));

	d.Trunc(42);
	verify(d.Length() == 42);
	verify(d == UNI_L("012345678911234567892123456789312345678941"));
}

test("UniString::ToDouble()")
{
	// This test test is based on the op_strtod() tests in stdlib_float.ot.
	const double epsilon = 1E-12;
	const double posinf = op_implode_double(0x7ff00000UL, 0UL);
	const double neginf = op_implode_double(0xfff00000UL, 0UL);

	UniString d;
	double result;
	size_t length;

	verify_success(d.SetConstData(UNI_L("    +4.5e-8")));
	verify_success(d.ToDouble(&result));
	verify((result - 4.5e-8) < epsilon);

	verify_success(d.SetConstData(UNI_L("  -Infinity  ")));
	verify_success(d.ToDouble(&result));
	verify(result == neginf);

	verify_success(d.ToDouble(&result, &length));
	verify(result == neginf);
	verify(length == 11);

	verify_success(d.SetConstData(UNI_L("  +Infinity")));
	verify_success(d.ToDouble(&result));
	verify(result == posinf);

	verify_success(d.SetConstData(UNI_L("12345678901234.0000000000000000000000000000000000000000000000000000000000001")));
	verify_success(d.ToDouble(&result));
	verify((result - 12345678901234.0) < epsilon);

	verify_success(d.SetConstData(UNI_L("12e3")));
	verify_success(d.ToDouble(&result));
	verify((result - 12000.0) < epsilon);

	verify_success(d.SetConstData(UNI_L("12e-3")));
	verify_success(d.ToDouble(&result));
	verify((result - 0.012) < epsilon);

	verify_success(d.SetConstData(UNI_L("-11E0foo")));
	verify_success(d.ToDouble(&result, &length));
	verify((result - -11) < epsilon);
	verify(length == 5);

	verify_status(OpStatus::ERR, d.ToDouble(&result));

	verify_success(d.SetConstData(UNI_L("12e3\n")));
	verify_success(d.ToDouble(&result, &length));
	verify((result - 12000.0) < epsilon);
	verify(length == 4);

	verify_success(d.SetConstData(UNI_L("12e-3	   \n\n		")));
	verify_success(d.ToDouble(&result, &length));
	verify((result - 0.012) < epsilon);
	verify(length == 5);

	verify_success(d.SetConstData(UNI_L("-11E0 ")));
	verify_success(d.ToDouble(&result, &length));
	verify((result - -11) < epsilon);
	verify(length == 5);

	verify_success(d.ToDouble(&result));
	verify((result - -11) < epsilon);
}

test("UniString::To(U)INT64()")
	require STDLIB_64BIT_STRING_CONVERSIONS;
{
	// This test is based on the op_strto(u)i64() tests in stdlib_integer.ot.
	UniString d;
	INT64 i;
	UINT64 u;
	size_t length;

	verify_success(d.SetConstData(UNI_L(" 1 ")));
	verify_success(d.ToINT64(&i));
	verify(i == 1);

	verify_success(d.SetConstData(UNI_L(" 9223372036854775807 ")));
	verify_success(d.ToINT64(&i, &length));
	verify(i == OP_INT64(9223372036854775807));
	verify(length == 20);

	verify_success(d.SetConstData(UNI_L(" -9223372036854775808xyzzy")));
	verify_success(d.ToINT64(&i, &length));
	verify(i == (OP_INT64(-9223372036854775807) - 1));
	verify(length == 21);

	verify_status(OpStatus::ERR, d.ToINT64(&i));

	// INT64 underflow
	verify_success(d.SetConstData(UNI_L(" -8000000000000001")));
	verify_status(OpStatus::ERR_OUT_OF_RANGE, d.ToINT64(&i, NULL, 16));

	// INT64 overflow
	verify_success(d.SetConstData(UNI_L(" 8000000000000001")));
	verify_status(OpStatus::ERR_OUT_OF_RANGE, d.ToINT64(&i, NULL, 16));

	
	verify_success(d.SetConstData(UNI_L(" 9223372036854775807 ")));
	verify_success(d.ToUINT64(&u, &length));
	verify(u == OP_UINT64(9223372036854775807));
	verify(length == 20);

	verify_success(d.SetConstData(UNI_L(" 18446744073709551615foo")));
	verify_success(d.ToUINT64(&u, &length));
	verify(u == OP_UINT64(18446744073709551615));
	verify(length == 21);

	// UINT64 negative
	verify_success(d.SetConstData(UNI_L(" -1")));
	OP_STATUS st = d.ToUINT64(&u);
	if (st != OpStatus::ERR_OUT_OF_RANGE)
	{
		verify_success(st);
		verify(u + 1 == 0);
	}

	// UINT64 overflow
	verify_success(d.SetConstData(UNI_L(" 10000000000000000")));
	verify_status(OpStatus::ERR_OUT_OF_RANGE, d.ToUINT64(&u, NULL, 16));
}

test("UniString::AppendCopyData()")
{
	const uni_char *const_a = UNI_L("a fairly long string which is long enough to exceed embedded storage.");
	const uni_char *const_b = UNI_L("b fairly long string which is long enough to exceed embedded storage.");
	const uni_char *const_c = UNI_L("c fairly long string which is long enough to exceed embedded storage.");
	uni_char a[70];
	uni_char b[70];
	uni_char c[70];
	uni_strcpy(a, const_a);
	uni_strcpy(b, const_b);
	uni_strcpy(c, const_c);

	UniString d;
	verify_success(d.AppendCopyData(a));

	a[0] = 'x';
	verify(d == UNI_L("a fairly long string which is long enough to exceed embedded storage."));

	d.Clear();
	verify_success(d.AppendCopyData(b, 10));

	b[0] = 'y';
	verify(d == UNI_L("b fairly l"));

	d.Clear();
	verify_success(d.AppendCopyData(c + 20, 17));

	c[20] = 'z';
	verify(d == UNI_L(" which is long en"));

	verify_success(d.AppendCopyData(a));
	verify_success(d.AppendCopyData(b));
	verify_success(d.AppendCopyData(c));

	a[1] = '#';
	b[1] = '#';
	c[1] = '#';
	verify_string(d, " which is long en"
		"x fairly long string which is long enough to exceed embedded storage."
		"y fairly long string which is long enough to exceed embedded storage."
		"c fairly long stringzwhich is long enough to exceed embedded storage.");
}

test("UniString::SetCopyData() and ::CopyDataL()")
{
	UniString d;
	verify_success(d.SetCopyData(UNI_L("abcdef")));
	verify(!d.IsEmpty());
	verify_success(d.SetCopyData(UNI_L("abcdef"), 6));
	verify(!d.IsEmpty());
	verify(d.SetCopyData(NULL, OpDataMaxLength - 1) == OpStatus::ERR_NO_MEMORY);
	verify(d == UNI_L("abcdef"));

	OP_MEMORY_VAR OP_STATUS error;
	TRAP(error, d = UniString::CopyDataL(UNI_L("abcdef")));
	verify_success(error);
	verify(!d.IsEmpty());
	TRAP(error, d = UniString::CopyDataL(UNI_L("abcdef"), 6));
	verify_success(error);
	verify(!d.IsEmpty());
	TRAP(error, d = UniString::CopyDataL(NULL, OpDataMaxLength - 1));
	verify_status(OpStatus::ERR_NO_MEMORY, error);
}

test("UniString::DebugView()")
	require OPDATA_DEBUG;
{
	UniString d;
	char *s = d.DebugView();
	verify_string(s, "{''}");

	d.AppendConstData(UNI_L("foo bar"));
	op_free(s);
	s = d.DebugView();
	verify_string(s, "{'foo bar'}");

	const uni_char *v = UNI_L("This is a string whose length is sufficient to force UniString to store it in normal mode.");
	verify_success(d.SetConstData(v));
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['This is a string whose length is sufficient to force UniString to store it in normal mode.']");

	d.Consume(5);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[5+'is a string whose length is sufficient to force UniString to store it in normal mode.']");

	d.Trunc(d.Length() - 6);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[5+'is a string whose length is sufficient to force UniString to store it in normal'+6]");

	d.AppendConstData(UNI_L(" foo bar baz and some other stuff..."));
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[5+'is a string whose length is sufficient to force UniString to store it in normal'] -> [' foo bar baz and some other stuff...']");

	d.AppendConstData(UNI_L(" ... and here is yet another fragment."));
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[5+'is a string whose length is sufficient to force UniString to store it in normal'] -> [' foo bar baz and some other stuff...'] -> [' ... and here is yet another fragment.']");

	d.Consume(15);
	d.Trunc(d.Length() - 10);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length is sufficient to force UniString to store it in normal'] -> [' foo bar baz and some other stuff...'] -> [' ... and here is yet another'+10]");

	d.Trunc(d.Length() - 23);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length is sufficient to force UniString to store it in normal'] -> [' foo bar baz and some other stuff...'] -> [' ... '+33]");

	d.Trunc(d.Length() - 6);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length is sufficient to force UniString to store it in normal'] -> [' foo bar baz and some other stuff..'+1]");

	d.Trunc(d.Length() - 35);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length is sufficient to force UniString to store it in normal']");

	d.Trunc(d.Length() - 2);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length is sufficient to force UniString to store it in norm'+2]");

	d.Trunc(10);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length '+54]");

	d.Trunc(0);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "{''}");
}
finally
{
	op_free(s);
}

test("UniString::DebugView() with non-printable characters")
	require OPDATA_DEBUG;
{
	// embedded mode
	UniString d;
	uni_char *fill = d.GetAppendPtr(5);
	for (int i = 0; i < 5; i++)
		fill[i] = static_cast<uni_char>(i);

	char *s = d.DebugView();
	verify_string(s, "{'\\x0000\\x0001\\x0002\\x0003\\x0004'}");

	// normal mode
	d.Clear();
	fill = d.GetAppendPtr(256);
	for (int i = 0; i < 256; i++)
		fill[i] = static_cast<uni_char>(i);

	op_free(s);
	s = d.DebugView();
	verify_string(s, "['"
		"\\x0000\\x0001\\x0002\\x0003\\x0004\\x0005\\x0006\\x0007"
		"\\x0008\\x0009\\x000a\\x000b\\x000c\\x000d\\x000e\\x000f"
		"\\x0010\\x0011\\x0012\\x0013\\x0014\\x0015\\x0016\\x0017"
		"\\x0018\\x0019\\x001a\\x001b\\x001c\\x001d\\x001e\\x001f"
		" !\"#$%&\\'()*+,-./"
		"0123456789:;<=>?"
		"@ABCDEFGHIJKLMNO"
		"PQRSTUVWXYZ[\\\\]^_"
		"`abcdefghijklmno"
		"pqrstuvwxyz{|}~\\x007f"
		"\\x0080\\x0081\\x0082\\x0083\\x0084\\x0085\\x0086\\x0087"
		"\\x0088\\x0089\\x008a\\x008b\\x008c\\x008d\\x008e\\x008f"
		"\\x0090\\x0091\\x0092\\x0093\\x0094\\x0095\\x0096\\x0097"
		"\\x0098\\x0099\\x009a\\x009b\\x009c\\x009d\\x009e\\x009f"
		"\\x00a0\\x00a1\\x00a2\\x00a3\\x00a4\\x00a5\\x00a6\\x00a7"
		"\\x00a8\\x00a9\\x00aa\\x00ab\\x00ac\\x00ad\\x00ae\\x00af"
		"\\x00b0\\x00b1\\x00b2\\x00b3\\x00b4\\x00b5\\x00b6\\x00b7"
		"\\x00b8\\x00b9\\x00ba\\x00bb\\x00bc\\x00bd\\x00be\\x00bf"
		"\\x00c0\\x00c1\\x00c2\\x00c3\\x00c4\\x00c5\\x00c6\\x00c7"
		"\\x00c8\\x00c9\\x00ca\\x00cb\\x00cc\\x00cd\\x00ce\\x00cf"
		"\\x00d0\\x00d1\\x00d2\\x00d3\\x00d4\\x00d5\\x00d6\\x00d7"
		"\\x00d8\\x00d9\\x00da\\x00db\\x00dc\\x00dd\\x00de\\x00df"
		"\\x00e0\\x00e1\\x00e2\\x00e3\\x00e4\\x00e5\\x00e6\\x00e7"
		"\\x00e8\\x00e9\\x00ea\\x00eb\\x00ec\\x00ed\\x00ee\\x00ef"
		"\\x00f0\\x00f1\\x00f2\\x00f3\\x00f4\\x00f5\\x00f6\\x00f7"
		"\\x00f8\\x00f9\\x00fa\\x00fb\\x00fc\\x00fd\\x00fe\\x00ff"
		"']");

	d.Clear();
	fill = d.GetAppendPtr(256);
	for (int i = 0; i < 256; i++)
		fill[i] = static_cast<uni_char>((i << 8) + i);

	op_free(s);
	s = d.DebugView();
	verify_string(s, "['"
		"\\x0000\\x0101\\x0202\\x0303\\x0404\\x0505\\x0606\\x0707"
		"\\x0808\\x0909\\x0a0a\\x0b0b\\x0c0c\\x0d0d\\x0e0e\\x0f0f"
		"\\x1010\\x1111\\x1212\\x1313\\x1414\\x1515\\x1616\\x1717"
		"\\x1818\\x1919\\x1a1a\\x1b1b\\x1c1c\\x1d1d\\x1e1e\\x1f1f"
		"\\x2020\\x2121\\x2222\\x2323\\x2424\\x2525\\x2626\\x2727"
		"\\x2828\\x2929\\x2a2a\\x2b2b\\x2c2c\\x2d2d\\x2e2e\\x2f2f"
		"\\x3030\\x3131\\x3232\\x3333\\x3434\\x3535\\x3636\\x3737"
		"\\x3838\\x3939\\x3a3a\\x3b3b\\x3c3c\\x3d3d\\x3e3e\\x3f3f"
		"\\x4040\\x4141\\x4242\\x4343\\x4444\\x4545\\x4646\\x4747"
		"\\x4848\\x4949\\x4a4a\\x4b4b\\x4c4c\\x4d4d\\x4e4e\\x4f4f"
		"\\x5050\\x5151\\x5252\\x5353\\x5454\\x5555\\x5656\\x5757"
		"\\x5858\\x5959\\x5a5a\\x5b5b\\x5c5c\\x5d5d\\x5e5e\\x5f5f"
		"\\x6060\\x6161\\x6262\\x6363\\x6464\\x6565\\x6666\\x6767"
		"\\x6868\\x6969\\x6a6a\\x6b6b\\x6c6c\\x6d6d\\x6e6e\\x6f6f"
		"\\x7070\\x7171\\x7272\\x7373\\x7474\\x7575\\x7676\\x7777"
		"\\x7878\\x7979\\x7a7a\\x7b7b\\x7c7c\\x7d7d\\x7e7e\\x7f7f"
		"\\x8080\\x8181\\x8282\\x8383\\x8484\\x8585\\x8686\\x8787"
		"\\x8888\\x8989\\x8a8a\\x8b8b\\x8c8c\\x8d8d\\x8e8e\\x8f8f"
		"\\x9090\\x9191\\x9292\\x9393\\x9494\\x9595\\x9696\\x9797"
		"\\x9898\\x9999\\x9a9a\\x9b9b\\x9c9c\\x9d9d\\x9e9e\\x9f9f"
		"\\xa0a0\\xa1a1\\xa2a2\\xa3a3\\xa4a4\\xa5a5\\xa6a6\\xa7a7"
		"\\xa8a8\\xa9a9\\xaaaa\\xabab\\xacac\\xadad\\xaeae\\xafaf"
		"\\xb0b0\\xb1b1\\xb2b2\\xb3b3\\xb4b4\\xb5b5\\xb6b6\\xb7b7"
		"\\xb8b8\\xb9b9\\xbaba\\xbbbb\\xbcbc\\xbdbd\\xbebe\\xbfbf"
		"\\xc0c0\\xc1c1\\xc2c2\\xc3c3\\xc4c4\\xc5c5\\xc6c6\\xc7c7"
		"\\xc8c8\\xc9c9\\xcaca\\xcbcb\\xcccc\\xcdcd\\xcece\\xcfcf"
		"\\xd0d0\\xd1d1\\xd2d2\\xd3d3\\xd4d4\\xd5d5\\xd6d6\\xd7d7"
		"\\xd8d8\\xd9d9\\xdada\\xdbdb\\xdcdc\\xdddd\\xdede\\xdfdf"
		"\\xe0e0\\xe1e1\\xe2e2\\xe3e3\\xe4e4\\xe5e5\\xe6e6\\xe7e7"
		"\\xe8e8\\xe9e9\\xeaea\\xebeb\\xecec\\xeded\\xeeee\\xefef"
		"\\xf0f0\\xf1f1\\xf2f2\\xf3f3\\xf4f4\\xf5f5\\xf6f6\\xf7f7"
		"\\xf8f8\\xf9f9\\xfafa\\xfbfb\\xfcfc\\xfdfd\\xfefe\\xffff"
		"']");
}
finally
{
	op_free(s);
}

test("UniString::DebugView() escapes hex digits immediately following escape codes")
	require OPDATA_DEBUG;
{
	UniString d;
	char *s = NULL;
	verify_success(d.SetConstData(UNI_L("\n 0\n2 \xfffd")));
	verify_success(d.AppendConstData(UNI_L("cd")));
	s = d.DebugView();
	verify_string(s, "{'\\x000a 0\\x000a\\x0032 \\xfffd\\x0063\\x0064'}");
}
finally
{
	op_free(s);
}

test("UniString::Split() bug from arjanl")
{
#define dir0 "/usr/local/share/opera/plugins"
#define dir1 "/usr/local/lib/npapi/symlinks/opera"
#define dir2 "/usr/local/lib/npapi/symlinks/linux-opera"
#define dir3 "/usr/home/avleeuwen/.mozilla/plugin"
/*
 * We CANNOT trust all compilers to auto-concatenate either
 *   UNI_L("literal" " C " "strings")
 * or
 *   UNI_L("literal") UNI_L(" C ") UNI_L("strings")
 */
#define alldirs "/usr/local/share/opera/plugins:/usr/local/lib/npapi/symlinks/opera:/usr/local/lib/npapi/symlinks/linux-opera:/usr/home/avleeuwen/.mozilla/plugin"

	UniString string;
	verify_success(string.SetConstData(UNI_L(alldirs)));
	verify(string.Length() == uni_strlen(UNI_L(alldirs)));

	OpAutoPtr<OtlCountedList<UniString> > list (string.Split(':'));
	verify(list->Count() == 4);
	unsigned count = 0;
	for (OtlList<UniString>::ConstIterator elem = list->Begin();
		 elem != list->End(); ++elem)
	{
		switch (count)
		{
		case 0:
			verify_string(*elem, UNI_L(dir0));
			break;
		case 1:
			verify_string(*elem, UNI_L(dir1));
			break;
		case 2:
			{
				verify_string(*elem, UNI_L(dir2));

				// Ensure that characters accessed from iterator
				// are the same characters in the actual object.
				UniStringFragmentIterator it(*elem);
				do
				{
					for (size_t i = 0; i < it.GetLength(); i++)
					{
						verify(it.GetData()[i] == UNI_L(dir2)[i]);
					}
				} while (it.Next());

				break;
			}
		case 3:
			verify_string(*elem, UNI_L(dir3));
			break;
		}
		count++;
	}

#undef dir0
#undef dir1
#undef dir2
#undef dir3
#undef alldirs
}

test("Pointer from UniString::CreatePtr(&ptr, true) is truly '\0'-terminated")
{
	UniString d;
	verify_success(d.SetConstData(UNI_L("foobar")));
	d.Trunc(3);
	const uni_char *s;
	verify_success(d.CreatePtr(&s, true));
	verify(s);
	verify_string(s, UNI_L("foo"));
	verify(s[0] == 'f');
	verify(s[1] == 'o');
	verify(s[2] == 'o');
	verify(s[3] == '\0');
}

test("UniString::Split(const uni_char *sep, size_t length)")
{
#define frag1 "SEPARATORThis is the first element (long enough to trigger normal mode storage)"
#define frag2 "SEPARATORThis is the second element (contains an incomplete SEPARATO)SEPARATOR"
#define frag3 "This is the third elementSEPA"
#define frag4 "RATORThis is the fourth element, following a separator that straddles fragment boundariesSEPARATORThis is the fifth element and should be followed by last element, which should be emptySEPARATOR"

	UniString d;
	char *s = NULL;
	verify_success(d.SetConstData(UNI_L(frag1)));
	verify_success(d.AppendConstData(UNI_L(frag2)));
	verify_success(d.AppendConstData(UNI_L(frag3)));
	verify_success(d.AppendConstData(UNI_L(frag4)));
#ifdef OPDATA_DEBUG
	s = d.DebugView();
	verify_string(s, "['" frag1 "'] -> ['" frag2 "'] -> ['" frag3 "'] -> ['" frag4 "']");
#endif // OPDATA_DEBUG

	OpAutoPtr< OtlCountedList<UniString> >ret(d.Split(UNI_L("SEPARATOR")));
	verify(ret.get());
	verify(ret->Length() == 7);
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("This is the first element (long enough to trigger normal mode storage)"));
	verify_string(ret->PopFirst(), UNI_L("This is the second element (contains an incomplete SEPARATO)"));
	verify_string(ret->PopFirst(), UNI_L("This is the third element"));
	verify_string(ret->PopFirst(), UNI_L("This is the fourth element, following a separator that straddles fragment boundaries"));
	verify_string(ret->PopFirst(), UNI_L("This is the fifth element and should be followed by last element, which should be empty"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("SEPARATORX"));
	verify(ret.get());
	verify(ret->Length() == 1);
	verify_string(ret->PopFirst(), UniString(d)); // Copy d to prevent consolidation.
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("SEPARATORT"));
	verify(ret.get());
	verify(ret->Length() == 6);
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("his is the first element (long enough to trigger normal mode storage)"));
	verify_string(ret->PopFirst(), UNI_L("his is the second element (contains an incomplete SEPARATO)"));
	verify_string(ret->PopFirst(), UNI_L("his is the third element"));
	verify_string(ret->PopFirst(), UNI_L("his is the fourth element, following a separator that straddles fragment boundaries"));
	verify_string(ret->PopFirst(), UNI_L("his is the fifth element and should be followed by last element, which should be emptySEPARATOR"));
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("SEPARATO"));
	verify(ret.get());
	verify(ret->Length() == 8);
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("RThis is the first element (long enough to trigger normal mode storage)"));
	verify_string(ret->PopFirst(), UNI_L("RThis is the second element (contains an incomplete "));
	verify_string(ret->PopFirst(), UNI_L(")"));
	verify_string(ret->PopFirst(), UNI_L("RThis is the third element"));
	verify_string(ret->PopFirst(), UNI_L("RThis is the fourth element, following a separator that straddles fragment boundaries"));
	verify_string(ret->PopFirst(), UNI_L("RThis is the fifth element and should be followed by last element, which should be empty"));
	verify_string(ret->PopFirst(), UNI_L("R"));
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("TOR"), 1);
	verify(ret.get());
	verify(ret->Length() == 13);
	verify_string(ret->PopFirst(), UNI_L("SEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify_string(ret->PopFirst(), UNI_L("his is the first element (long enough to trigger normal mode storage)SEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify_string(ret->PopFirst(), UNI_L("his is the second element (contains an incomplete SEPARA"));
	verify_string(ret->PopFirst(), UNI_L("O)SEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify_string(ret->PopFirst(), UNI_L("his is the third elementSEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify_string(ret->PopFirst(), UNI_L("his is the fourth element, following a separator that straddles fragment boundariesSEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify_string(ret->PopFirst(), UNI_L("his is the fifth element and should be followed by last element, which should be emptySEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify(ret->IsEmpty());

	// The above 1-char string separator should be equivalent to the char separator
	ret = d.Split('T');
	verify(ret.get());
	verify(ret->Length() == 13);
	verify_string(ret->PopFirst(), UNI_L("SEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify_string(ret->PopFirst(), UNI_L("his is the first element (long enough to trigger normal mode storage)SEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify_string(ret->PopFirst(), UNI_L("his is the second element (contains an incomplete SEPARA"));
	verify_string(ret->PopFirst(), UNI_L("O)SEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify_string(ret->PopFirst(), UNI_L("his is the third elementSEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify_string(ret->PopFirst(), UNI_L("his is the fourth element, following a separator that straddles fragment boundariesSEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify_string(ret->PopFirst(), UNI_L("his is the fifth element and should be followed by last element, which should be emptySEPARA"));
	verify_string(ret->PopFirst(), UNI_L("OR"));
	verify(ret->IsEmpty());

	// Splitting on empty string should split after each byte
	ret = d.Split(UNI_L(""));
	verify(ret.get());
	verify(ret->Length() == d.Length());
	for (size_t i = 0; i < d.Length(); i++)
	{
		UniString c = ret->PopFirst();
		verify(c.Length() == 1);
		verify(c[0] == d[i]);
	}
	verify(ret->IsEmpty());

	// Split off the 100 first bytes as individual characters, and then the
	// rest of the buffer as the final list element.
	ret = d.Split(UNI_L(""), 0, 100);
	verify(ret.get());
	verify(ret->Length() == 101);
	for (size_t i = 0; i < 100; i++)
	{
		UniString c = ret->PopFirst();
		verify(c.Length() == 1);
		verify(c[0] == d[i]);
	}
	verify_string(ret->PopFirst(), UniString(d, 100));
	verify(ret->IsEmpty());

	// Split off the 0 first bytes as individual characters, and then the
	// rest of the buffer (i.e. the entire buffer) as the only list element.
	ret = d.Split(UNI_L(""), 0, 0);
	verify(ret.get());
	verify(ret->Length() == 1);
	verify_string(ret->PopFirst(), UniString(d));
	verify(ret->IsEmpty());

#undef frag1
#undef frag2
#undef frag3
#undef frag4
}
finally
{
	op_free(s);
}

test("UniString::Split() with more challenging separators")
{
#define frag1 "This is element #1 (long enough to trigger normal mode storage)"
#define frag2 "COCOCONUTThis is element #2C"
#define frag3 "OCOCONUTThis is element #3CO"
#define frag4 "COCONUTThis is element #4COC"
#define frag5 "OCONUTThis is element #5COCO"
#define frag6 "CONUTThis is element #6COCOC"
#define frag7 "ONUTThis is element #7COCOCO"
#define frag8 "NUTThis is element #8COCOCON"
#define frag9 "UTThis is element #9COCOCONU"
#define fragA "TThis is element #ACOCOCONUT"
#define fragB "This is element #BCOCOCONUTThis is element #C (the last)"

	UniString d;
	char *s = NULL;
	verify_success(d.SetConstData(UNI_L(frag1)));
	verify_success(d.AppendConstData(UNI_L(frag2)));
	verify_success(d.AppendConstData(UNI_L(frag3)));
	verify_success(d.AppendConstData(UNI_L(frag4)));
	verify_success(d.AppendConstData(UNI_L(frag5)));
	verify_success(d.AppendConstData(UNI_L(frag6)));
	verify_success(d.AppendConstData(UNI_L(frag7)));
	verify_success(d.AppendConstData(UNI_L(frag8)));
	verify_success(d.AppendConstData(UNI_L(frag9)));
	verify_success(d.AppendConstData(UNI_L(fragA)));
	verify_success(d.AppendConstData(UNI_L(fragB)));
#ifdef OPDATA_DEBUG
	s = d.DebugView();
	verify_string(s, "['" frag1 "'] -> ['" frag2 "'] -> ['" frag3
		"'] -> ['" frag4 "'] -> ['" frag5 "'] -> ['" frag6
		"'] -> ['" frag7 "'] -> ['" frag8 "'] -> ['" frag9
		"'] -> ['" fragA "'] -> ['" fragB "']");
#endif // OPDATA_DEBUG

	OpAutoPtr< OtlCountedList<UniString> >ret(d.Split(UNI_L("COCOCONUT")));
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), UNI_L("This is element #1 (long enough to trigger normal mode storage)"));
	verify_string(ret->PopFirst(), UNI_L("This is element #2"));
	verify_string(ret->PopFirst(), UNI_L("This is element #3"));
	verify_string(ret->PopFirst(), UNI_L("This is element #4"));
	verify_string(ret->PopFirst(), UNI_L("This is element #5"));
	verify_string(ret->PopFirst(), UNI_L("This is element #6"));
	verify_string(ret->PopFirst(), UNI_L("This is element #7"));
	verify_string(ret->PopFirst(), UNI_L("This is element #8"));
	verify_string(ret->PopFirst(), UNI_L("This is element #9"));
	verify_string(ret->PopFirst(), UNI_L("This is element #A"));
	verify_string(ret->PopFirst(), UNI_L("This is element #B"));
	verify_string(ret->PopFirst(), UNI_L("This is element #C (the last)"));
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("COCONUT"));
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), UNI_L("This is element #1 (long enough to trigger normal mode storage)CO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #2CO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #3CO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #4CO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #5CO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #6CO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #7CO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #8CO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #9CO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #ACO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #BCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #C (the last)"));
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("COCOCONUTThis is element #"));
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), UNI_L("This is element #1 (long enough to trigger normal mode storage)"));
	verify_string(ret->PopFirst(), UNI_L("2"));
	verify_string(ret->PopFirst(), UNI_L("3"));
	verify_string(ret->PopFirst(), UNI_L("4"));
	verify_string(ret->PopFirst(), UNI_L("5"));
	verify_string(ret->PopFirst(), UNI_L("6"));
	verify_string(ret->PopFirst(), UNI_L("7"));
	verify_string(ret->PopFirst(), UNI_L("8"));
	verify_string(ret->PopFirst(), UNI_L("9"));
	verify_string(ret->PopFirst(), UNI_L("A"));
	verify_string(ret->PopFirst(), UNI_L("B"));
	verify_string(ret->PopFirst(), UNI_L("C (the last)"));
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("COCONUTThis is element #5"));
	verify(ret.get());
	verify(ret->Length() == 2);
	verify_string(ret->PopFirst(), UNI_L("This is element #1 (long enough to trigger normal mode storage)COCOCONUTThis is element #2COCOCONUTThis is element #3COCOCONUTThis is element #4CO"));
	verify_string(ret->PopFirst(), UNI_L("COCOCONUTThis is element #6COCOCONUTThis is element #7COCOCONUTThis is element #8COCOCONUTThis is element #9COCOCONUTThis is element #ACOCOCONUTThis is element #BCOCOCONUTThis is element #C (the last)"));
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("CO"));
	verify(ret.get());
	verify(ret->Length() == 34);
	verify_string(ret->PopFirst(), UNI_L("This is element #1 (long enough to trigger normal mode storage)"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #2"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #3"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #4"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #5"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #6"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #7"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #8"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #9"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #A"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #B"));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L(""));
	verify_string(ret->PopFirst(), UNI_L("NUTThis is element #C (the last)"));
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("COCO"));
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), UNI_L("This is element #1 (long enough to trigger normal mode storage)"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #2"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #3"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #4"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #5"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #6"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #7"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #8"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #9"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #A"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #B"));
	verify_string(ret->PopFirst(), UNI_L("CONUTThis is element #C (the last)"));
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("CONUT"));
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), UNI_L("This is element #1 (long enough to trigger normal mode storage)COCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #2COCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #3COCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #4COCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #5COCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #6COCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #7COCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #8COCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #9COCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #ACOCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #BCOCO"));
	verify_string(ret->PopFirst(), UNI_L("This is element #C (the last)"));
	verify(ret->IsEmpty());

	ret = d.Split(UNI_L("CON"));
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), UNI_L("This is element #1 (long enough to trigger normal mode storage)COCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #2COCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #3COCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #4COCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #5COCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #6COCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #7COCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #8COCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #9COCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #ACOCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #BCOCO"));
	verify_string(ret->PopFirst(), UNI_L("UTThis is element #C (the last)"));
	verify(ret->IsEmpty());
#undef frag1
#undef frag2
#undef frag3
#undef frag4
#undef frag5
#undef frag6
#undef frag7
#undef frag8
#undef frag9
#undef fragA
#undef fragB
}
finally
{
	op_free(s);
}

test("UniString::Delete()")
{
	UniString d;
	verify_success(d.AppendConstData(UNI_L("Well, there's egg and bacon;")));
	//                                     0     6       14            28
	verify_success(d.AppendConstData(UNI_L(" egg sausage and bacon;")));
	//                                       29                    51
	verify_success(d.AppendConstData(UNI_L(" egg and spam;")));
	//                                       52      60   65
	verify_success(d.AppendConstData(UNI_L(" egg bacon and spam;")));
	//                                       66        76  80   85
	verify_success(d.AppendConstData(UNI_L(" egg bacon sausage and spam;")));
	//                                       86                104 108  113
	verify_success(d.AppendConstData(UNI_L(" spam bacon sausage and spam;")));
	//                                       114  119           133 137  142
	verify_success(d.AppendConstData(UNI_L(" spam egg spam spam bacon and spam;")));
	//                                       143  148 152       162   168 172  177
	verify_success(d.AppendConstData(UNI_L(" spam sausage spam spam bacon spam tomato and spam. And foo.")));
	//                                       178  183     191       201   207  212    219 223  228      237
	verify(d.Length() == 237);

	verify_success(d.Delete(228, 1000));
	verify_success(d.Delete(212, 7));
	verify_success(d.Delete(201, 6));
	verify_success(d.Delete(183, 8));
	verify_success(d.Delete(162, 6));
	verify_success(d.Delete(148, 4));
	verify_success(d.Delete(119, 14));
	verify_success(d.Delete(66, 48));
	verify_success(d.Delete(0, 6));
	verify_success(d.Delete(14 - 6, 46));

	verify_string(d, "there's spam; spam and spam; spam spam spam and spam; spam spam spam spam and spam.");
}

test("UniString::Remove(char remove, ...)")
{
	UniString d;
	verify_success(d.AppendConstData(UNI_L("Well, there's egg and bacon;")));
	verify_success(d.AppendConstData(UNI_L(" egg sausage and bacon;")));
	verify_success(d.AppendConstData(UNI_L(" egg and spam;")));
	verify_success(d.AppendConstData(UNI_L(" egg bacon and spam;")));
	verify_success(d.AppendConstData(UNI_L(" egg bacon sausage and spam;")));
	verify_success(d.AppendConstData(UNI_L(" spam bacon sausage and spam;")));
	verify_success(d.AppendConstData(UNI_L(" spam egg spam spam bacon and spam;")));
	verify_success(d.AppendConstData(UNI_L(" spam sausage spam spam bacon spam tomato and spam. And foo.")));
	verify(d.Length() == 237);

	verify_success(d.Remove('s'));
	verify_success(d.Remove('p'));
	verify_success(d.Remove('a'));
	verify_success(d.Remove('m', 5));

	verify_string(d, "Well, there' egg nd bcon; egg uge nd bcon; egg nd ; egg bcon nd ; egg bcon uge nd ;  bcon uge nd ; m egg m m bcon nd m; m uge m m bcon m tomto nd m. And foo.");
}

test("UniString::Remove(const char *remove, size_length, ...)")
{
	UniString d;
	verify_success(d.AppendConstData(UNI_L("Well, there's egg and bacon;")));
	verify_success(d.AppendConstData(UNI_L(" egg sausage and bacon;")));
	verify_success(d.AppendConstData(UNI_L(" egg and spam;")));
	verify_success(d.AppendConstData(UNI_L(" egg bacon and spam;")));
	verify_success(d.AppendConstData(UNI_L(" egg bacon sausage and spam;")));
	verify_success(d.AppendConstData(UNI_L(" spam bacon sausage and spam;")));
	verify_success(d.AppendConstData(UNI_L(" spam egg spam spam bacon and spam;")));
	verify_success(d.AppendConstData(UNI_L(" spam sausage spam spam bacon spam tomato and spam. And foo.")));
	verify(d.Length() == 237);

	verify_success(d.Remove(UNI_L(" egg")));
	verify_success(d.Remove(UNI_L(" bacon")));
	verify_success(d.Remove(UNI_L(" tomato"), 4));
	verify_success(d.Remove(UNI_L("ato")));
	verify_success(d.Remove(UNI_L(" sausage"), 3));
	verify_success(d.Remove(UNI_L("usage")));
	verify_success(d.Remove(UNI_L(" and"), 4, 5));
	verify_success(d.Remove(UNI_L(" spam"), 5, 2));
	verify_success(d.Remove(UNI_L(";;")));
	verify_success(d.Remove(UNI_L(" And foo.")));

	verify_string(d, "Well, there's spam; spam and spam; spam spam spam and spam; spam spam spam spam and spam.");
}

test("UniString::Append() appending an object to itself")
{
	UniString d;
	char *s = NULL;

	// appending embedded mode to embedded mode - result is in embedded mode
	verify_success(d.SetConstData(UNI_L("foo")));
	verify_success(d.Append(d));
	verify(d.Length() == 6);
	verify(d == UNI_L("foofoo"));

	// appending embedded mode to embedded mode - result is in normal mode
	verify_success(d.SetConstData(UNI_L("Buffer is 19 long..")));
	verify_success(d.Append(d));
	verify_success(d.Append(d));
	verify(d.Length() == 19 * 4);
	verify(d == UNI_L("Buffer is 19 long..Buffer is 19 long..Buffer is 19 long..Buffer is 19 long.."));

	// appending normal mode to normal mode - result is in normal mode
	verify_success(d.SetConstData(UNI_L("This is the first fragment in the buffer. ")));
	verify_success(d.AppendConstData(UNI_L("This is the second fragment. ")));
#ifdef OPDATA_DEBUG
	s = d.DebugView();
	verify_string(s, "['This is the first fragment in the buffer. '] -> ['This is the second fragment. ']");
#endif // OPDATA_DEBUG
	verify_success(d.Append(d));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['This is the first fragment in the buffer. '] -> ['This is the second fragment. '] -> ['This is the first fragment in the buffer. '] -> ['This is the second fragment. ']");
#endif // OPDATA_DEBUG
	verify(d.Length() == 71 * 2);
	verify(d == UNI_L("This is the first fragment in the buffer. This is the second fragment. This is the first fragment in the buffer. This is the second fragment. "));
}
finally
{
	op_free(s);
}

test("UniString::Append() appending a short fragment")
{
	/* Appending a UniString-substring creates a fragmented UniString even if
	 * the resulting string could be consolidated into embedded mode. This test
	 * verifies that it is possible to append another short string to such a
	 * fragmented UniString instance. */
	char* s = NULL;
	UniString uni;

	// Create a short embedded mode UniString:
	verify_success(uni.AppendConstData(UNI_L("Spam")));
	verify_string(uni, "Spam");
#ifdef OPDATA_DEBUG
	s = uni.DebugView();
	verify_string(s, "{'Spam'}");
#endif // OPDATA_DEBUG

	// Create a long normal mode UniString
	UniString normal;
	verify_success(normal.SetConstData(UNI_L("This is element #1 (long enough to trigger normal mode storage)")));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = normal.DebugView();
	verify_string(s, "['This is element #1 (long enough to trigger normal mode storage)']");
#endif // OPDATA_DEBUG

	/* Create a sub-string of the normal mode UniString. This will cause part
	 * to be in normal mode as well, though it is short enough to be in
	 * embedded mode. */
	UniString part(normal, 7, 11);
	// Note: don't call verify_string, because that consolidates the string:
	// verify_string(part, " element #1");
#ifdef OPDATA_DEBUG
	op_free(s);
	s = part.DebugView();
	verify_string(s, "[7+' element #1'+45]");
#endif // OPDATA_DEBUG

	/* The length of the resulting string is short enough to create an embedded
	 * mode string, but the code creates a list of two fragments. */
	verify_success(uni.Append(part));
	// Note: don't call verify_string, because that consolidates the string:
	// verify_string(uni, "Spam element #1 ");
#ifdef OPDATA_DEBUG
	op_free(s);
	s = uni.DebugView();
	verify_string(s, "['Spam'] -> [' element #1']");
#endif // OPDATA_DEBUG

	/* Appending some more data may still create an embedded mode string, but
	 * the code creates now a list of three fragments. */
	verify_success(uni.AppendConstData(UNI_L(".")));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = uni.DebugView();
	verify_string(s, "['Spam'] -> [' element #1'] -> ['.']");
#endif // OPDATA_DEBUG
	verify_string(uni, "Spam element #1.");
}
finally
{
	op_free(s);
}

table unistring_replace_spam(const char* testname, const uni_char a, const uni_char b, size_t maxreplace, OP_STATUS expected_status, size_t expected_replacecount, const char* expected_result)
{
	{ "s/ /_/g",
			' ', '_', OpDataMaxLength, OpStatus::OK, 43,
			"Well,_there's_egg_and_bacon;_egg_sausage_and_bacon;_egg_and_spam;"
			"_egg_bacon_and_spam;_egg_bacon_sausage_and_spam;"
			"_spam_bacon_sausage_and_spam;_spam_egg_spam_spam_bacon_and_spam;"
			"_spam_sausage_spam_spam_bacon_spam_tomato_and_spam._And_foo."
	},
	{ "s/ /_/8",
			' ', '_', 8, OpStatus::OK, 8,
			"Well,_there's_egg_and_bacon;_egg_sausage_and_bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/g/k/3",
			'g', 'k', 3, OpStatus::OK, 3,
			"Well, there's ekk and bacon; ekg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/X/U/",
			'X', 'U', 1, OpStatus::OK, 0,
			"Well, there's egg and bacon; egg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
		/* the following entries use const uni_char* a, const uni_char* b
		 * instead of uni_char a, uni_char b, but selftest does not complain -
		 * otherwise we had to duplicate the test code. */
	{ "s/egg/spam/g",
			UNI_L("egg"), UNI_L("spam"), OpDataMaxLength, OpStatus::OK, 6,
			"Well, there's spam and bacon; spam sausage and bacon; spam and"
			" spam; spam bacon and spam; spam bacon sausage and spam;"
			" spam bacon sausage and spam; spam spam spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/ spam/ ham/8",
			UNI_L(" spam"), UNI_L(" ham"), 8, OpStatus::OK, 8,
			"Well, there's egg and bacon; egg sausage and bacon; egg and ham;"
			" egg bacon and ham; egg bacon sausage and ham;"
			" ham bacon sausage and ham; ham egg ham ham bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/; spam/! ham/3",
			UNI_L("; spam"), UNI_L("! ham"), 3, OpStatus::OK, 3,
			"Well, there's egg and bacon; egg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam! ham bacon sausage"
			" and spam! ham egg spam spam bacon and spam! ham sausage spam spam"
			" bacon spam tomato and spam. And foo."
	},
	{ "s/fish/frog/",
			UNI_L("fish"), UNI_L("frog"), 1, OpStatus::OK, 0,
			"Well, there's egg and bacon; egg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/NULL/spam/",
			NULL, UNI_L("spam"), OpDataMaxLength, OpStatus::ERR, 0,
			"Well, there's egg and bacon; egg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s//fish/",
			UNI_L(""), UNI_L("fish"), OpDataMaxLength, OpStatus::ERR, 0,
			"Well, there's egg and bacon; egg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/spam/NULL/5",
			UNI_L("spam"), NULL, 5, OpStatus::OK, 5,
			"Well, there's egg and bacon; egg sausage and bacon; egg and ;"
			" egg bacon and ; egg bacon sausage and ;"
			"  bacon sausage and ; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
}

foreach (testname, a, b, maxreplace, expected_status, expected_replacecount, expected_result) from unistring_replace_spam
{
	test("UniString::Replace(" testname ")")
	{
		UniString d;
		verify_success(d.AppendConstData(UNI_L("Well, there's egg and bacon;")));
		verify_success(d.AppendConstData(UNI_L(" egg sausage and bacon;")));
		verify_success(d.AppendConstData(UNI_L(" egg and spam;")));
		verify_success(d.AppendConstData(UNI_L(" egg bacon and spam;")));
		verify_success(d.AppendConstData(UNI_L(" egg bacon sausage and spam;")));
		verify_success(d.AppendConstData(UNI_L(" spam bacon sausage and spam;")));
		verify_success(d.AppendConstData(UNI_L(" spam egg spam spam bacon and spam;")));
		verify_success(d.AppendConstData(UNI_L(" spam sausage spam spam bacon spam tomato and spam. And foo.")));
		verify(d.Length() == 237);

		size_t replacecount = 17;
		OP_STATUS rc = d.Replace(a, b, maxreplace, &replacecount);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
			verify(replacecount == expected_replacecount);
		verify_string(d, expected_result);
	}
}

table unistring_split_at_any(const char* testname, const uni_char** string, const uni_char* seq, size_t length, size_t maxsplit, size_t expected_segments, const char** expected_result)
{
	// Test examples from documentation:
	{ "\";,\"",
		{ UNI_L("12;34,567,8;,9,0,"), NULL },
		UNI_L(";,"), OpDataUnknownLength, OpDataFullLength,
		8, {"12", "34", "567", "8", "", "9", "0", "", NULL},
	},
	{ "\";,\",, 3",
		{ UNI_L("12;34,567,8;,9,0,"), NULL },
		UNI_L(";,"), OpDataUnknownLength, 3,
		4, {"12", "34", "567", "8;,9,0,", NULL},
	},
	{ "\";,\",, 6",
		{ UNI_L("12;34,567,8;,9,0,"), NULL },
		UNI_L(";,"), OpDataUnknownLength, 6,
		7, {"12", "34", "567", "8", "", "9", "0,", NULL},
	},
	{ "\";,\",, 0",
		{ UNI_L("12;34,567,8;,9,0,"), NULL },
		UNI_L(";,"), OpDataUnknownLength, 0,
		1, {"12;34,567,8;,9,0,", NULL},
	},
	{ "\"X\",, 6",
		{ UNI_L("12;34,567,8;,9,0,"), NULL },
		UNI_L("X"), OpDataUnknownLength, 6,
		1, {"12;34,567,8;,9,0,", NULL},
	},
	{ "\"ef\"",
		{ UNI_L("abcdefghij"), NULL },
		UNI_L("ef"), OpDataUnknownLength, OpDataFullLength,
		3, {"abcd", "", "ghij", NULL},
	},
	{ "\"\"",
		{ UNI_L("abcdefghij"), NULL },
		UNI_L(""), OpDataUnknownLength, OpDataFullLength,
		1, {"abcdefghij", NULL},
	},
	{ "\"fob\"",
		{ UNI_L("abcdefghij"), NULL },
		UNI_L("fob"), OpDataUnknownLength, 3,
		3, {"a", "cde", "ghij", NULL},
	},
	{ "\"fob\", 0, 3",
		{ UNI_L("abcdefghij"), NULL },
		UNI_L("fob"), 0, 3,
		1, {"abcdefghij", NULL},
	},
	{ "\"fob\", 1, 3",
		{ UNI_L("abcdefghij"), NULL },
		UNI_L("fob"), 1, 3,
		2, {"abcde", "ghij", NULL},
	},
	{ "split cross chunk border",
		{ UNI_L("Well, there's egg and bacon;"),
			UNI_L(" egg sausage and bacon;"),
			UNI_L(" egg and spam;"),
			UNI_L(" egg bacon and spam;"),
			UNI_L(" egg bacon sausage and spam;"),
			UNI_L(" spam bacon sausage and spam;"),
			UNI_L(" spam egg spam spam bacon and spam;"),
			UNI_L(" spam sausage spam spam bacon spam tomato and spam. And foo."),
			NULL },
		UNI_L("c'"), OpDataUnknownLength, OpDataFullLength,
		9,
		{ "Well, there", "s egg and ba", "on; egg sausage and ba",
			"on; egg and spam; egg ba", "on and spam; egg ba",
			"on sausage and spam; spam ba",
			"on sausage and spam; spam egg spam spam ba",
			"on and spam; spam sausage spam spam ba",
			"on spam tomato and spam. And foo.", NULL
		}
	}
}

foreach (testname, string_data, seq, length, maxsplit, expected_segments, expected_data) from unistring_split_at_any
{
	test("UniString::SplitAtAnyOf(" testname ")")
	{
		const uni_char* string_setup[] = string_data;
		UniString d;
		size_t i;
		for (i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		OpAutoPtr< OtlCountedList<UniString> > result(d.SplitAtAnyOf(seq, length, maxsplit));
		verify(result.get());
		verify(result->Length() == expected_segments);
		const char* expected_result[] = expected_data;
		for (i = 0; i < expected_segments; ++i)
			verify_string(result->PopFirst(), expected_result[i]);
		verify(expected_result[i] == NULL);
	}
}
