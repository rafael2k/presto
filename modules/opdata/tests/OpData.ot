/* -*- Mode: c++; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*-
 *
 * Copyright (C) 2011 Opera Software ASA.  All rights reserved.
 *
 * This file is part of the Opera web browser.
 * It may not be distributed under any circumstances.
 */
group "opdata.OpData";

include "modules/opdata/OpData.h";
include "modules/opdata/UniString.h";
include "modules/otl/list.h";
include "modules/opdata/OpDataFragmentIterator.h";
include "modules/opdata/OpDataASCII.h";
include "modules/unicode/unicode_stringiterator.h";

global {
	const char* g_spam_text =
		"Well, there's egg and bacon;"
		" egg sausage and bacon;"
		" egg and spam;"
		" egg bacon and spam;"
		" egg bacon sausage and spam;"
		" spam bacon sausage and spam;"
		" spam egg spam spam bacon and spam;"
		" spam sausage spam spam bacon spam tomato and spam. And foo.";
}

test("OpData::Data()")
{
	OpData d;
	const char *buf = d.Data(false);
	verify(buf);
	buf = d.Data(true);
	verify(buf);
	verify(!buf[d.Length()]);

	verify_success(d.SetConstData(""));
	buf = d.Data(false);
	verify(buf);
	buf = d.Data(true);
	verify(buf);
	verify(!buf[d.Length()]);

	verify_success(d.SetConstData("a"));
	buf = d.Data(false);
	verify(buf);
	buf = d.Data(true);
	verify(buf);
	verify(!buf[d.Length()]);

	verify_success(d.SetConstData("ab"));
	buf = d.Data(false);
	verify(buf);
	buf = d.Data(true);
	verify(buf);
	verify(!buf[d.Length()]);

	verify_success(d.SetConstData("abc"));
	buf = d.Data(false);
	verify(buf);
	buf = d.Data(true);
	verify(buf);
	verify(!buf[d.Length()]);

	verify_success(d.SetConstData("01234567891123456789212345678931234567894123456789"));
	verify_success(d.AppendConstData("01234567891123456789212345678931234567894123456789"));
	verify(d.Length() == 100);
	buf = d.Data(false);
	verify(buf);
	buf = d.Data(true);
	verify(buf);
	verify(!buf[d.Length()]);
}

test("OpData::FindFirst(char needle)")
{
	// embedded mode
	OpData d;
	verify(d.FindFirst('\0') == OpDataNotFound);
	verify(d.FindFirst('0') == OpDataNotFound);
	verify(d.FindFirst('0', 17) == OpDataNotFound);

	verify_success(d.SetConstData(""));
	verify(d.FindFirst('\0') == OpDataNotFound);
	verify(d.FindFirst('0') == OpDataNotFound);
	verify(d.FindFirst('0', 17) == OpDataNotFound);

	verify_success(d.SetConstData("0"));
	verify(d.FindFirst('\0') == OpDataNotFound);
	verify(d.FindFirst('0') == 0);
	verify(d.FindFirst('0', 0) == 0);
	verify(d.FindFirst('0', 0, 1) == 0);
	verify(d.FindFirst('0', 1) == OpDataNotFound);
	verify(d.FindFirst('0', 0, 0) == OpDataNotFound);

	verify_success(d.SetConstData("110"));
	verify(d.FindFirst('\0') == OpDataNotFound);
	verify(d.FindFirst('0') == 2);
	verify(d.FindFirst('0', 1) == 2);
	verify(d.FindFirst('0', 2) == 2);
	verify(d.FindFirst('0', 3) == OpDataNotFound);
	verify(d.FindFirst('0', 17) == OpDataNotFound);
	verify(d.FindFirst('0', 0, 3) == 2);
	verify(d.FindFirst('0', 0, 2) == OpDataNotFound);
	verify(d.FindFirst('0', 1, 2) == 2);
	verify(d.FindFirst('0', 1, 1) == OpDataNotFound);
	verify(d.FindFirst('0', 2, 1) == 2);
	verify(d.FindFirst('0', 2, 0) == OpDataNotFound);

	verify_success(d.SetConstData("110", 4)); // including '\0'-terminator
	verify(d.FindFirst('\0') == 3);
	verify(d.FindFirst('\0', 0) == 3);
	verify(d.FindFirst('\0', 0, 4) == 3);
	verify(d.FindFirst('\0', 0, 3) == OpDataNotFound);
	verify(d.FindFirst('\0', 1, 3) == 3);

	verify_success(d.AppendConstData("098")); // d is now "110\0098"
	verify(d.FindFirst('\0') == 3);
	verify(d.FindFirst('\0', 2) == 3);
	verify(d.FindFirst('0', 0) == 2);
	verify(d.FindFirst('0', 3) == 4);
	verify(d.FindFirst('9') == 5);

	// embeddable mode appended to normal mode
	verify_success(d.SetConstData("0123456789012345678901234567890123456789012345"));
	verify_success(d.AppendConstData("6789X123"));
	verify(d.Length() == 54);
	verify(d.FindFirst('\0') == OpDataNotFound);
	verify(d.FindFirst('0') == 0);
	verify(d.FindFirst('0', 1) == 10);
	verify(d.FindFirst('0', 10) == 10);
	verify(d.FindFirst('0', 11) == 20);
	verify(d.FindFirst('0', 20) == 20);
	verify(d.FindFirst('0', 21) == 30);
	verify(d.FindFirst('0', 30) == 30);
	verify(d.FindFirst('0', 31) == 40);
	verify(d.FindFirst('0', 31, 9) == OpDataNotFound);
	verify(d.FindFirst('0', 31, 10) == 40);
	verify(d.FindFirst('0', 40) == 40);
	verify(d.FindFirst('0', 41) == OpDataNotFound);
	verify(d.FindFirst('0', 50) == OpDataNotFound);
	verify(d.FindFirst('0', 53) == OpDataNotFound);
	verify(d.FindFirst('0', 54) == OpDataNotFound);
	verify(d.FindFirst('0', 60) == OpDataNotFound);
	verify(d.FindFirst('X') == 50);
	verify(d.FindFirst('X', 2) == 50);
	verify(d.FindFirst('X', 49) == 50);
	verify(d.FindFirst('X', 50) == 50);
	verify(d.FindFirst('X', 51) == OpDataNotFound);
	verify(d.FindFirst('F') == OpDataNotFound);

	// normal mode appended to normal mode
	verify_success(d.SetConstData("012345678901234567890123456789012345678901"));
	verify_success(d.AppendConstData("23456789X12345678901234567890123456789012345"));
	verify(d.Length() == 86);
	verify(d.FindFirst('X') == 50);
	verify(d.FindFirst('X', 2) == 50);
	verify(d.FindFirst('X', 2, 48) == OpDataNotFound);
	verify(d.FindFirst('X', 2, 49) == 50);
	verify(d.FindFirst('X', 49) == 50);
	verify(d.FindFirst('X', 50) == 50);
	verify(d.FindFirst('X', 51) == OpDataNotFound);
	verify(d.FindFirst('F') == OpDataNotFound);

	// normal mode, appended to truncated normal mode
	verify_success(d.SetConstData("01234567890123456789012345678901234567890123456789"));
	d.Trunc(42);
	verify_success(d.AppendConstData("23456789X12345678901234567890123456789012345"));
	verify(d.Length() == 86);
	verify(d.FindFirst('X') == 50);
	verify(d.FindFirst('X', 2) == 50);
	verify(d.FindFirst('X', 2, 48) == OpDataNotFound);
	verify(d.FindFirst('X', 2, 49) == 50);
	verify(d.FindFirst('X', 49) == 50);
	verify(d.FindFirst('X', 50) == 50);
	verify(d.FindFirst('X', 51) == OpDataNotFound);
	verify(d.FindFirst('F') == OpDataNotFound);

	// normal mode appended to embedded mode
	verify_success(d.SetConstData("01"));
	verify_success(d.AppendConstData("23456789X12345678901234567890123456789012345"));
	verify(d.Length() == 46);
	verify(d.FindFirst('X') == 10);
	verify(d.FindFirst('X', 2) == 10);
	verify(d.FindFirst('X', 2, 8) == OpDataNotFound);
	verify(d.FindFirst('X', 2, 9) == 10);
	verify(d.FindFirst('X', 9) == 10);
	verify(d.FindFirst('X', 10) == 10);
	verify(d.FindFirst('X', 11) == OpDataNotFound);
	verify(d.FindFirst('F') == OpDataNotFound);
}

test("OpData::FindFirst(const char *needle)")
{
	// embedded mode
	OpData d;
	verify(d.FindFirst("") == 0);
	verify(d.FindFirst("", 0, 0, 0) == 0);
	verify(d.FindFirst("", 0, 0, 1) == 0);
	verify(d.FindFirst("", 0, 1, 0) == OpDataNotFound);
	verify(d.FindFirst("", 0, 1, 1) == OpDataNotFound);
	verify(d.FindFirst("0") == OpDataNotFound);
	verify(d.FindFirst("0", 1, 17) == OpDataNotFound);

	verify_success(d.SetConstData(""));
	verify(d.FindFirst("") == 0);
	verify(d.FindFirst("", 0, 0, 0) == 0);
	verify(d.FindFirst("", 0, 0, 1) == 0);
	verify(d.FindFirst("", 0, 1, 0) == OpDataNotFound);
	verify(d.FindFirst("", 0, 1, 1) == OpDataNotFound);
	verify(d.FindFirst("0") == OpDataNotFound);
	verify(d.FindFirst("0", 1, 17) == OpDataNotFound);

	verify_success(d.SetConstData("0"));
	verify(d.FindFirst("") == 0);
	verify(d.FindFirst("", 0, 0, 0) == 0);
	verify(d.FindFirst("", 0, 0, 1) == 0);
	verify(d.FindFirst("", 0, 1, 0) == 1);
	verify(d.FindFirst("", 0, 1, 1) == 1);
	verify(d.FindFirst("", 0, 2, 0) == OpDataNotFound);
	verify(d.FindFirst("", 0, 2, 1) == OpDataNotFound);
	verify(d.FindFirst("0") == 0);
	verify(d.FindFirst("0", 1, 0) == 0);
	verify(d.FindFirst("0", 1, 0, 1) == 0);
	verify(d.FindFirst("0", 1, 1) == OpDataNotFound);
	verify(d.FindFirst("0", 1, 0, 0) == OpDataNotFound);
	verify(d.FindFirst("00") == OpDataNotFound);
	verify(d.FindFirst("00", 2) == OpDataNotFound);
	verify(d.FindFirst("00", 1) == 0);
	verify(d.FindFirst("00", 1, 0) == 0);
	verify(d.FindFirst("00", 1, 0, 1) == 0);
	verify(d.FindFirst("00", 1, 1) == OpDataNotFound);
	verify(d.FindFirst("00", 1, 0, 0) == OpDataNotFound);

	verify_success(d.SetConstData("110"));
	verify(d.FindFirst("1") == 0);
	verify(d.FindFirst("1", 1, 1) == 1);
	verify(d.FindFirst("11") == 0);
	verify(d.FindFirst("11", 2, 1) == OpDataNotFound);
	verify(d.FindFirst("110") == 0);
	verify(d.FindFirst("110", 3, 1) == OpDataNotFound);
	verify(d.FindFirst("110", 3, 0) == 0);
	verify(d.FindFirst("110", 3, 0, 0) == OpDataNotFound);
	verify(d.FindFirst("110", 3, 0, 1) == OpDataNotFound);
	verify(d.FindFirst("110", 3, 0, 2) == OpDataNotFound);
	verify(d.FindFirst("110", 3, 0, 3) == 0);
	verify(d.FindFirst("110", 4, 0, 0) == OpDataNotFound); // with '\0'
	verify(d.FindFirst("110", 4, 0, 1) == OpDataNotFound);
	verify(d.FindFirst("110", 4, 0, 2) == OpDataNotFound);
	verify(d.FindFirst("110", 4, 0, 3) == OpDataNotFound);
	verify(d.FindFirst("110", 4, 0, 4) == OpDataNotFound);
	verify(d.FindFirst("10", 2, 0, 3) == 1);
	verify(d.FindFirst("10", 2, 0, 2) == OpDataNotFound);
	verify(d.FindFirst("10", 2, 1, 2) == 1);
	verify(d.FindFirst("10", 2, 1, 1) == OpDataNotFound);
	verify(d.FindFirst("10", 3, 0, 17) == OpDataNotFound); // with '\0'

	verify_success(d.SetConstData("110", 4)); // including '\0'-terminator
	verify(d.FindFirst("1") == 0);
	verify(d.FindFirst("110") == 0);
	verify(d.FindFirst("110", 3, 1) == OpDataNotFound);
	verify(d.FindFirst("110", 3, 0) == 0);
	verify(d.FindFirst("110", 4, 1) == OpDataNotFound); // with '\0'
	verify(d.FindFirst("110", 4, 0) == 0);
	verify(d.FindFirst("110", 4, 0, 0) == OpDataNotFound);
	verify(d.FindFirst("110", 4, 0, 1) == OpDataNotFound);
	verify(d.FindFirst("110", 4, 0, 2) == OpDataNotFound);
	verify(d.FindFirst("110", 4, 0, 3) == OpDataNotFound);
	verify(d.FindFirst("110", 4, 0, 4) == 0);
	verify(d.FindFirst("10", 2, 0, 3) == 1);
	verify(d.FindFirst("10", 2, 0, 2) == OpDataNotFound);
	verify(d.FindFirst("10", 2, 1, 2) == 1);
	verify(d.FindFirst("10", 2, 1, 1) == OpDataNotFound);
	verify(d.FindFirst("10", 3, 0, 4) == 1);
	verify(d.FindFirst("10", 3, 0, 3) == OpDataNotFound);
	verify(d.FindFirst("10", 3, 1, 3) == 1);
	verify(d.FindFirst("10", 3, 1, 2) == OpDataNotFound);
	verify(d.FindFirst("10", 3, 2, 2) == OpDataNotFound);
	verify(d.FindFirst("10", 3, 2, 1) == OpDataNotFound);
	verify(d.FindFirst("10", 3, 3, 1) == OpDataNotFound);
	verify(d.FindFirst("10", 3, 3, 0) == OpDataNotFound);

	verify_success(d.AppendConstData("098")); // d is now "110\0098"
	verify(d.FindFirst("", 1) == 3);
	verify(d.FindFirst("", 1, 2) == 3);
	verify(d.FindFirst("0", 2, 0) == 2);
	verify(d.FindFirst("0", 2, 3) == OpDataNotFound);
	verify(d.FindFirst("0", 1, 3) == 4);
	verify(d.FindFirst("\0" "0", 2) == 3);
	verify(d.FindFirst("9") == 5);
	verify(d.FindFirst("0\0" "0", 3) == 2);

	// normal mode
	verify_success(d.SetConstData("0123456789012345678901234567890123456789012345"));
	verify_success(d.AppendConstData("6789X123"));
	verify(d.Length() == 54);
	verify(d.FindFirst("0123456789") == 0);
	verify(d.FindFirst("0123456789", 10) == 0);
	verify(d.FindFirst("0123456789", 10, 1) == 10);
	verify(d.FindFirst("0123456789", 10, 9) == 10);
	verify(d.FindFirst("0123456789", 10, 10) == 10);
	verify(d.FindFirst("0123456789", 10, 11) == 20);
	verify(d.FindFirst("0123456789", 10, 31) == 40);
	verify(d.FindFirst("0123456789", 10, 41) == OpDataNotFound);
	verify(d.FindFirst("X123", 4, 41) == 50);
	verify(d.FindFirst("X123", 4, 41, 10) == OpDataNotFound);
	verify(d.FindFirst("X123", 4, 41, 13) == 50);
}

test("OpData::FindFirstOf()")
{
	// embedded mode
	OpData d;
	verify(d.FindFirstOf("") == OpDataNotFound);
	verify(d.FindFirstOf("foo") == OpDataNotFound);

	verify_success(d.SetConstData(""));
	verify(d.FindFirstOf("") == OpDataNotFound);
	verify(d.FindFirstOf("foo") == OpDataNotFound);

	verify_success(d.SetConstData("123"));
	verify(d.FindFirstOf("") == OpDataNotFound);
	verify(d.FindFirstOf("foo") == OpDataNotFound);
	verify(d.FindFirstOf("123") == 0);
	verify(d.FindFirstOf("23") == 1);
	verify(d.FindFirstOf("3") == 2);
	verify(d.FindFirstOf("123", 3, 0) == 0);
	verify(d.FindFirstOf("123", 3, 1) == 1);
	verify(d.FindFirstOf("123", 3, 2) == 2);
	verify(d.FindFirstOf("123", 3, 3) == OpDataNotFound);
	verify(d.FindFirstOf("1", 1, 0) == 0);
	verify(d.FindFirstOf("1", 1, 1) == OpDataNotFound);
	verify(d.FindFirstOf("3", 1, 2) == 2);
	verify(d.FindFirstOf("3", 1, 2, 0) == OpDataNotFound);
	verify(d.FindFirstOf("3", 1, 2, 1) == 2);
	verify(d.FindFirstOf("3", 1, 1, 1) == OpDataNotFound);
	verify(d.FindFirstOf("3", 1, 1, 2) == 2);
	verify(d.FindFirstOf("3", 1, 0, 2) == OpDataNotFound);
	verify(d.FindFirstOf("3", 1, 0, 3) == 2);
	verify(d.FindFirstOf("foofoofoospamspamspamX3X") == 2);

	verify_success(d.SetConstData("123", 4)); // including '\0'-terminator
	verify(d.FindFirstOf("") == OpDataNotFound);
	verify(d.FindFirstOf("", 1) == 3); // with '\0'
	verify(d.FindFirstOf("", 1, 0, 4) == 3);
	verify(d.FindFirstOf("", 1, 0, 3) == OpDataNotFound);
	verify(d.FindFirstOf("", 1, 1, 3) == 3);
	verify(d.FindFirstOf("", 1, 1, 2) == OpDataNotFound);
	verify(d.FindFirstOf("", 1, 2, 2) == 3);
	verify(d.FindFirstOf("", 1, 2, 1) == OpDataNotFound);
	verify(d.FindFirstOf("", 1, 3, 1) == 3);
	verify(d.FindFirstOf("", 1, 3, 0) == OpDataNotFound);

	verify_success(d.AppendConstData("098")); // d is now "123\0098"
	verify(d.FindFirstOf("", 1) == 3);
	verify(d.FindFirstOf("", 1, 2) == 3);
	verify(d.FindFirstOf("0") == 4);
	verify(d.FindFirstOf("0", 1) == 4);
	verify(d.FindFirstOf("0", 2) == 3);
	verify(d.FindFirstOf("9") == 5);

	// normal mode
	verify_success(d.SetConstData("0123456789012345678901234567890123456789012345"));
	verify_success(d.AppendConstData("6789X123"));
	verify(d.Length() == 54);
	verify(d.FindFirstOf("0123456789") == 0);
	verify(d.FindFirstOf("0123456789", 10, 0) == 0);
	verify(d.FindFirstOf("0123456789", 10, 1) == 1);
	verify(d.FindFirstOf("0123456789", 10, 2) == 2);
	verify(d.FindFirstOf("0123456789", 10, 3) == 3);
	verify(d.FindFirstOf("0123456789", 10, 4) == 4);
	verify(d.FindFirstOf("foox") == OpDataNotFound);
	verify(d.FindFirstOf("fooX") == 50);
	verify(d.FindFirstOf("foox", 5) == OpDataNotFound); // with '\0'
	verify(d.FindFirstOf("fooX", 4, 10) == 50);
	verify(d.FindFirstOf("fooX", 4, 49) == 50);
	verify(d.FindFirstOf("fooX", 4, 50) == 50);
	verify(d.FindFirstOf("fooX", 4, 51) == OpDataNotFound);
	verify(d.FindFirstOf("0123456789", 10, 50) == 51);
}

test("OpData::FindEndOf()")
{
	// embedded mode
	OpData d;
	verify(d.FindEndOf("") == OpDataNotFound);
	verify(d.FindEndOf("foo") == OpDataNotFound);

	verify_success(d.SetConstData(""));
	verify(d.FindEndOf("") == OpDataNotFound);
	verify(d.FindEndOf("foo") == OpDataNotFound);

	verify_success(d.SetConstData("", 1));
	verify(d.FindEndOf("") == 0);
	verify(d.FindEndOf("", 1) == OpDataNotFound);
	verify(d.FindEndOf("foo") == 0);
	verify(d.FindEndOf("foo", 4) == OpDataNotFound);

	verify_success(d.SetConstData("123"));
	verify(d.FindEndOf("") == 0);
	verify(d.FindEndOf("foo") == 0);
	verify(d.FindEndOf("123") == OpDataNotFound);
	verify(d.FindEndOf("12") == 2);
	verify(d.FindEndOf("1") == 1);
	verify(d.FindEndOf("2") == 0);
	verify(d.FindEndOf("2", 1, 1) == 2);
	verify(d.FindEndOf("foofoofoospamspamspamX12X") == 2);

	verify_success(d.SetConstData("321", 4)); // including '\0'-terminator
	verify(d.FindEndOf("123", 3) == 3);
	verify(d.FindEndOf("123", 4) == OpDataNotFound);

	verify_success(d.AppendConstData("098")); // d is now "321\0098"
	verify(d.FindEndOf("123", 3) == 3);
	verify(d.FindEndOf("123", 4) == 4);
	verify(d.FindEndOf("0123", 5, 2) == 5);
	verify(d.FindEndOf("90123", 6) == 6);
	verify(d.FindEndOf("890123", 7) == OpDataNotFound);
	verify(d.FindEndOf("0", 2, 3, 3) == 5);
	verify(d.FindEndOf("0", 2, 3, 2) == OpDataNotFound);

	// normal mode
	verify_success(d.SetConstData("0123456789012345678901234567890123456789012345"));
	verify_success(d.AppendConstData("6789X123"));
	verify(d.Length() == 54);
	verify(d.FindEndOf("X") == 0);
	verify(d.FindEndOf("X0") == 1);
	verify(d.FindEndOf("X01") == 2);
	verify(d.FindEndOf("X012") == 3);
	verify(d.FindEndOf("X0123") == 4);
	verify(d.FindEndOf("X01234") == 5);
	verify(d.FindEndOf("X012345") == 6);
	verify(d.FindEndOf("X0123456") == 7);
	verify(d.FindEndOf("X01234567") == 8);
	verify(d.FindEndOf("X012345678") == 9);
	verify(d.FindEndOf("X0123456789") == OpDataNotFound);
	verify(d.FindEndOf("0123456789") == 50);
	verify(d.FindEndOf("6789X12", 7, 46) == 53);
	verify(d.FindEndOf("6789X12", 7, 46, 7) == OpDataNotFound);
	verify(d.FindEndOf("6789X12", 7, 46, 8) == 53);
	verify(d.FindEndOf("0123456789", 10, 50) == 50);
}

test("OpData::FindLast(char needle)")
{
	// embedded mode
	OpData d;
	verify(d.FindLast('\0') == OpDataNotFound);
	verify(d.FindLast('0') == OpDataNotFound);
	verify(d.FindLast('0', 17) == OpDataNotFound);

	verify_success(d.SetConstData(""));
	verify(d.FindLast('\0') == OpDataNotFound);
	verify(d.FindLast('0') == OpDataNotFound);
	verify(d.FindLast('0', 17) == OpDataNotFound);

	verify_success(d.SetConstData("0"));
	verify(d.FindLast('\0') == OpDataNotFound);
	verify(d.FindLast('0') == 0);
	verify(d.FindLast('0', 0) == 0);
	verify(d.FindLast('0', 0, 1) == 0);
	verify(d.FindLast('0', 1) == OpDataNotFound);
	verify(d.FindLast('0', 0, 0) == OpDataNotFound);

	verify_success(d.SetConstData("00"));
	verify(d.FindLast('0') == 1);
	verify(d.FindLast('0', 0) == 1);
	verify(d.FindLast('0', 0, 1) == 0);
	verify(d.FindLast('0', 2) == OpDataNotFound);
	verify(d.FindLast('0', 1, 0) == OpDataNotFound);
	verify(d.FindLast('0', 0, 0) == OpDataNotFound);

	verify_success(d.SetConstData("110"));
	verify(d.FindLast('\0') == OpDataNotFound);
	verify(d.FindLast('1') == 1);
	verify(d.FindLast('1', 1) == 1);
	verify(d.FindLast('1', 2) == OpDataNotFound);
	verify(d.FindLast('1', 0, 1) == 0);
	verify(d.FindLast('1', 17) == OpDataNotFound);
	verify(d.FindLast('1', 0, 2) == 1);
	verify(d.FindLast('1', 0, 1) == 0);
	verify(d.FindLast('1', 1, 1) == 1);
	verify(d.FindLast('1', 1, 0) == OpDataNotFound);
	verify(d.FindLast('1', 2, 1) == OpDataNotFound);
	verify(d.FindLast('1', 2, 0) == OpDataNotFound);

	verify_success(d.SetConstData("110", 4)); // including '\0'-terminator
	verify(d.FindLast('\0') == 3);
	verify(d.FindLast('\0', 0) == 3);
	verify(d.FindLast('\0', 0, 4) == 3);
	verify(d.FindLast('\0', 0, 3) == OpDataNotFound);
	verify(d.FindLast('\0', 1, 3) == 3);

	verify_success(d.AppendConstData("098")); // d is now "110\0098"
	verify(d.FindLast('\0') == 3);
	verify(d.FindLast('\0', 2) == 3);
	verify(d.FindLast('0', 0) == 4);
	verify(d.FindLast('0', 0, 3) == 2);
	verify(d.FindLast('9') == 5);

	// embeddable mode appended to normal mode
	verify_success(d.SetConstData("0123456789012345678901234567890123456789012345"));
	verify_success(d.AppendConstData("6789X123"));
	verify(d.Length() == 54);
	verify(d.FindLast('\0') == OpDataNotFound);
	verify(d.FindLast('0') == 40);
	verify(d.FindLast('0', 0, 40) == 30);
	verify(d.FindLast('0', 0, 30) == 20);
	verify(d.FindLast('0', 0, 20) == 10);
	verify(d.FindLast('0', 0, 10) == 0);
	verify(d.FindLast('0', 0, 0) == OpDataNotFound);
	verify(d.FindLast('X') == 50);
	verify(d.FindLast('X', 2) == 50);
	verify(d.FindLast('X', 49) == 50);
	verify(d.FindLast('X', 50) == 50);
	verify(d.FindLast('X', 51) == OpDataNotFound);
	verify(d.FindLast('F') == OpDataNotFound);

	// normal mode appended to normal mode
	verify_success(d.SetConstData("0123456789X1234567890123456789012345678901"));
	verify_success(d.AppendConstData("23456789012345678901234567890123456789012345"));
	verify(d.Length() == 86);
	verify(d.FindLast('5') == 85);
	verify(d.FindLast('4') == 84);
	verify(d.FindLast('3') == 83);
	verify(d.FindLast('2') == 82);
	verify(d.FindLast('1') == 81);
	verify(d.FindLast('0') == 80);
	verify(d.FindLast('X') == 10);
	verify(d.FindLast('X', 2) == 10);
	verify(d.FindLast('X', 2, 8) == OpDataNotFound);
	verify(d.FindLast('X', 2, 9) == 10);
	verify(d.FindLast('X', 9) == 10);
	verify(d.FindLast('X', 10) == 10);
	verify(d.FindLast('X', 11) == OpDataNotFound);
	verify(d.FindLast('F') == OpDataNotFound);

	// normal mode, appended to truncated normal mode
	verify_success(d.SetConstData("0123456789X123456789012345678901234567890123456789"));
	d.Trunc(42);
	verify_success(d.AppendConstData("23456789012345678901234567890123456789012345"));
	d.Trunc(80);
	verify(d.Length() == 80);
	verify(d.FindLast('5') == 75);
	verify(d.FindLast('4') == 74);
	verify(d.FindLast('3') == 73);
	verify(d.FindLast('2') == 72);
	verify(d.FindLast('1') == 71);
	verify(d.FindLast('0') == 70);
	verify(d.FindLast('9', 0, 50) == 49);
	verify(d.FindLast('8', 0, 50) == 48);
	verify(d.FindLast('7', 0, 50) == 47);
	verify(d.FindLast('6', 0, 50) == 46);
	verify(d.FindLast('5', 0, 50) == 45);
	verify(d.FindLast('4', 0, 50) == 44);
	verify(d.FindLast('3', 0, 50) == 43);
	verify(d.FindLast('2', 0, 50) == 42);
	verify(d.FindLast('1', 0, 50) == 41);
	verify(d.FindLast('0', 0, 50) == 40);
	verify(d.FindLast('X') == 10);
	verify(d.FindLast('X', 2) == 10);
	verify(d.FindLast('X', 2, 8) == OpDataNotFound);
	verify(d.FindLast('X', 2, 9) == 10);
	verify(d.FindLast('X', 9) == 10);
	verify(d.FindLast('X', 10) == 10);
	verify(d.FindLast('X', 11) == OpDataNotFound);
	verify(d.FindLast('F') == OpDataNotFound);

	// normal mode appended to embedded mode
	verify_success(d.SetConstData("01"));
	verify_success(d.AppendConstData("23456789X12345678901234567890123456789012345"));
	verify(d.Length() == 46);
	verify(d.FindLast('X') == 10);
	verify(d.FindLast('X', 2) == 10);
	verify(d.FindLast('X', 2, 8) == OpDataNotFound);
	verify(d.FindLast('X', 2, 9) == 10);
	verify(d.FindLast('X', 9) == 10);
	verify(d.FindLast('X', 10) == 10);
	verify(d.FindLast('X', 11) == OpDataNotFound);
	verify(d.FindLast('F') == OpDataNotFound);
}

test("OpData::FindLast(const char *needle)")
{
	// embedded mode
	OpData d;
	verify(d.FindLast("") == 0);
	verify(d.FindLast("", 0, 0, 0) == 0);
	verify(d.FindLast("", 0, 0, 1) == 0);
	verify(d.FindLast("", 0, 1, 0) == OpDataNotFound);
	verify(d.FindLast("", 0, 1, 1) == OpDataNotFound);
	verify(d.FindLast("0") == OpDataNotFound);
	verify(d.FindLast("0", 1, 17) == OpDataNotFound);

	verify_success(d.SetConstData("\0" "blahblah0123"));
	verify(d.FindLast("") == 0);
	verify(d.FindLast("", 0, 0, 0) == 0);
	verify(d.FindLast("", 0, 0, 1) == 0);
	verify(d.FindLast("", 0, 1, 0) == OpDataNotFound);
	verify(d.FindLast("", 0, 1, 1) == OpDataNotFound);
	verify(d.FindLast("0") == OpDataNotFound);
	verify(d.FindLast("0", 1, 17) == OpDataNotFound);

	verify_success(d.SetConstData("0"));
	verify(d.FindLast("") == 1);
	verify(d.FindLast("", 0, 0, 0) == 0);
	verify(d.FindLast("", 0, 0, 1) == 1);
	verify(d.FindLast("", 0, 1, 0) == 1);
	verify(d.FindLast("", 0, 1, 1) == 1);
	verify(d.FindLast("", 0, 2, 0) == OpDataNotFound);
	verify(d.FindLast("", 0, 2, 1) == OpDataNotFound);
	verify(d.FindLast("0") == 0);
	verify(d.FindLast("0", 1, 0) == 0);
	verify(d.FindLast("0", 1, 0, 1) == 0);
	verify(d.FindLast("0", 1, 1) == OpDataNotFound);
	verify(d.FindLast("0", 1, 0, 0) == OpDataNotFound);
	verify(d.FindLast("00") == OpDataNotFound);
	verify(d.FindLast("00", 2) == OpDataNotFound);
	verify(d.FindLast("00", 1) == 0);
	verify(d.FindLast("00", 1, 0) == 0);
	verify(d.FindLast("00", 1, 0, 1) == 0);
	verify(d.FindLast("00", 1, 1) == OpDataNotFound);
	verify(d.FindLast("00", 1, 0, 0) == OpDataNotFound);

	verify_success(d.SetConstData("00"));
	verify(d.FindLast("0") == 1);
	verify(d.FindLast("0", 1, 0) == 1);
	verify(d.FindLast("0", 1, 0, 1) == 0);
	verify(d.FindLast("0", 1, 2) == OpDataNotFound);
	verify(d.FindLast("0", 1, 1, 0) == OpDataNotFound);
	verify(d.FindLast("0", 1, 0, 0) == OpDataNotFound);
	verify(d.FindLast("00") == 0);
	verify(d.FindLast("00", 2, 0, 2) == 0);
	verify(d.FindLast("00", 2, 0, 1) == OpDataNotFound);
	verify(d.FindLast("00", 2, 1, 2) == OpDataNotFound);

	verify_success(d.SetConstData("110"));
	verify(d.FindLast("1") == 1);
	verify(d.FindLast("1", 1, 1) == 1);
	verify(d.FindLast("11") == 0);
	verify(d.FindLast("11", 2, 1) == OpDataNotFound);
	verify(d.FindLast("110") == 0);
	verify(d.FindLast("110", 3, 1) == OpDataNotFound);
	verify(d.FindLast("110", 3, 0) == 0);
	verify(d.FindLast("110", 3, 0, 0) == OpDataNotFound);
	verify(d.FindLast("110", 3, 0, 1) == OpDataNotFound);
	verify(d.FindLast("110", 3, 0, 2) == OpDataNotFound);
	verify(d.FindLast("110", 3, 0, 3) == 0);
	verify(d.FindLast("110", 4, 0, 0) == OpDataNotFound); // with '\0'
	verify(d.FindLast("110", 4, 0, 1) == OpDataNotFound);
	verify(d.FindLast("110", 4, 0, 2) == OpDataNotFound);
	verify(d.FindLast("110", 4, 0, 3) == OpDataNotFound);
	verify(d.FindLast("110", 4, 0, 4) == OpDataNotFound);
	verify(d.FindLast("10", 2, 0, 3) == 1);
	verify(d.FindLast("10", 2, 0, 2) == OpDataNotFound);
	verify(d.FindLast("10", 2, 1, 2) == 1);
	verify(d.FindLast("10", 2, 1, 1) == OpDataNotFound);
	verify(d.FindLast("10", 3, 0, 17) == OpDataNotFound); // with '\0'

	verify_success(d.SetConstData("110", 4)); // including '\0'-terminator
	verify(d.FindLast("1") == 1);
	verify(d.FindLast("110") == 0);
	verify(d.FindLast("110", 3, 1) == OpDataNotFound);
	verify(d.FindLast("110", 3, 0) == 0);
	verify(d.FindLast("110", 4, 1) == OpDataNotFound); // with '\0'
	verify(d.FindLast("110", 4, 0) == 0);
	verify(d.FindLast("110", 4, 0, 0) == OpDataNotFound);
	verify(d.FindLast("110", 4, 0, 1) == OpDataNotFound);
	verify(d.FindLast("110", 4, 0, 2) == OpDataNotFound);
	verify(d.FindLast("110", 4, 0, 3) == OpDataNotFound);
	verify(d.FindLast("110", 4, 0, 4) == 0);
	verify(d.FindLast("10", 2, 0, 3) == 1);
	verify(d.FindLast("10", 2, 0, 2) == OpDataNotFound);
	verify(d.FindLast("10", 2, 1, 2) == 1);
	verify(d.FindLast("10", 2, 1, 1) == OpDataNotFound);
	verify(d.FindLast("10", 3, 0, 4) == 1);
	verify(d.FindLast("10", 3, 0, 3) == OpDataNotFound);
	verify(d.FindLast("10", 3, 1, 3) == 1);
	verify(d.FindLast("10", 3, 1, 2) == OpDataNotFound);
	verify(d.FindLast("10", 3, 2, 2) == OpDataNotFound);
	verify(d.FindLast("10", 3, 2, 1) == OpDataNotFound);
	verify(d.FindLast("10", 3, 3, 1) == OpDataNotFound);
	verify(d.FindLast("10", 3, 3, 0) == OpDataNotFound);

	verify_success(d.AppendConstData("098")); // d is now "110\0098"
	verify(d.FindLast("", 1) == 3);
	verify(d.FindLast("", 1, 2) == 3);
	verify(d.FindLast("0", 2, 0) == 2);
	verify(d.FindLast("0", 2, 3) == OpDataNotFound);
	verify(d.FindLast("0", 1, 0) == 4);
	verify(d.FindLast("0", 1, 0, 3) == 2);
	verify(d.FindLast("\0" "0", 2) == 3);
	verify(d.FindLast("9") == 5);
	verify(d.FindLast("0\0" "0", 3) == 2);

	// normal mode
	verify_success(d.SetConstData("0123456789X12345678901234567890123456789012345"));
	verify_success(d.AppendConstData("67890123"));
	verify(d.Length() == 54);
	verify(d.FindLast("0123456789") == 40);
	verify(d.FindLast("0123456789", 10) == 40);
	verify(d.FindLast("0123456789", 10, 0, 50) == 40);
	verify(d.FindLast("0123456789", 10, 0, 49) == 30);
	verify(d.FindLast("0123456789", 10, 0, 39) == 20);
	verify(d.FindLast("0123456789", 10, 0, 29) == 0);
	verify(d.FindLast("0123456789", 10, 0, 19) == 0);
	verify(d.FindLast("0123456789", 10, 0, 10) == 0);
	verify(d.FindLast("0123456789", 10, 0, 9) == OpDataNotFound);
	verify(d.FindLast("X123", 4) == 10);
	verify(d.FindLast("X123", 4, 10) == 10);
	verify(d.FindLast("X123", 4, 11) == OpDataNotFound);
}

test("OpData::FindLast(const char *needle) with trickier needles and haystacks")
{
#define frag0 "A long text forcing this object into normal mode. "
#define fragN " trailing data..."
	char *s = NULL;
	OpData d;

	verify_success(d.SetConstData(frag0));
	verify_success(d.AppendConstData("CO"));
	verify_success(d.AppendConstData("NUT"));
	verify_success(d.AppendConstData(fragN));
#ifdef OPDATA_DEBUG
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['CO'] -> ['NUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast("COCONUT") == OpDataNotFound);
	verify(d.FindLast("CONUT") == op_strlen(frag0));

	verify_success(d.SetConstData(frag0));
	verify_success(d.AppendConstData("CO"));
	verify_success(d.AppendConstData("CONUT"));
	verify_success(d.AppendConstData(fragN));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['CO'] -> ['CONUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast("COCONUT") == op_strlen(frag0));
	verify(d.FindLast("CONUT") == op_strlen(frag0) + 2);

	verify_success(d.SetConstData(frag0));
	verify_success(d.AppendConstData("CO"));
	verify_success(d.AppendConstData("CO"));
	verify_success(d.AppendConstData("NUT"));
	verify_success(d.AppendConstData(fragN));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['CO'] -> ['CO'] -> ['NUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast("COCONUT") == op_strlen(frag0));
	verify(d.FindLast("CONUT") == op_strlen(frag0) + 2);

	verify_success(d.SetConstData(frag0));
	verify_success(d.AppendConstData("COCO"));
	verify_success(d.AppendConstData("NUT"));
	verify_success(d.AppendConstData(fragN));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['COCO'] -> ['NUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast("COCONUT") == op_strlen(frag0));
	verify(d.FindLast("CONUT") == op_strlen(frag0) + 2);

	verify_success(d.SetConstData(frag0));
	verify_success(d.AppendConstData("COCO"));
	verify_success(d.AppendConstData("CONUT"));
	verify_success(d.AppendConstData(fragN));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['COCO'] -> ['CONUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast("COCOCONUT") == op_strlen(frag0));
	verify(d.FindLast("COCONUT") == op_strlen(frag0) + 2);
	verify(d.FindLast("CONUT") == op_strlen(frag0) + 4);

	verify_success(d.SetConstData(frag0));
	verify_success(d.AppendConstData("CO"));
	verify_success(d.AppendConstData("CO"));
	verify_success(d.AppendConstData("CONUT"));
	verify_success(d.AppendConstData(fragN));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['CO'] -> ['CO'] -> ['CONUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast("COCOCONUT") == op_strlen(frag0));
	verify(d.FindLast("COCONUT") == op_strlen(frag0) + 2);
	verify(d.FindLast("CONUT") == op_strlen(frag0) + 4);

	verify_success(d.SetConstData(frag0));
	verify_success(d.AppendConstData("CO"));
	verify_success(d.AppendConstData("CO"));
	verify_success(d.AppendConstData("CO"));
	verify_success(d.AppendConstData("NUT"));
	verify_success(d.AppendConstData(fragN));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['CO'] -> ['CO'] -> ['CO'] -> ['NUT'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast("COCOCONUT") == op_strlen(frag0));
	verify(d.FindLast("COCONUT") == op_strlen(frag0) + 2);
	verify(d.FindLast("CONUT") == op_strlen(frag0) + 4);

	verify_success(d.SetConstData(frag0));
	verify_success(d.AppendConstData("xxx"));
	verify_success(d.AppendConstData("x"));
	verify_success(d.AppendConstData("xx"));
	verify_success(d.AppendConstData(fragN));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['" frag0 "'] -> ['xxx'] -> ['x'] -> ['xx'] -> ['" fragN "']");
#endif // OPDATA_DEBUG
	verify(d.FindLast("x") == op_strlen(frag0) + 5);
	verify(d.FindLast("xx") == op_strlen(frag0) + 4);
	verify(d.FindLast("xxx") == op_strlen(frag0) + 3);
	verify(d.FindLast("xxxx") == op_strlen(frag0) + 2);
	verify(d.FindLast("xxxxx") == op_strlen(frag0) + 1);
	verify(d.FindLast("xxxxxx") == op_strlen(frag0) + 0);
	verify(d.FindLast("xxxxxxx") == OpDataNotFound);
}
finally
{
	op_free(s);
}

table opdata_toint(
	const char* testname, const uni_char** string_data,
	size_t base, size_t offset,
	OP_STATUS expected_status, int expected_value, size_t expected_length)
{
	{ "<empty>", { NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ " ", { " ", NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "1", { "1", NULL },
			10, 0, OpStatus::OK, 1, 1 },
	{ "+1234", { " +1234 ", NULL },
			10, 0, OpStatus::OK, 1234, 6 },
	{ "-1234", { " -1234 ", NULL },
			10, 0, OpStatus::OK, -1234, 6 },
	{ "foo-1-bar,4", { "foo-1-bar", NULL },
			10, 4, OpStatus::OK, 1, 1 },
	{ "foo-1-bar,3", { "foo-1-bar", NULL },
			10, 3, OpStatus::OK, -1, 2 },
	{ "foo-bar,3", { "foo-bar", NULL },
			10, 3, OpStatus::ERR, 0, 0 },
	{ "bacon + spam,5", { "bacon + spam", NULL },
			10, 5, OpStatus::ERR, 0, 0 },
	{ "bacon +2x spam,5", { "bacon +2x spam", NULL },
			10, 5, OpStatus::OK, 2, 3 },
	{ " -  + ", { "\t - + - + \r\n", NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "- 1", { "- 1", NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "+ 1", { "+ 1", NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "+-17", { "+-17", NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "+-17,1", { "+-17", NULL },
			10, 1, OpStatus::OK, -17, 3 },
	{ "-+17", { "-+17", NULL },
			10, 0, OpStatus::ERR, 0, 0 },
	{ "-+17,1", { "-+17", NULL },
			10, 1, OpStatus::OK, 17, 3 },
	{ " 1 ", { " 1 ", NULL },
			10, 0, OpStatus::OK, 1, 2 },
	{ " 666 ", { " 666 ", NULL },
			10, 0, OpStatus::OK, 666, 4 },
	{ " 12abcdeFoo123 ", { " 12abcdeFoo123 ", NULL },
			10, 0, OpStatus::OK, 12, 3 },
	{ " 12abcdeFoo123 ;base=2", { " 12abcdeFoo123 ", NULL },
			2, 0, OpStatus::OK, 1, 2 },
	{ " 12abcdeFoo123 ;base=3", { " 12abcdeFoo123 ", NULL },
			3, 0, OpStatus::OK, (3+2), 3 },
	{ "10000 x spam",
		{ "Well, there's egg and bacon;",
			" egg sausage and bacon;",
			" egg and spam;",
			" egg bacon and spam;",
			" egg bacon sausage and spam; 10",
			"000 x spam bacon sausage and spam;",
			" spam egg spam spam bacon and spam;",
			" spam sausage spam spam bacon spam tomato and spam.",
			NULL },
		10, 113, OpStatus::OK, 10000, 6 },
	{ " 2147483647 ", { "	2147483647 ", NULL },
			10, 0, OpStatus::OK, 2147483647, 11 },
	{ " -2147483648 ", { "\r\n-2147483648 ", NULL },
			10, 0, OpStatus::OK, (-2147483647 - 1), 13 },
		// Same tests with base=16
	{ "<empty>;base=16", { NULL },
			16, 0, OpStatus::ERR, 0, 0 },
	{ "1;base=16", { "1", NULL },
			16, 0, OpStatus::OK, 1, 1 },
	{ "foo-1-bar,4;base=16", { "foo-1-bar", NULL },
			16, 4, OpStatus::OK, 1, 1 },
	{ "foo-1-bar,3;base=16", { "foo-1-bar", NULL },
			16, 3, OpStatus::OK, -1, 2 },
	{ "foo-bar,3;base=16", { "foo-bar", NULL },
			16, 3, OpStatus::OK, -186, 3 },
	{ "foo-bar,4;base=16", { "foo-bar", NULL },
			16, 4, OpStatus::OK, 186, 2 },
	{ " 1 ;base=16", { " 1 ", NULL },
			16, 0, OpStatus::OK, 1, 2 },
	{ " 666 ;base=16", { " 666 ", NULL },
			16, 0, OpStatus::OK, 0x666, 4 },
	{ " 12abcdeFoo123 ;base=16", { " 12abcdeFoo123 ", NULL },
			16, 0, OpStatus::OK, 0x12abcdef, 9 },
	{ "123 Foo 456;base=16", { "123 Foo 456", NULL },
			16, 0, OpStatus::OK, 0x123, 3 },
	{ "10000 x spam;base=16",
		{ "Well, there's egg and bacon;",
			" egg sausage and bacon;",
			" egg and spam;",
			" egg bacon and spam;",
			" egg bacon sausage and spam; 10",
			"000 x spam bacon sausage and spam;",
			" spam egg spam spam bacon and spam;",
			" spam sausage spam spam bacon spam tomato and spam.",
			NULL },
		16, 113, OpStatus::OK, 0x10000, 6 },
	{ " 7fffffff ;base=16", { "	7fffffff ", NULL },
			16, 0, OpStatus::OK, 0x7fffffff, 9 },
	{ " -80000000 ;base=16", { " -80000000 ", NULL },
			16, 0, OpStatus::OK, (-2147483647 - 1), 10 },
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from opdata_toint
{
	test("OpData::ToInt(" testname ")")
	{
		const char* string_setup[] = string_data;
		OpData d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		int result;
		size_t parsed_length;
		OP_STATUS rc = d.ToInt(&result, &parsed_length, base, offset);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (int)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from opdata_toint
{
	test("OpData::ToUInt(" testname ")")
	{
		const char* string_setup[] = string_data;
		OpData d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		unsigned int result;
		size_t parsed_length;
		OP_STATUS rc = d.ToUInt(&result, &parsed_length, base, offset);
		int value = (int)(expected_value);
		if (value < 0)
			/* Note: if the value is negative, then strtoul() returns the
			 * negation of the corresponding unsigned value (as unsigned long)
			 * which causes the unsigned int to overflow: */
			verify_status(OpStatus::ERR_OUT_OF_RANGE, rc);
		else
			verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (unsigned int)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from opdata_toint
{
	test("OpData::ToINT64(" testname ")")
		require STDLIB_64BIT_STRING_CONVERSIONS;
	{
		const char* string_setup[] = string_data;
		OpData d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		INT64 result;
		size_t parsed_length;
		OP_STATUS rc = d.ToINT64(&result, &parsed_length, base, offset);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (INT64)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from opdata_toint
{
	test("OpData::ToUINT64(" testname ")")
		require STDLIB_64BIT_STRING_CONVERSIONS;
	{
		const char* string_setup[] = string_data;
		OpData d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		UINT64 result;
		size_t parsed_length;
		OP_STATUS rc = d.ToUINT64(&result, &parsed_length, base, offset);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (UINT64)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from opdata_toint
{
	test("OpData::ToLong(" testname ")")
	{
		const char* string_setup[] = string_data;
		OpData d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		long result;
		size_t parsed_length;
		OP_STATUS rc = d.ToLong(&result, &parsed_length, base, offset);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (long)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

foreach (testname, string_data, base, offset,
		 expected_status, expected_value, expected_length) from opdata_toint
{
	test("OpData::ToULong(" testname ")")
	{
		const char* string_setup[] = string_data;
		OpData d;
		for (size_t i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		unsigned long result;
		size_t parsed_length;
		OP_STATUS rc = d.ToULong(&result, &parsed_length, base, offset);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
		{
			verify(result == (unsigned long)(expected_value));
			verify(parsed_length == expected_length);
		}
	}
}

subtest test_OpData_ToInt(const OpData& d, int expect)
{
	int actual;
	verify_success(d.ToInt(&actual));
	verify(actual == expect);
}

test("OpData::Split(char sep)")
{
	OpData d;
	OpAutoPtr< OtlCountedList<OpData> >ret(d.Split('|'));
	verify(ret->Length() == 1);
	verify(ret->First().IsEmpty());

	verify_success(d.SetConstData("12|34|567|8||9|0|"));
	ret = d.Split('|');
	verify(ret->Length() == 8);
	verify(ret->PopFirst() == "12");
	verify(ret->PopFirst() == "34");
	verify(ret->PopFirst() == "567");
	verify(ret->PopFirst() == "8");
	verify(ret->PopFirst() == "");
	verify(ret->PopFirst() == "9");
	verify(ret->PopFirst() == "0");
	verify(ret->PopFirst() == "");
	verify(ret->IsEmpty());

	ret = d.Split('|', 3);
	verify(ret->Length() == 4);
	verify(ret->PopFirst() == "12");
	verify(ret->PopFirst() == "34");
	verify(ret->PopFirst() == "567");
	verify(ret->PopFirst() == "8||9|0|");
	verify(ret->IsEmpty());

	ret = d.Split('|', 6);
	verify(ret->Length() == 7);
	verify(ret->PopFirst() == "12");
	verify(ret->PopFirst() == "34");
	verify(ret->PopFirst() == "567");
	verify(ret->PopFirst() == "8");
	verify(ret->PopFirst() == "");
	verify(ret->PopFirst() == "9");
	verify(ret->PopFirst() == "0|");
	verify(ret->IsEmpty());

	ret = d.Split('|', 7);
	verify(ret->Length() == 8);
	verify(ret->PopFirst() == "12");
	verify(ret->PopFirst() == "34");
	verify(ret->PopFirst() == "567");
	verify(ret->PopFirst() == "8");
	verify(ret->PopFirst() == "");
	verify(ret->PopFirst() == "9");
	verify(ret->PopFirst() == "0");
	verify(ret->PopFirst() == "");
	verify(ret->IsEmpty());

	ret = d.Split('|', 0);
	verify(ret->Length() == 1);
	verify(ret->First() == "12|34|567|8||9|0|");
	verify(ret->First() == d);

	ret = d.Split('X');
	verify(ret->Length() == 1);
	verify(ret->First() == "12|34|567|8||9|0|");

	ret = d.Split('X', 6);
	verify(ret->Length() == 1);
	verify(ret->First() == "12|34|567|8||9|0|");

	verify_success(d.SetConstData("12|34|5averyveryveryveryveryveryveryverylongstring67|8||9|0|"));
	ret = d.Split('|');
	verify(ret->Length() == 8);
	verify(ret->PopFirst() == "12");
	verify(ret->PopFirst() == "34");
	verify(ret->PopFirst() == "5averyveryveryveryveryveryveryverylongstring67");
	verify(ret->PopFirst() == "8");
	verify(ret->PopFirst() == "");
	verify(ret->PopFirst() == "9");
	verify(ret->PopFirst() == "0");
	verify(ret->PopFirst() == "");
	verify(ret->IsEmpty());

	ret = d.Split('|', 3);
	verify(ret->Length() == 4);
	verify(ret->PopFirst() == "12");
	verify(ret->PopFirst() == "34");
	verify(ret->PopFirst() == "5averyveryveryveryveryveryveryverylongstring67");
	verify(ret->PopFirst() == "8||9|0|");
	verify(ret->IsEmpty());

	ret = d.Split('|', 6);
	verify(ret->Length() == 7);
	verify(ret->PopFirst() == "12");
	verify(ret->PopFirst() == "34");
	verify(ret->PopFirst() == "5averyveryveryveryveryveryveryverylongstring67");
	verify(ret->PopFirst() == "8");
	verify(ret->PopFirst() == "");
	verify(ret->PopFirst() == "9");
	verify(ret->PopFirst() == "0|");
	verify(ret->IsEmpty());

	ret = d.Split('|', 7);
	verify(ret->Length() == 8);
	verify(ret->PopFirst() == "12");
	verify(ret->PopFirst() == "34");
	verify(ret->PopFirst() == "5averyveryveryveryveryveryveryverylongstring67");
	verify(ret->PopFirst() == "8");
	verify(ret->PopFirst() == "");
	verify(ret->PopFirst() == "9");
	verify(ret->PopFirst() == "0");
	verify(ret->PopFirst() == "");
	verify(ret->IsEmpty());

	ret = d.Split('|', 0);
	verify(ret->Length() == 1);
	verify(ret->First() == "12|34|5averyveryveryveryveryveryveryverylongstring67|8||9|0|");

	ret = d.Split('X');
	verify(ret->Length() == 1);
	verify(ret->First() == "12|34|5averyveryveryveryveryveryveryverylongstring67|8||9|0|");

	ret = d.Split('X', 6);
	verify(ret->Length() == 1);
	verify(ret->First() == "12|34|5averyveryveryveryveryveryveryverylongstring67|8||9|0|");

	ret = d.Split('g', 6);
	verify(ret->Length() == 3);
	verify(ret->PopFirst() == "12|34|5averyveryveryveryveryveryveryverylon");
	verify(ret->PopFirst() == "strin");
	verify(ret->PopFirst() == "67|8||9|0|");
	verify(ret->IsEmpty());

	verify_success(d.SetConstData("1.0|0.0|OpComponentManagerResponseMessage|0|1#"));
	ret = d.Split('#');
	verify(ret->Length() == 2);
	verify(ret->First() == "1.0|0.0|OpComponentManagerResponseMessage|0|1");
	verify(ret->Last() == "");

	d = ret->First();
	ret = d.Split('|');

	verify(ret->Length() == 5);

	OtlList<OpData>::Iterator p = ret->Begin();
	verify_string(*p, "1.0");
	verify(++p != ret->End());
	verify_string(*p, "0.0");
	verify(++p != ret->End());
	verify_string(*p, "OpComponentManagerResponseMessage");
	verify(++p != ret->End());
	verify_string(*p, "0");
	verify(++p != ret->End());
	verify_string(*p, "1");
	verify(++p == ret->End());

	d = ret->PopFirst();
	OpData e = ret->PopFirst();
	verify(ret->First() == "OpComponentManagerResponseMessage");

	/* If we move the iterator to ret->Begin() before deleting the list, it will
	 * keep the reference to that item and even after deleting the list we can
	 * access the string. */
	p = ret->Begin();
	verify_string(*p, "OpComponentManagerResponseMessage");

	ret = d.Split('.', 1);

	/* Now that ret points to a new list, p still points to the one lonely Node
	 * from the old list (because the reference count is not yet 0), but that
	 * Node will finally be removed when p removes its reference to it... */
	verify_string(*p, "OpComponentManagerResponseMessage");

	verify(ret->Length() == 2);
	verify(ret->First() == "1");
	verify(ret->Last() == "0");

	verify(test_OpData_ToInt(ret->First(), 1));
	verify(test_OpData_ToInt(ret->Last(), 0));

	ret = e.Split('.', 1);
	verify(ret->Length() == 2);
	verify(ret->First() == "0");
	verify(ret->Last() == "0");

	verify(test_OpData_ToInt(ret->First(), 0));
	verify(test_OpData_ToInt(ret->Last(), 0));
}

table opdata_split_at_any(const char* testname, const char** string, const char* seq, size_t length, size_t maxsplit, size_t expected_segments, const char** expected_result)
{
	// Test examples from documentation:
	{ "\";,\"",
		{ "12;34,567,8;,9,0,", NULL },
		";,", OpDataUnknownLength, OpDataFullLength,
		8, {"12", "34", "567", "8", "", "9", "0", "", NULL},
	},
	{ "\";,\",, 3",
		{ "12;34,567,8;,9,0,", NULL },
		";,", OpDataUnknownLength, 3,
		4, {"12", "34", "567", "8;,9,0,", NULL},
	},
	{ "\";,\",, 6",
		{ "12;34,567,8;,9,0,", NULL },
		";,", OpDataUnknownLength, 6,
		7, {"12", "34", "567", "8", "", "9", "0,", NULL},
	},
	{ "\";,\",, 0",
		{ "12;34,567,8;,9,0,", NULL },
		";,", OpDataUnknownLength, 0,
		1, {"12;34,567,8;,9,0,", NULL},
	},
	{ "\"X\",, 6",
		{ "12;34,567,8;,9,0,", NULL },
		"X", OpDataUnknownLength, 6,
		1, {"12;34,567,8;,9,0,", NULL},
	},
	{ "\"ef\"",
		{ "abcdefghij", NULL },
		"ef", OpDataUnknownLength, OpDataFullLength,
		3, {"abcd", "", "ghij", NULL},
	},
	{ "\"\"",
		{ "abcdefghij", NULL },
		"", OpDataUnknownLength, OpDataFullLength,
		1, {"abcdefghij", NULL},
	},
	{ "\"fob\"",
		{ "abcdefghij", NULL },
		"fob", OpDataUnknownLength, 3,
		3, {"a", "cde", "ghij", NULL},
	},
	{ "\"fob\", 0, 3",
		{ "abcdefghij", NULL },
		"fob", 0, 3,
		1, {"abcdefghij", NULL},
	},
	{ "\"fob\", 1, 3",
		{ "abcdefghij", NULL },
		"fob", 1, 3,
		2, {"abcde", "ghij", NULL},
	},
	{ "split cross chunk border",
		{ "Well, there's egg and bacon;",
			" egg sausage and bacon;",
			" egg and spam;",
			" egg bacon and spam;",
			" egg bacon sausage and spam;",
			" spam bacon sausage and spam;",
			" spam egg spam spam bacon and spam;",
			" spam sausage spam spam bacon spam tomato and spam. And foo.",
			NULL },
		"c'", OpDataUnknownLength, OpDataFullLength,
		9,
		{ "Well, there", "s egg and ba", "on; egg sausage and ba",
			"on; egg and spam; egg ba", "on and spam; egg ba",
			"on sausage and spam; spam ba",
			"on sausage and spam; spam egg spam spam ba",
			"on and spam; spam sausage spam spam ba",
			"on spam tomato and spam. And foo.", NULL
		}
	}
}

foreach (testname, string_data, seq, length, maxsplit, expected_segments, expected_data) from opdata_split_at_any
{
	test("OpData::SplitAtAnyOf(" testname ")")
	{
		const char* string_setup[] = string_data;
		OpData d;
		size_t i;
		for (i = 0; string_setup[i]; ++i)
			verify_success(d.AppendConstData(string_setup[i]));
		OpAutoPtr< OtlCountedList<OpData> > result(d.SplitAtAnyOf(seq, length, maxsplit));
		verify(result.get());
		verify(result->Length() == expected_segments);
		const char* expected_result[] = expected_data;
		for (i = 0; i < expected_segments; ++i)
			verify_string(result->PopFirst(), expected_result[i]);
		verify(expected_result[i] == NULL);
	}
}

test("OpData::Trunc() truncating to fragment boundary")
{
	OpData d;
	verify_success(d.SetConstData("012345678911234567892123456789312345678941"));
	verify_success(d.AppendConstData("012345678911234567892123456789312345678941"));
	verify(d.Length() == 84);
	verify(d == "012345678911234567892123456789312345678941012345678911234567892123456789312345678941");

	d.Trunc(42);
	verify(d.Length() == 42);
	verify(d == "012345678911234567892123456789312345678941");
}

test("OpData::ToDouble()")
{
	// This test is based on the op_strtod() tests in stdlib_float.ot.
	const double epsilon = 1E-12;
	const double posinf = op_implode_double(0x7ff00000UL, 0UL);
	const double neginf = op_implode_double(0xfff00000UL, 0UL);

	OpData d;
	double result;
	size_t length;

	verify_success(d.SetConstData("    +4.5e-8"));
	verify_success(d.ToDouble(&result));
	verify((result - 4.5e-8) < epsilon);

	verify_success(d.SetConstData("  -Infinity  "));
	verify_success(d.ToDouble(&result));
	verify(result == neginf);

	verify_success(d.ToDouble(&result, &length));
	verify(result == neginf);
	verify(length == 11);

	verify_success(d.SetConstData("  +Infinity"));
	verify_success(d.ToDouble(&result));
	verify(result == posinf);

	verify_success(d.SetConstData("12345678901234.0000000000000000000000000000000000000000000000000000000000001"));
	verify_success(d.ToDouble(&result));
	verify((result - 12345678901234.0) < epsilon);

	verify_success(d.SetConstData("12e3"));
	verify_success(d.ToDouble(&result));
	verify((result - 12000.0) < epsilon);

	verify_success(d.SetConstData("12e-3"));
	verify_success(d.ToDouble(&result));
	verify((result - 0.012) < epsilon);

	verify_success(d.SetConstData("-11E0foo"));
	verify_success(d.ToDouble(&result, &length));
	verify((result - -11) < epsilon);
	verify(length == 5);

	verify_status(OpStatus::ERR, d.ToDouble(&result));

	verify_success(d.SetConstData("12e3\n"));
	verify_success(d.ToDouble(&result, &length));
	verify((result - 12000.0) < epsilon);
	verify(length == 4);

	verify_success(d.SetConstData("12e-3	   \n\n		"));
	verify_success(d.ToDouble(&result, &length));
	verify((result - 0.012) < epsilon);
	verify(length == 5);

	verify_success(d.SetConstData("-11E0 "));
	verify_success(d.ToDouble(&result, &length));
	verify((result - -11) < epsilon);
	verify(length == 5);

	verify_success(d.ToDouble(&result));
	verify((result - -11) < epsilon);
}

test("OpData::To(U)INT64()")
	require STDLIB_64BIT_STRING_CONVERSIONS;
{
	// This test is based on the op_strto(u)i64() tests in stdlib_integer.ot.
	OpData d;
	INT64 i;
	UINT64 u;
	size_t length;

	verify_success(d.SetConstData(" 1 "));
	verify_success(d.ToINT64(&i));
	verify(i == 1);

	verify_success(d.SetConstData(" 9223372036854775807 "));
	verify_success(d.ToINT64(&i, &length));
	verify(i == OP_INT64(9223372036854775807));
	verify(length == 20);

	verify_success(d.SetConstData(" -9223372036854775808xyzzy"));
	verify_success(d.ToINT64(&i, &length));
	verify(i == (OP_INT64(-9223372036854775807) - 1));
	verify(length == 21);

	verify_status(OpStatus::ERR, d.ToINT64(&i));

	// INT64 underflow
	verify_success(d.SetConstData(" -8000000000000001"));
	verify_status(OpStatus::ERR_OUT_OF_RANGE, d.ToINT64(&i, NULL, 16));

	// INT64 overflow
	verify_success(d.SetConstData(" 8000000000000001"));
	verify_status(OpStatus::ERR_OUT_OF_RANGE, d.ToINT64(&i, NULL, 16));


	verify_success(d.SetConstData(" 9223372036854775807 "));
	verify_success(d.ToUINT64(&u, &length));
	verify(u == OP_UINT64(9223372036854775807));
	verify(length == 20);

	verify_success(d.SetConstData(" 18446744073709551615foo"));
	verify_success(d.ToUINT64(&u, &length));
	verify(u == OP_UINT64(18446744073709551615));
	verify(length == 21);

	// UINT64 negative
	verify_success(d.SetConstData(" -1"));
	OP_STATUS st = d.ToUINT64(&u);
	if (st != OpStatus::ERR_OUT_OF_RANGE)
	{
		verify_success(st);
		verify(u + 1 == 0);
	}

	// UINT64 overflow
	verify_success(d.SetConstData(" 10000000000000000"));
	verify_status(OpStatus::ERR_OUT_OF_RANGE, d.ToUINT64(&u, NULL, 16));
}

test("OpData::At() bug from jborsodi")
{
        const char raw[] = "28954.0.0|0.1.1|-771370963|0|\x08\x00\x10\x01#more_data_to_make_this_long_enough";
        OpData data1;
	verify_success(data1.SetConstData(raw, sizeof(raw) - 1));
        verify(data1.At(0) == '2');

        OpAutoPtr< OtlCountedList<OpData> > segments(data1.Split('|', 5));
        OpData seg1 = segments->PopFirst();
        OpData seg2 = segments->PopFirst();
        OpData seg3 = segments->PopFirst();
        OpData seg4 = segments->PopFirst();
        OpData seg5 = segments->PopFirst();

        verify(seg1.At(0) == '2');
        verify(seg2.At(0) == '0');
        verify(seg3.At(0) == '-');
        verify(seg4.At(0) == '0');
        verify(seg5.At(0) == '\x08');
}

test("OpData::AppendCopyData()")
{
	char a[] = "a fairly long string which is long enough to exceed embedded storage.";
	char b[] = "b fairly long string which is long enough to exceed embedded storage.";
	char c[] = "c fairly long string which is long enough to exceed embedded storage.";

	OpData d;
	verify_success(d.AppendCopyData(a));

	a[0] = 'x';
	verify(d == "a fairly long string which is long enough to exceed embedded storage.");

	d.Clear();
	verify_success(d.AppendCopyData(b, 10));

	b[0] = 'y';
	verify(d == "b fairly l");

	d.Clear();
	verify_success(d.AppendCopyData(c + 20, 17));

	c[20] = 'z';
	verify(d == " which is long en");

	verify_success(d.AppendCopyData(a));
	verify_success(d.AppendCopyData(b));
	verify_success(d.AppendCopyData(c));

	a[1] = '#';
	b[1] = '#';
	c[1] = '#';
	verify_string(d, " which is long en"
		"x fairly long string which is long enough to exceed embedded storage."
		"y fairly long string which is long enough to exceed embedded storage."
		"c fairly long stringzwhich is long enough to exceed embedded storage.");
}

test("OpData::SetCopyData() and ::CopyDataL()")
{
	OpData d;
	verify_success(d.SetCopyData("abcdef"));
	verify(!d.IsEmpty());
	verify_success(d.SetCopyData("abcdef", 6));
	verify(!d.IsEmpty());
	verify(d.SetCopyData(NULL, OpDataMaxLength - 1) == OpStatus::ERR_NO_MEMORY);
	verify(d == "abcdef");

	OP_MEMORY_VAR OP_STATUS error;
	TRAP(error, d = OpData::CopyDataL("abcdef"));
	verify_success(error);
	verify(!d.IsEmpty());
	TRAP(error, d = OpData::CopyDataL("abcdef", 6));
	verify_success(error);
	verify(!d.IsEmpty());
	TRAP(error, d = OpData::CopyDataL(NULL, OpDataMaxLength - 1));
	verify_status(OpStatus::ERR_NO_MEMORY, error);
}

test("OpData::DebugView()")
	require OPDATA_DEBUG;
{
	OpData d;
	char *s = d.DebugView();
	verify_string(s, "{''}");

	d.AppendConstData("foo bar");
	op_free(s);
	s = d.DebugView();
	verify_string(s, "{'foo bar'}");

	const char v[] = "This is a string whose length is sufficient to force OpData to store it in normal mode.";
	verify_success(d.SetConstData(v));
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['This is a string whose length is sufficient to force OpData to store it in normal mode.']");

	d.Consume(5);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[5+'is a string whose length is sufficient to force OpData to store it in normal mode.']");

	d.Trunc(d.Length() - 6);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[5+'is a string whose length is sufficient to force OpData to store it in normal'+6]");

	d.AppendConstData(" foo bar baz and some other stuff...");
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[5+'is a string whose length is sufficient to force OpData to store it in normal'] -> [' foo bar baz and some other stuff...']");

	d.AppendConstData(" ... and here is yet another fragment.");
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[5+'is a string whose length is sufficient to force OpData to store it in normal'] -> [' foo bar baz and some other stuff...'] -> [' ... and here is yet another fragment.']");

	d.Consume(15);
	d.Trunc(d.Length() - 10);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length is sufficient to force OpData to store it in normal'] -> [' foo bar baz and some other stuff...'] -> [' ... and here is yet another'+10]");

	d.Trunc(d.Length() - 23);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length is sufficient to force OpData to store it in normal'] -> [' foo bar baz and some other stuff...'] -> [' ... '+33]");

	d.Trunc(d.Length() - 6);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length is sufficient to force OpData to store it in normal'] -> [' foo bar baz and some other stuff..'+1]");

	d.Trunc(d.Length() - 35);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length is sufficient to force OpData to store it in normal']");

	d.Trunc(d.Length() - 2);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length is sufficient to force OpData to store it in norm'+2]");

	d.Trunc(10);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "[20+'se length '+51]");

	d.Trunc(0);
	op_free(s);
	s = d.DebugView();
	verify_string(s, "{''}");
}
finally
{
	op_free(s);
}

test("OpData::DebugView() with non-printable characters")
	require OPDATA_DEBUG;
{
	// embedded mode
	OpData d;
	char *s = d.GetAppendPtr(5);
	for (int i = 0; i < 5; i++)
		s[i] = static_cast<char>(i);

	s = d.DebugView();
	verify_string(s, "{'\\x00\\x01\\x02\\x03\\x04'}");

	// normal mode
	d.Clear();
	op_free(s);
	s = d.GetAppendPtr(256);
	for (int i = 0; i < 256; i++)
		s[i] = static_cast<char>(i);

	s = d.DebugView();
	verify_string(s, "['"
		"\\x00\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f"
		"\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f"
		" !\"#$%&\\'()*+,-./"
		"0123456789:;<=>?"
		"@ABCDEFGHIJKLMNO"
		"PQRSTUVWXYZ[\\\\]^_"
		"`abcdefghijklmno"
		"pqrstuvwxyz{|}~\\x7f"
		"\\x80\\x81\\x82\\x83\\x84\\x85\\x86\\x87\\x88\\x89\\x8a\\x8b\\x8c\\x8d\\x8e\\x8f"
		"\\x90\\x91\\x92\\x93\\x94\\x95\\x96\\x97\\x98\\x99\\x9a\\x9b\\x9c\\x9d\\x9e\\x9f"
		"\\xa0\\xa1\\xa2\\xa3\\xa4\\xa5\\xa6\\xa7\\xa8\\xa9\\xaa\\xab\\xac\\xad\\xae\\xaf"
		"\\xb0\\xb1\\xb2\\xb3\\xb4\\xb5\\xb6\\xb7\\xb8\\xb9\\xba\\xbb\\xbc\\xbd\\xbe\\xbf"
		"\\xc0\\xc1\\xc2\\xc3\\xc4\\xc5\\xc6\\xc7\\xc8\\xc9\\xca\\xcb\\xcc\\xcd\\xce\\xcf"
		"\\xd0\\xd1\\xd2\\xd3\\xd4\\xd5\\xd6\\xd7\\xd8\\xd9\\xda\\xdb\\xdc\\xdd\\xde\\xdf"
		"\\xe0\\xe1\\xe2\\xe3\\xe4\\xe5\\xe6\\xe7\\xe8\\xe9\\xea\\xeb\\xec\\xed\\xee\\xef"
		"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff"
		"']");
}
finally
{
	op_free(s);
}

test("OpData::DebugView() escapes hex digits immediately following escape codes")
	require OPDATA_DEBUG;
{
	OpData d;
	char *s = NULL;
	verify_success(d.SetConstData("\n 01 \n23 \n ab \ncd"));
	s = d.DebugView();
	verify_string(s, "{'\\x0a 01 \\x0a\\x32\\x33 \\x0a ab \\x0a\\x63\\x64'}");
}
finally
{
	op_free(s);
}

test("OpData::Split() bug from arjanl")
{
#define dir0 "/usr/local/share/opera/plugins"
#define dir1 "/usr/local/lib/npapi/symlinks/opera"
#define dir2 "/usr/local/lib/npapi/symlinks/linux-opera"
#define dir3 "/usr/home/avleeuwen/.mozilla/plugin"
#define alldirs dir0 ":" dir1 ":" dir2 ":" dir3

	OpData string;
	verify_success(string.SetConstData(alldirs));
	verify(string.Length() == op_strlen(alldirs));

	OpAutoPtr<OtlCountedList<OpData> > list (string.Split(':'));
	verify(list->Count() == 4);
	unsigned count = 0;
	for (OtlList<OpData>::Iterator elem = list->Begin(); elem != list->End(); ++elem)
	{
		switch (count)
		{
		case 0:
			verify(*elem == dir0);
			break;
		case 1:
			verify(*elem == dir1);
			break;
		case 2:
			{
				verify(*elem == dir2);

				// Ensure that characters accessed from iterator
				// are the same characters in the actual object.
				OpDataFragmentIterator it(*elem);
				do
				{
					for (size_t i = 0; i < it.GetLength(); i++)
					{
						verify(it.GetData()[i] == dir2[i]);
					}
				} while (it.Next());

				break;
			}
		case 3:
			verify(*elem == dir3);
			break;
		}
		count++;
	}

#undef dir0
#undef dir1
#undef dir2
#undef dir3
#undef alldirs
}

test("Pointer from OpData::CreatePtr(&ptr, true) is truly '\0'-terminated")
{
	OpData d;
	verify_success(d.SetConstData("foobar"));
	d.Trunc(3);
	const char *s;
	verify_success(d.CreatePtr(&s, true));
	verify(s);
	verify_string(s, "foo");
	verify(s[0] == 'f');
	verify(s[1] == 'o');
	verify(s[2] == 'o');
	verify(s[3] == '\0');
}

test("Provoke AppendFragments() recounting bugs")
{
	OpData a;
	a.SetConstData("This is a long string that forces OpData into normal mode");
	OpData b = a; // Make sure a's data is shared.
	a.Trunc(50); // Leave some unused characters at the end.

	OpData c;
	c.SetConstData("a continuation that is long enough to force OpData into normal mode");
	OpData d = c; // Make sure c's data is shared.
	c.Consume(5);

	verify_success(a.Append(c));
	verify_string(a, "This is a long string that forces OpData into normtinuation that is long enough to force OpData into normal mode");
}

test("OpData::Split(const char *sep, size_t length)")
{
#define frag1 "SEPARATORThis is the first element (long enough to trigger normal mode storage)"
#define frag2 "SEPARATORThis is the second element (contains an incomplete SEPARATO)SEPARATOR"
#define frag3 "This is the third elementSEPA"
#define frag4 "RATORThis is the fourth element, following a separator that straddles fragment boundariesSEPARATORThis is the fifth element and should be followed by last element, which should be emptySEPARATOR"

	OpData d;
	char *s = NULL;
	verify_success(d.SetConstData(frag1));
	verify_success(d.AppendConstData(frag2));
	verify_success(d.AppendConstData(frag3));
	verify_success(d.AppendConstData(frag4));
#ifdef OPDATA_DEBUG
	s = d.DebugView();
	verify_string(s, "['" frag1 "'] -> ['" frag2 "'] -> ['" frag3 "'] -> ['" frag4 "']");
#endif // OPDATA_DEBUG

	OpAutoPtr< OtlCountedList<OpData> >ret(d.Split("SEPARATOR"));
	verify(ret.get());
	verify(ret->Length() == 7);
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "This is the first element (long enough to trigger normal mode storage)");
	verify_string(ret->PopFirst(), "This is the second element (contains an incomplete SEPARATO)");
	verify_string(ret->PopFirst(), "This is the third element");
	verify_string(ret->PopFirst(), "This is the fourth element, following a separator that straddles fragment boundaries");
	verify_string(ret->PopFirst(), "This is the fifth element and should be followed by last element, which should be empty");
	verify_string(ret->PopFirst(), "");
	verify(ret->IsEmpty());

	ret = d.Split("SEPARATORX");
	verify(ret.get());
	verify(ret->Length() == 1);
	verify_string(ret->PopFirst(), OpData(d)); // Copy d to prevent consolidation.
	verify(ret->IsEmpty());

	ret = d.Split("SEPARATORT");
	verify(ret.get());
	verify(ret->Length() == 6);
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "his is the first element (long enough to trigger normal mode storage)");
	verify_string(ret->PopFirst(), "his is the second element (contains an incomplete SEPARATO)");
	verify_string(ret->PopFirst(), "his is the third element");
	verify_string(ret->PopFirst(), "his is the fourth element, following a separator that straddles fragment boundaries");
	verify_string(ret->PopFirst(), "his is the fifth element and should be followed by last element, which should be emptySEPARATOR");
	verify(ret->IsEmpty());

	ret = d.Split("SEPARATO");
	verify(ret.get());
	verify(ret->Length() == 8);
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "RThis is the first element (long enough to trigger normal mode storage)");
	verify_string(ret->PopFirst(), "RThis is the second element (contains an incomplete ");
	verify_string(ret->PopFirst(), ")");
	verify_string(ret->PopFirst(), "RThis is the third element");
	verify_string(ret->PopFirst(), "RThis is the fourth element, following a separator that straddles fragment boundaries");
	verify_string(ret->PopFirst(), "RThis is the fifth element and should be followed by last element, which should be empty");
	verify_string(ret->PopFirst(), "R");
	verify(ret->IsEmpty());

	ret = d.Split("TOR", 1);
	verify(ret.get());
	verify(ret->Length() == 13);
	verify_string(ret->PopFirst(), "SEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify_string(ret->PopFirst(), "his is the first element (long enough to trigger normal mode storage)SEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify_string(ret->PopFirst(), "his is the second element (contains an incomplete SEPARA");
	verify_string(ret->PopFirst(), "O)SEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify_string(ret->PopFirst(), "his is the third elementSEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify_string(ret->PopFirst(), "his is the fourth element, following a separator that straddles fragment boundariesSEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify_string(ret->PopFirst(), "his is the fifth element and should be followed by last element, which should be emptySEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify(ret->IsEmpty());

	// The above 1-char string separator should be equivalent to the char separator
	ret = d.Split('T');
	verify(ret.get());
	verify(ret->Length() == 13);
	verify_string(ret->PopFirst(), "SEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify_string(ret->PopFirst(), "his is the first element (long enough to trigger normal mode storage)SEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify_string(ret->PopFirst(), "his is the second element (contains an incomplete SEPARA");
	verify_string(ret->PopFirst(), "O)SEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify_string(ret->PopFirst(), "his is the third elementSEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify_string(ret->PopFirst(), "his is the fourth element, following a separator that straddles fragment boundariesSEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify_string(ret->PopFirst(), "his is the fifth element and should be followed by last element, which should be emptySEPARA");
	verify_string(ret->PopFirst(), "OR");
	verify(ret->IsEmpty());

	// Splitting on empty string should split after each byte
	ret = d.Split("");
	verify(ret.get());
	verify(ret->Length() == d.Length());
	for (size_t i = 0; i < d.Length(); i++)
	{
		OpData c = ret->PopFirst();
		verify(c.Length() == 1);
		verify(c[0] == d[i]);
	}
	verify(ret->IsEmpty());

	// Split off the 100 first bytes as individual characters, and then the
	// rest of the buffer as the final list element.
	ret = d.Split("", 0, 100);
	verify(ret.get());
	verify(ret->Length() == 101);
	for (size_t i = 0; i < 100; i++)
	{
		OpData c = ret->PopFirst();
		verify(c.Length() == 1);
		verify(c[0] == d[i]);
	}
	verify_string(ret->PopFirst(), OpData(d, 100));
	verify(ret->IsEmpty());

	// Split off the 0 first bytes as individual characters, and then the
	// rest of the buffer (i.e. the entire buffer) as the only list element.
	ret = d.Split("", 0, 0);
	verify(ret.get());
	verify(ret->Length() == 1);
	verify_string(ret->PopFirst(), OpData(d));
	verify(ret->IsEmpty());
#undef frag1
#undef frag2
#undef frag3
#undef frag4
}
finally
{
	op_free(s);
}

test("OpData::Split() with more challenging separators")
{
#define frag1 "This is element #1 (long enough to trigger normal mode storage)"
#define frag2 "COCOCONUTThis is element #2C"
#define frag3 "OCOCONUTThis is element #3CO"
#define frag4 "COCONUTThis is element #4COC"
#define frag5 "OCONUTThis is element #5COCO"
#define frag6 "CONUTThis is element #6COCOC"
#define frag7 "ONUTThis is element #7COCOCO"
#define frag8 "NUTThis is element #8COCOCON"
#define frag9 "UTThis is element #9COCOCONU"
#define fragA "TThis is element #ACOCOCONUT"
#define fragB "This is element #BCOCOCONUTThis is element #C (the last)"

	OpData d;
	char *s = NULL;
	verify_success(d.SetConstData(frag1));
	verify_success(d.AppendConstData(frag2));
	verify_success(d.AppendConstData(frag3));
	verify_success(d.AppendConstData(frag4));
	verify_success(d.AppendConstData(frag5));
	verify_success(d.AppendConstData(frag6));
	verify_success(d.AppendConstData(frag7));
	verify_success(d.AppendConstData(frag8));
	verify_success(d.AppendConstData(frag9));
	verify_success(d.AppendConstData(fragA));
	verify_success(d.AppendConstData(fragB));
#ifdef OPDATA_DEBUG
	s = d.DebugView();
	verify_string(s, "['" frag1 "'] -> ['" frag2 "'] -> ['" frag3
		"'] -> ['" frag4 "'] -> ['" frag5 "'] -> ['" frag6
		"'] -> ['" frag7 "'] -> ['" frag8 "'] -> ['" frag9
		"'] -> ['" fragA "'] -> ['" fragB "']");
#endif // OPDATA_DEBUG

	OpAutoPtr< OtlCountedList<OpData> >ret(d.Split("COCOCONUT"));
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), "This is element #1 (long enough to trigger normal mode storage)");
	verify_string(ret->PopFirst(), "This is element #2");
	verify_string(ret->PopFirst(), "This is element #3");
	verify_string(ret->PopFirst(), "This is element #4");
	verify_string(ret->PopFirst(), "This is element #5");
	verify_string(ret->PopFirst(), "This is element #6");
	verify_string(ret->PopFirst(), "This is element #7");
	verify_string(ret->PopFirst(), "This is element #8");
	verify_string(ret->PopFirst(), "This is element #9");
	verify_string(ret->PopFirst(), "This is element #A");
	verify_string(ret->PopFirst(), "This is element #B");
	verify_string(ret->PopFirst(), "This is element #C (the last)");
	verify(ret->IsEmpty());

	ret = d.Split("COCONUT");
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), "This is element #1 (long enough to trigger normal mode storage)CO");
	verify_string(ret->PopFirst(), "This is element #2CO");
	verify_string(ret->PopFirst(), "This is element #3CO");
	verify_string(ret->PopFirst(), "This is element #4CO");
	verify_string(ret->PopFirst(), "This is element #5CO");
	verify_string(ret->PopFirst(), "This is element #6CO");
	verify_string(ret->PopFirst(), "This is element #7CO");
	verify_string(ret->PopFirst(), "This is element #8CO");
	verify_string(ret->PopFirst(), "This is element #9CO");
	verify_string(ret->PopFirst(), "This is element #ACO");
	verify_string(ret->PopFirst(), "This is element #BCO");
	verify_string(ret->PopFirst(), "This is element #C (the last)");
	verify(ret->IsEmpty());

	ret = d.Split("COCOCONUTThis is element #");
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), "This is element #1 (long enough to trigger normal mode storage)");
	verify_string(ret->PopFirst(), "2");
	verify_string(ret->PopFirst(), "3");
	verify_string(ret->PopFirst(), "4");
	verify_string(ret->PopFirst(), "5");
	verify_string(ret->PopFirst(), "6");
	verify_string(ret->PopFirst(), "7");
	verify_string(ret->PopFirst(), "8");
	verify_string(ret->PopFirst(), "9");
	verify_string(ret->PopFirst(), "A");
	verify_string(ret->PopFirst(), "B");
	verify_string(ret->PopFirst(), "C (the last)");
	verify(ret->IsEmpty());

	ret = d.Split("COCONUTThis is element #5");
	verify(ret.get());
	verify(ret->Length() == 2);
	verify_string(ret->PopFirst(), "This is element #1 (long enough to trigger normal mode storage)"
		"COCOCONUTThis is element #2"
		"COCOCONUTThis is element #3"
		"COCOCONUTThis is element #4CO");
	verify_string(ret->PopFirst(), "COCOCONUTThis is element #6"
		"COCOCONUTThis is element #7"
		"COCOCONUTThis is element #8"
		"COCOCONUTThis is element #9"
		"COCOCONUTThis is element #A"
		"COCOCONUTThis is element #B"
		"COCOCONUTThis is element #C (the last)");
	verify(ret->IsEmpty());

	ret = d.Split("CO");
	verify(ret.get());
	verify(ret->Length() == 34);
	verify_string(ret->PopFirst(), "This is element #1 (long enough to trigger normal mode storage)");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #2");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #3");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #4");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #5");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #6");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #7");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #8");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #9");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #A");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #B");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "");
	verify_string(ret->PopFirst(), "NUTThis is element #C (the last)");
	verify(ret->IsEmpty());

	ret = d.Split("COCO");
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), "This is element #1 (long enough to trigger normal mode storage)");
	verify_string(ret->PopFirst(), "CONUTThis is element #2");
	verify_string(ret->PopFirst(), "CONUTThis is element #3");
	verify_string(ret->PopFirst(), "CONUTThis is element #4");
	verify_string(ret->PopFirst(), "CONUTThis is element #5");
	verify_string(ret->PopFirst(), "CONUTThis is element #6");
	verify_string(ret->PopFirst(), "CONUTThis is element #7");
	verify_string(ret->PopFirst(), "CONUTThis is element #8");
	verify_string(ret->PopFirst(), "CONUTThis is element #9");
	verify_string(ret->PopFirst(), "CONUTThis is element #A");
	verify_string(ret->PopFirst(), "CONUTThis is element #B");
	verify_string(ret->PopFirst(), "CONUTThis is element #C (the last)");
	verify(ret->IsEmpty());

	ret = d.Split("CONUT");
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), "This is element #1 (long enough to trigger normal mode storage)COCO");
	verify_string(ret->PopFirst(), "This is element #2COCO");
	verify_string(ret->PopFirst(), "This is element #3COCO");
	verify_string(ret->PopFirst(), "This is element #4COCO");
	verify_string(ret->PopFirst(), "This is element #5COCO");
	verify_string(ret->PopFirst(), "This is element #6COCO");
	verify_string(ret->PopFirst(), "This is element #7COCO");
	verify_string(ret->PopFirst(), "This is element #8COCO");
	verify_string(ret->PopFirst(), "This is element #9COCO");
	verify_string(ret->PopFirst(), "This is element #ACOCO");
	verify_string(ret->PopFirst(), "This is element #BCOCO");
	verify_string(ret->PopFirst(), "This is element #C (the last)");
	verify(ret->IsEmpty());

	ret = d.Split("CON");
	verify(ret.get());
	verify(ret->Length() == 12);
	verify_string(ret->PopFirst(), "This is element #1 (long enough to trigger normal mode storage)COCO");
	verify_string(ret->PopFirst(), "UTThis is element #2COCO");
	verify_string(ret->PopFirst(), "UTThis is element #3COCO");
	verify_string(ret->PopFirst(), "UTThis is element #4COCO");
	verify_string(ret->PopFirst(), "UTThis is element #5COCO");
	verify_string(ret->PopFirst(), "UTThis is element #6COCO");
	verify_string(ret->PopFirst(), "UTThis is element #7COCO");
	verify_string(ret->PopFirst(), "UTThis is element #8COCO");
	verify_string(ret->PopFirst(), "UTThis is element #9COCO");
	verify_string(ret->PopFirst(), "UTThis is element #ACOCO");
	verify_string(ret->PopFirst(), "UTThis is element #BCOCO");
	verify_string(ret->PopFirst(), "UTThis is element #C (the last)");
	verify(ret->IsEmpty());
#undef frag1
#undef frag2
#undef frag3
#undef frag4
#undef frag5
#undef frag6
#undef frag7
#undef frag8
#undef frag9
#undef fragA
#undef fragB
}
finally
{
	op_free(s);
}

/* Adds the following text fragments to the specified OpData argument.
 *  "Well, there's egg and bacon;"
 *   0     6       14            28
 *  " egg sausage and bacon;"
 *   29                    51
 *  " egg and spam;"
 *   52      60   65
 *  " egg bacon and spam;"
 *   66        76  80   85
 *  " egg bacon sausage and spam;"
 *   86                104 108  113
 *  " spam bacon sausage and spam;"
 *   114  119           133 137  142
 *  " spam egg spam spam bacon and spam;"
 *   143  148 152       162   168 172  177
 *  " spam sausage spam spam bacon spam tomato and spam. And foo."
 *   178  183     191       201   207  212    219 223  228      237
 */
subtest SetupSpamText(OpData& d)
{
	verify_success(d.AppendConstData("Well, there's egg and bacon;"));
	verify_success(d.AppendConstData(" egg sausage and bacon;"));
	verify_success(d.AppendConstData(" egg and spam;"));
	verify_success(d.AppendConstData(" egg bacon and spam;"));
	verify_success(d.AppendConstData(" egg bacon sausage and spam;"));
	verify_success(d.AppendConstData(" spam bacon sausage and spam;"));
	verify_success(d.AppendConstData(" spam egg spam spam bacon and spam;"));
	verify_success(d.AppendConstData(" spam sausage spam spam bacon spam tomato and spam. And foo."));
	verify(d.Length() == 237);
	verify_string(d, g_spam_text);
}

subtest SetupSpamText(UniString& s)
{
	verify_success(s.AppendConstData(UNI_L("Well, there's egg and bacon;")));
	verify_success(s.AppendConstData(UNI_L(" egg sausage and bacon;")));
	verify_success(s.AppendConstData(UNI_L(" egg and spam;")));
	verify_success(s.AppendConstData(UNI_L(" egg bacon and spam;")));
	verify_success(s.AppendConstData(UNI_L(" egg bacon sausage and spam;")));
	verify_success(s.AppendConstData(UNI_L(" spam bacon sausage and spam;")));
	verify_success(s.AppendConstData(UNI_L(" spam egg spam spam bacon and spam;")));
	verify_success(s.AppendConstData(UNI_L(" spam sausage spam spam bacon spam tomato and spam. And foo.")));
	verify(s.Length() == 237);
	verify_string(s, g_spam_text);
}

test("OpData::Delete()")
{
	OpData d;
	verify(SetupSpamText(d));

	verify_success(d.Delete(228, 1000));
	verify_success(d.Delete(212, 7));
	verify_success(d.Delete(201, 6));
	verify_success(d.Delete(183, 8));
	verify_success(d.Delete(162, 6));
	verify_success(d.Delete(148, 4));
	verify_success(d.Delete(119, 14));
	verify_success(d.Delete(66, 48));
	verify_success(d.Delete(0, 6));
	verify_success(d.Delete(14 - 6, 46));

	verify_string(d, "there's spam; spam and spam; spam spam spam and spam; spam spam spam spam and spam.");
}

test("OpData::Remove(char remove, ...)")
{
	OpData d;
	verify(SetupSpamText(d));

	verify_success(d.Remove('s'));
	verify_success(d.Remove('p'));
	verify_success(d.Remove('a'));
	verify_success(d.Remove('m', 5));

	verify_string(d, "Well, there' egg nd bcon; egg uge nd bcon; egg nd ; egg bcon nd ; egg bcon uge nd ;  bcon uge nd ; m egg m m bcon nd m; m uge m m bcon m tomto nd m. And foo.");
}

test("OpData::Remove(const char *remove, size_length, ...)")
{
	OpData d;
	verify(SetupSpamText(d));

	verify_success(d.Remove(" egg"));
	verify_success(d.Remove(" bacon"));
	verify_success(d.Remove(" tomato", 4));
	verify_success(d.Remove("ato"));
	verify_success(d.Remove(" sausage", 3));
	verify_success(d.Remove("usage"));
	verify_success(d.Remove(" and", 4, 5));
	verify_success(d.Remove(" spam", 5, 2));
	verify_success(d.Remove(";;"));
	verify_success(d.Remove(" And foo."));

	verify_string(d, "Well, there's spam; spam and spam; spam spam spam and spam; spam spam spam spam and spam.");
}

table opdata_replace_spam(const char* testname, const char a, const char b, size_t maxreplace, OP_STATUS expected_status, size_t expected_replacecount, const char* expected_result)
{
	{ "s/ /_/g",
			' ', '_', OpDataMaxLength, OpStatus::OK, 43,
			"Well,_there's_egg_and_bacon;_egg_sausage_and_bacon;_egg_and_spam;"
			"_egg_bacon_and_spam;_egg_bacon_sausage_and_spam;"
			"_spam_bacon_sausage_and_spam;_spam_egg_spam_spam_bacon_and_spam;"
			"_spam_sausage_spam_spam_bacon_spam_tomato_and_spam._And_foo."
	},
	{ "s/ /_/8",
			' ', '_', 8, OpStatus::OK, 8,
			"Well,_there's_egg_and_bacon;_egg_sausage_and_bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/g/k/3",
			'g', 'k', 3, OpStatus::OK, 3,
			"Well, there's ekk and bacon; ekg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/X/U/",
			'X', 'U', 1, OpStatus::OK, 0,
			"Well, there's egg and bacon; egg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
		/* the following entries use const char* a, const char* b instead of
		 * char a, char b, but selftest does not complain - otherwise we had to
		 * duplicate the test code. */
	{ "s/egg/spam/g",
			"egg", "spam", OpDataMaxLength, OpStatus::OK, 6,
			"Well, there's spam and bacon; spam sausage and bacon; spam and"
			" spam; spam bacon and spam; spam bacon sausage and spam;"
			" spam bacon sausage and spam; spam spam spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/ spam/ ham/8",
			" spam", " ham", 8, OpStatus::OK, 8,
			"Well, there's egg and bacon; egg sausage and bacon; egg and ham;"
			" egg bacon and ham; egg bacon sausage and ham;"
			" ham bacon sausage and ham; ham egg ham ham bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/; spam/! ham/3",
			"; spam", "! ham", 3, OpStatus::OK, 3,
			"Well, there's egg and bacon; egg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam! ham bacon sausage"
			" and spam! ham egg spam spam bacon and spam! ham sausage spam spam"
			" bacon spam tomato and spam. And foo."
	},
	{ "s/fish/frog/",
			"fish", "frog", 1, OpStatus::OK, 0,
			"Well, there's egg and bacon; egg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/NULL/spam/",
			NULL, "spam", OpDataMaxLength, OpStatus::ERR, 0,
			"Well, there's egg and bacon; egg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s//fish/",
			"", "fish", OpDataMaxLength, OpStatus::ERR, 0,
			"Well, there's egg and bacon; egg sausage and bacon; egg and spam;"
			" egg bacon and spam; egg bacon sausage and spam;"
			" spam bacon sausage and spam; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
	{ "s/spam/NULL/5",
			"spam", NULL, 5, OpStatus::OK, 5,
			"Well, there's egg and bacon; egg sausage and bacon; egg and ;"
			" egg bacon and ; egg bacon sausage and ;"
			"  bacon sausage and ; spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam. And foo."
	},
}

foreach (testname, a, b, maxreplace, expected_status, expected_replacecount, expected_result) from opdata_replace_spam
{
	test("OpData::Replace(" testname ")")
	{
		OpData d;
		verify_success(d.AppendConstData("Well, there's egg and bacon;"));
		verify_success(d.AppendConstData(" egg sausage and bacon;"));
		verify_success(d.AppendConstData(" egg and spam;"));
		verify_success(d.AppendConstData(" egg bacon and spam;"));
		verify_success(d.AppendConstData(" egg bacon sausage and spam;"));
		verify_success(d.AppendConstData(" spam bacon sausage and spam;"));
		verify_success(d.AppendConstData(" spam egg spam spam bacon and spam;"));
		verify_success(d.AppendConstData(" spam sausage spam spam bacon spam tomato and spam. And foo."));
		verify(d.Length() == 237);

		size_t replacecount = 17;
		OP_STATUS rc = d.Replace(a, b, maxreplace, &replacecount);
		verify_status(expected_status, rc);
		if (OpStatus::IsSuccess(rc))
			verify(replacecount == expected_replacecount);
		verify_string(d, expected_result);
	}
}

test("OpData::Append() appending an object to itself")
{
	OpData d;
	char *s = NULL;

	// appending embedded mode to embedded mode - result is in embedded mode
	verify_success(d.SetConstData("foo"));
	verify_success(d.Append(d));
	verify(d.Length() == 6);
	verify(d == "foofoo");

	// appending embedded mode to embedded mode - result is in normal mode
	verify_success(d.SetConstData("Buffer is 19 long.."));
	verify_success(d.Append(d));
	verify_success(d.Append(d));
	verify(d.Length() == 19 * 4);
	verify(d == "Buffer is 19 long..Buffer is 19 long..Buffer is 19 long..Buffer is 19 long..");

	// appending normal mode to normal mode - result is in normal mode
	verify_success(d.SetConstData("This is the first fragment in the buffer. "));
	verify_success(d.AppendConstData("This is the second fragment. "));
#ifdef OPDATA_DEBUG
	s = d.DebugView();
	verify_string(s, "['This is the first fragment in the buffer. '] -> ['This is the second fragment. ']");
#endif // OPDATA_DEBUG
	verify_success(d.Append(d));
#ifdef OPDATA_DEBUG
	op_free(s);
	s = d.DebugView();
	verify_string(s, "['This is the first fragment in the buffer. '] -> ['This is the second fragment. '] -> ['This is the first fragment in the buffer. '] -> ['This is the second fragment. ']");
#endif // OPDATA_DEBUG
	verify(d.Length() == 71 * 2);
	verify(d == "This is the first fragment in the buffer. This is the second fragment. This is the first fragment in the buffer. This is the second fragment. ");
}
finally
{
	op_free(s);
}

test("OpData::LStrip(NULL string)")
{
	OpData d;
	d.LStrip();
	verify_string(d, "");
}

table test_LStrip(const char* test_name, const char* test_data, const char* expected_data)
{
	{ "empty string", "", "" },
	{ "space", " ", "" },
	{ "all spaces", "\f \n\r\t\v", "" },
	{ "tab", "\t", "" },
	{ "text", "\t \t\r\n \tSome text with leading ws",
		"Some text with leading ws" },
	{ "trailing ws", "\r\n \tSome text with leading and trailing ws\t \t ",
		"Some text with leading and trailing ws\t \t " },
	{ "Embedded '\\0'", " Embedded \0 non-terminal ",
			"Embedded \0 non-terminal "},
	{ "Blank with '\\0'", " \t\0\t ", "\0\t "}
}

foreach (test_name, test_data, expected_data) from test_LStrip
{
	test("OpData::LStrip(" test_name ")")
	{
		const char text[] = test_data;
		const char expected[] = expected_data;
		OpData d;
		verify_success(d.AppendConstData(text, sizeof(text)));
		d.LStrip();
		verify(d.Length() == sizeof(expected));
		OpDataCharIterator it(d);
		for (size_t i = 0; i < d.Length(); ++i, ++it)
			verify(*it == expected[i]);
		verify_string(d, expected);
	}
}

test("OpData::RStrip(NULL string)")
{
	OpData d;
	d.RStrip();
	verify_string(d, "");
}

table test_RStrip(const char* test_name, const char* test_data, const char* expected_data)
{
	{ "empty string", "", "" },
	{ "space", " ", "" },
	{ "all spaces", "\f \n\r\t\v", "" },
	{ "tab", "\t", "" },
	{ "text", "Some text with trailing ws\t \t \t",
		"Some text with trailing ws" },
	{ "leading ws", "\r\n \tSome text with leading and trailing ws\t \t ",
		"\r\n \tSome text with leading and trailing ws" },
	{ "Embedded '\\0'", " Embedded \0 non-terminal ",
			" Embedded \0 non-terminal"},
	{ "Blank with '\\0'", " \t\0\t ", " \t\0"}
}

foreach (test_name, test_data, expected_data) from test_RStrip
{
	test("OpData::RStrip(" test_name ")")
	{
		const char text[] = test_data;
		const char expected[] = expected_data;
		OpData d;
		verify_success(d.AppendConstData(text, sizeof(text)-1));
		d.RStrip();
		verify(d.Length() == sizeof(expected)-1);
		OpDataCharIterator it(d);
		for (size_t i = 0; i < d.Length(); ++i, ++it)
			verify(*it == expected[i]);
		verify_string(d, expected);
	}
}

table test_OpDataCharIterator(const char* test_name, const char* test_text)
{
	{ "NULL string", NULL }
	{ "empty string", "" }
	{ "embedded string", "embedded" }
	{ "single char", "x" }
	{ "long string", g_spam_text }
}

foreach (test_name, test_text) from test_OpDataCharIterator
{
	test("OpDataCharIterator++ " test_name)
	{
		const char* text = test_text;
		OpData d;
		UniString s;
		if (text)
		{
			verify_success(d.AppendConstData(text));
			verify_success(ASCIIOpData::ToUniString(d, s));
			verify_string(d, text);
			verify_string(s, text);
		}

		/* apply the same test steps to an OpDataCharIterator and a
		 * UnicodeStringIterator iterating over the same text to verify that
		 * the two classes behave in the same way: */
		OpDataCharIterator itd(d);
		UnicodeStringIterator its(s);
		verify(itd.IsAtBeginning());
		verify(its.IsAtBeginning());
		size_t length = text ? op_strlen(text) : 0;
		if (length > 0)
		{
			for (size_t i = 0; i < length-1; i++)
			{
				verify(itd.Index() == i);
				verify(its.Index() == i);
				verify(!itd.IsAtEnd());
				verify(!its.IsAtEnd());
				verify(*itd == text[i]);
				verify(*its == (UnicodePoint)text[i]);
				verify(itd.HasNext());
				verify(its.HasNext());
				verify(++itd);
				verify(++its);
				verify(!itd.IsAtBeginning());
				verify(!its.IsAtBeginning());
			}

			verify(itd.Index() == length-1);
			verify(its.Index() == length-1);
			verify(!itd.IsAtEnd());
			verify(!its.IsAtEnd());
			verify(*itd == text[length-1]);
			verify(*its == (UnicodePoint)text[length-1]);
			verify(!itd.HasNext());
			verify(!its.HasNext());
			verify(!++itd);
			verify(!++its);
			verify(!itd.IsAtBeginning());
			verify(!its.IsAtBeginning());
		}

		verify(itd.Index() == length);
		verify(its.Index() == length);
		verify(itd.IsAtEnd());
		verify(its.IsAtEnd());
		verify(*itd == '\0');
		verify(*its == (UnicodePoint)'\0');
		verify(!itd.HasNext());
		verify(!its.HasNext());
		verify(!++itd);
		verify(!++its);
		verify(itd.Index() == length);
		verify(its.Index() == length);
		verify(itd.IsAtEnd());
		verify(its.IsAtEnd());
		verify(*itd == '\0');
		verify(*its == (UnicodePoint)'\0');
	}
}

test("OpDataCharIterator++ fragmented string")
{
	OpData d;
	UniString s;
	verify(SetupSpamText(d));
	verify(SetupSpamText(s));

	/* apply the same test steps to an OpDataCharIterator and a
	 * UnicodeStringIterator iterating over the same text to verify that
	 * the two classes behave in the same way: */
	OpDataCharIterator itd(d);
	UnicodeStringIterator its(s);
	verify(itd.IsAtBeginning());
	verify(its.IsAtBeginning());

	// walk from the start to the end:
	size_t length = op_strlen(g_spam_text);
	for (size_t i = 0; i < length-1; i++)
	{
		verify(itd.Index() == i);
		verify(its.Index() == i);
		verify(!itd.IsAtEnd());
		verify(!its.IsAtEnd());
		verify(*itd == g_spam_text[i]);
		verify(*its == (UnicodePoint)g_spam_text[i]);
		verify(itd.HasNext());
		verify(its.HasNext());
		verify(++itd);
		verify(++its);
		verify(!itd.IsAtBeginning());
		verify(!its.IsAtBeginning());

		// make it two steps forward and one step back:
		verify(itd.Index() == i+1);
		verify(its.Index() == i+1);
		verify(*itd == g_spam_text[i+1]);
		verify(*its == (UnicodePoint)g_spam_text[i+1]);
		if (++itd)
		{
			verify(++its);
			verify(itd.Index() == i+2);
			verify(its.Index() == i+2);
			verify(*itd == g_spam_text[i+2]);
			verify(*its == (UnicodePoint)g_spam_text[i+2]);
		}
		else
		{
			verify(!++its);
			verify(itd.Index() == d.Length());
			verify(its.Index() == d.Length());
			verify(*itd == '\0');
			verify(*its == (UnicodePoint)'\0');
			verify(itd.IsAtEnd());
			verify(its.IsAtEnd());
		}

		verify(itd.HasPrevious());
		verify(its.HasPrevious());
		verify(--itd);
		verify(--its);
	}

	/* Now we are at the last character: we moved to the end-sentinel and back
	 * one character. */
	verify(itd.Index() == length-1);
	verify(its.Index() == length-1);
	verify(!itd.IsAtEnd());
	verify(!its.IsAtEnd());
	verify(*itd == g_spam_text[length-1]);
	verify(*its == (UnicodePoint)g_spam_text[length-1]);

	// So there is only the end-sentinel after the current position:
	verify(!itd.HasNext());
	verify(!its.HasNext());
	verify(!++itd);
	verify(!++its);
	verify(itd.Index() == length);
	verify(its.Index() == length);
	verify(!itd.IsAtBeginning());
	verify(!its.IsAtBeginning());
	verify(itd.IsAtEnd());
	verify(its.IsAtEnd());
	verify(*itd == '\0');
	verify(*its == (UnicodePoint)'\0');
	verify(!itd.HasNext());
	verify(!its.HasNext());

	// Moving past the end-sentinel doesn't change the position:
	verify(!++itd);
	verify(!++its);
	verify(itd.Index() == length);
	verify(its.Index() == length);
	verify(itd.IsAtEnd());
	verify(its.IsAtEnd());
	verify(*itd == '\0');
	verify(*its == (UnicodePoint)'\0');
}

foreach (test_name, test_text) from test_OpDataCharIterator
{
	test("OpDataCharIterator-- " test_name)
	{
		const char* text = test_text;
		OpData d;
		UniString s;
		if (text)
		{
			verify_success(d.AppendConstData(text));
			verify_success(ASCIIOpData::ToUniString(d, s));
			verify_string(d, text);
			verify_string(s, text);
		}

		/* apply the same test steps to an OpDataCharIterator and a
		 * UnicodeStringIterator iterating over the same text to verify that
		 * the two classes behave in the same way: */
		OpDataCharIterator itd(d, OpDataUnknownLength);
		UnicodeStringIterator its(s, OpDataUnknownLength);
		verify(itd.IsAtEnd());
		verify(its.IsAtEnd());

		// Move from the end-sentinel to the beginning:
		size_t length = text ? op_strlen(text) : 0;
		verify(itd.Index() == length);
		verify(its.Index() == length);
		if (length > 0)
		{
			for (size_t i = length; i > 0; i--)
			{
				verify(*itd == text[i]);
				verify(*its == (UnicodePoint)text[i]);
				verify(!itd.IsAtBeginning());
				verify(!its.IsAtBeginning());
				verify(itd.HasPrevious());
				verify(its.HasPrevious());
				verify(--itd);
				verify(--its);
				verify(!itd.IsAtEnd());
				verify(!its.IsAtEnd());
				verify(itd.Index() == i-1);
				verify(its.Index() == i-1);
			}
		}

		// Now we are at the first character:
		verify(itd.IsAtBeginning());
		verify(its.IsAtBeginning());
		verify(!itd.HasPrevious());
		verify(!its.HasPrevious());
		verify(*itd == (text ? text[0] : '\0'));
		verify(*its == (UnicodePoint)(text ? text[0] : '\0'));

		// It's not possible to move the iterator before the first char:
		verify(!--itd);
		verify(!--its);
		verify(itd.IsAtBeginning());
		verify(its.IsAtBeginning());
		verify(*itd == (text ? text[0] : '\0'));
		verify(*its == (UnicodePoint)(text ? text[0] : '\0'));
	}
}

test("OpDataCharIterator-- fragmented string")
{
	OpData d;
	UniString s;
	verify(SetupSpamText(d));
	verify(SetupSpamText(s));

	/* apply the same test steps to an OpDataCharIterator and a
	 * UnicodeStringIterator iterating over the same text to verify that
	 * the two classes behave in the same way: */
	OpDataCharIterator itd(d, OpDataUnknownLength);
	UnicodeStringIterator its(s, OpDataUnknownLength);
	verify(itd.IsAtEnd());
	verify(its.IsAtEnd());

	// Move from the end-sentinel to the beginning:
	size_t length = op_strlen(g_spam_text);
	verify(itd.Index() == length);
	verify(its.Index() == length);
	for (size_t i = length; i > 0; i--)
	{
		verify(*itd == g_spam_text[i]);
		verify(*its == (UnicodePoint)g_spam_text[i]);
		verify(!itd.IsAtBeginning());
		verify(!its.IsAtBeginning());
		verify(itd.HasPrevious());
		verify(its.HasPrevious());
		verify(--itd);
		verify(--its);
		verify(!itd.IsAtEnd());
		verify(!its.IsAtEnd());

		verify(itd.Index() == i-1);
		verify(its.Index() == i-1);
		verify(*itd == g_spam_text[i-1]);
		verify(*its == (UnicodePoint)g_spam_text[i-1]);
		if (i > 1)
		{
			// make it two steps back and one step forward:
			verify(itd.HasPrevious());
			verify(its.HasPrevious());
			verify(--itd);
			verify(--its);
			verify(itd.Index() == i-2);
			verify(its.Index() == i-2);
			verify(*itd == g_spam_text[i-2]);
			verify(*its == (UnicodePoint)g_spam_text[i-2]);

			verify(itd.HasNext());
			verify(its.HasNext());
			verify(++itd);
			verify(++its);
			verify(itd.Index() == i-1);
			verify(its.Index() == i-1);
		}
		else
		{
			// we are at the beginning and can't make another step back:
			verify(!itd.HasPrevious());
			verify(!its.HasPrevious());
			verify(!--itd);
			verify(!--its);
			verify(itd.Index() == 0);
			verify(its.Index() == 0);
			verify(*itd == g_spam_text[0]);
			verify(*its == (UnicodePoint)g_spam_text[0]);
		}
	}

	// Now we are at the first character:
	verify(itd.IsAtBeginning());
	verify(its.IsAtBeginning());
	verify(!itd.HasPrevious());
	verify(!its.HasPrevious());
	verify(*itd == g_spam_text[0]);
	verify(*its == (UnicodePoint)g_spam_text[0]);

	// It's not possible to move the iterator before the first char:
	verify(!--itd);
	verify(!--its);
	verify(itd.IsAtBeginning());
	verify(its.IsAtBeginning());
	verify(*itd == g_spam_text[0]);
	verify(*its == (UnicodePoint)g_spam_text[0]);
}

table test_OpDataCharIteratorOffset(const char* test_name, size_t test_offset, char expected_char)
{
	{ "0", 0, 'W' }
	{ "middle of first fragment", 14, 'X' }
	{ "start second fragment", 28, 'Y' }
	{ "end of a fragment", 112, 'Z' }
	{ "middle of sixth fragment", 121, 'V' }
	{ "embedded \\0", 228, '\0' }
	{ "end", 237, '.' }
	{ "length", 238, '\0' }
	{ "OpDataUnknownLength", OpDataUnknownLength, '\0' }
}

foreach (test_name, test_offset, expected_char) from test_OpDataCharIteratorOffset
{
	test("OpDataCharIterator fragmented string with offset " test_name)
	{
		OpData d;
		verify_success(d.AppendConstData("Well, there's Xgg and bacon;"));
		//                                0     6       14            28
		verify_success(d.AppendConstData("Yegg sausage and bacon;"));
		//                                 29                    51
		verify_success(d.AppendConstData(" egg and spam;"));
		//                                 52      60   65
		verify_success(d.AppendConstData(" egg bacon and spam;"));
		//                                 66        76  80   85
		verify_success(d.AppendConstData(" egg bacon sausage and spamZ"));
		//                                 86                104 108  113
		verify_success(d.AppendConstData(" spam baVon sausage and spam;"));
		//                                 114  119           133 137  142
		verify_success(d.AppendConstData(" spam egg spam spam bacon and spam;"));
		//                                 143  148 152       162   168 172  177
		const char spam_spam_and_foo[] = " spam sausage spam spam bacon spam tomato and spam;\0 And foo.";
		//                                 178  183     191       201   207  212    219 223  228       238
		verify_success(d.AppendConstData(spam_spam_and_foo, sizeof(spam_spam_and_foo)-1));
		verify(d.Length() == 238);
		const char text[] = "Well, there's Xgg and bacon;"
			"Yegg sausage and bacon;"
			" egg and spam;"
			" egg bacon and spam;"
			" egg bacon sausage and spamZ"
			" spam baVon sausage and spam;"
			" spam egg spam spam bacon and spam;"
			" spam sausage spam spam bacon spam tomato and spam;\0 And foo.";

		verify_string(d, text);

		OpDataCharIterator it(d, test_offset);
		const size_t offset = test_offset >= d.Length() ? d.Length() : test_offset;
		if (offset < d.Length())
			verify(!it.IsAtEnd());
		else
			verify(it.IsAtEnd());
		verify(*it == expected_char);
		verify(*it == text[offset]);
		verify(it.Index() == offset);

		if (offset > 0)
		{
			verify(--it);
			verify(!it.IsAtEnd());
			verify(it.Index() == offset-1);
			verify(*it == text[offset-1]);
			if (offset == d.Length())
			{
				verify(!++it);
				verify(it.IsAtEnd());
			}
			else
				verify(++it);
			verify(it.Index() == offset);
			verify(*it == text[offset]);
		}
		else
		{
			verify(it.IsAtBeginning());
			verify(!--it);
			verify(it.IsAtBeginning());
			verify(*it == text[0]);
			verify(it.Index() == 0);
		}

		if (offset < d.Length()-1)
		{
			verify(++it);
			verify(!it.IsAtEnd());
			verify(!it.IsAtBeginning());
			verify(it.Index() == offset+1);
			verify(*it == text[offset+1]);
			verify(--it);
			verify(it.Index() == offset);
			verify(*it == text[offset]);
		}
		else if (offset == d.Length()-1)
		{
			verify(!++it);
			verify(it.IsAtEnd());
			verify(!it.IsAtBeginning());
			verify(it.Index() == offset+1);
			verify(*it == text[offset+1]);
			verify(--it);
			verify(!it.IsAtEnd());
			verify(it.Index() == offset);
			verify(*it == text[offset]);
		}
		else
		{
			verify(it.IsAtEnd());
			verify(*it == text[offset]);
		}
	}
}
