group "libssl ciphers";

require _NATIVE_SSL_SUPPORT_;

language c++;

include "modules/libssl/sslbase.h";
include "modules/libssl/options/sslopt.h";
include "modules/libssl/ssl_api.h";
include "modules/libssl/selftest/sslinc.h";
include "modules/libssl/methods/sslcipher.h";

global {
/* Test vectors from openssl*/

/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
 * All rights reserved.
 *
 * This package is an SSL implementation written
 * by Eric Young (eay@cryptsoft.com).
 * The implementation was written so as to conform with Netscapes SSL.
 *
 * This library is free for commercial and non-commercial use as long as
 * the following conditions are aheared to.  The following conditions
 * apply to all code found in this distribution, be it the RC4, RSA,
 * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
 * included with this distribution is covered by the same copyright terms
 * except that the holder is Tim Hudson (tjh@cryptsoft.com).
 *
 * Copyright remains Eric Young's, and as such any Copyright notices in
 * the code are not to be removed.
 * If this package is used in a product, Eric Young should be given attribution
 * as the author of the parts of the library used.
 * This can be in the form of a textual message at program startup or
 * in documentation (online or textual) provided with the package.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *    "This product includes cryptographic software written by
 *     Eric Young (eay@cryptsoft.com)"
 *    The word 'cryptographic' can be left out if the rouines from the library
 *    being used are not cryptographic related :-).
 * 4. If you include any Windows specific code (or a derivative thereof) from
 *    the apps directory (application code) you must include an acknowledgement:
 *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
 *
 * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * The licence and distribution terms for any publically available version or
 * derivative of this code cannot be changed.  i.e. this code cannot simply be
 * copied and put under another distribution licence
 * [including the GNU Public Licence.]
 */


BOOL SSL_initialized = FALSE;

// Null cipher tests

unsigned char ssl_null_keys[3][8] = {
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08},
	{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
};

unsigned char ssl_null_data_len = 8;
unsigned char ssl_null_data[3][8] = {
	{ 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},
	{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{ 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08}
};



// RC4 tests

unsigned char ssl_rc4_keys[6][16]={
	{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},
	{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45},
	{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},
	{0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45, 0xef, 0x01, 0x23, 0x45}
	};

static unsigned char ssl_rc4_data_len[6]={8,8,8,20, 28, 10};
static unsigned char ssl_rc4_data[6][28]={
	{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0x12, 0x34, 0x56, 0x78, 0x9A, 0xBC, 0xDE, 0xF0, 0x12, 0x34, 0x56, 0x78},
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	};

static unsigned char ssl_rc4_output[6][30]={
	{0x75, 0xb7, 0x87, 0x80, 0x99, 0xe0, 0xc5, 0x96},
	{0x74, 0x94, 0xc2, 0xe7, 0x10, 0x4b, 0x08, 0x79},
	{0xde, 0x18, 0x89, 0x41, 0xa3, 0x37, 0x5d, 0x3a},
	{0xd6, 0xa1, 0x41, 0xa7, 0xec, 0x3c, 0x38, 0xdf, 0xbd, 0x61, 0x5a, 0x11, 0x62, 0xe1, 0xc7, 0xba, 0x36, 0xb6, 0x78, 0x58},
	{0x66, 0xa0, 0x94, 0x9f, 0x8a, 0xf7, 0xd6, 0x89, 0x1f, 0x7f, 0x83, 0x2b, 0xa8, 0x33, 0xc0, 0x0c, 0x89, 0x2e, 0xbe, 0x30, 0x14, 0x3c, 0xe2, 0x87, 0x40, 0x01, 0x1e, 0xcf},
	{0xd6, 0xa1, 0x41, 0xa7, 0xec, 0x3c, 0x38, 0xdf, 0xbd, 0x61}
	};

/*
// RC2 tests
static const unsigned char ssl_RC2key[4][16]={
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,
	 0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F},
	};

static const unsigned char ssl_rc2_iv  [8]={0,0,0,0,0,0,0,0};

static const unsigned char ssl_rc2_data_len[4]={8,8,8,8};
static const unsigned char ssl_RC2plain[4][8]={
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF},
	{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};

static const unsigned char ssl_RC2cipher[4][8]={
	{0x1C,0x19,0x8A,0x83,0x8D,0xF0,0x28,0xB7},
	{0x21,0x82,0x9C,0x78,0xA9,0xF9,0xC0,0x74},
	{0x13,0xDB,0x35,0x17,0xD3,0x21,0x86,0x9E},
	{0x50,0xDC,0x01,0x62,0xBD,0x75,0x7F,0x31},
	};
*/

// DES test

static const unsigned char ssl_cbc_key []={	0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef};
static const unsigned char ssl_cbc3_key[]={	0x01,0x23,0x45,0x67,0x89,0xab,0xcd,0xef,
										0xf1,0xe0,0xd3,0xc2,0xb5,0xa4,0x97,0x86,
										0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};

static const unsigned char ssl_cbc_iv  [8]={0xfe,0xdc,0xba,0x98,0x76,0x54,0x32,0x10};

static const unsigned char ssl_cbc_data[]={
	0x37,0x36,0x35,0x34,0x33,0x32,0x31,0x20,
	0x4E,0x6F,0x77,0x20,0x69,0x73,0x20,0x74,
	0x68,0x65,0x20,0x74,0x69,0x6D,0x65,0x20,
	0x66,0x6F,0x72,0x20,0x00,0x31,0x00,0x00
};

static const unsigned char ssl_cbc_ok[32]={
	0xcc,0xd1,0x73,0xff,0xab,0x20,0x39,0xf4,
	0xac,0xd8,0xae,0xfd,0xdf,0xd8,0xa1,0xeb,
	0x46,0x8e,0x91,0x15,0x78,0x88,0xba,0x68,
	0x1d,0x26,0x93,0x97,0xf7,0xfe,0x62,0xb4};

static const unsigned char ssl_cbc3_ok[32]={
	0x3F,0xE3,0x01,0xC9,0x62,0xAC,0x01,0xD0,
	0x22,0x13,0x76,0x3C,0x1C,0xBD,0x4C,0xDC,
	0x79,0x96,0x57,0xC0,0x64,0xEC,0xF5,0xD4,
	0x1C,0x67,0x38,0x12,0xCF,0xDE,0x96,0x75};

static const unsigned char ssl_des_cbc_size[] = {29, 32, 32};

// 3DES test


static const unsigned char ssl_des_ede_cbc3_data_len[1] = {32};

static const unsigned char ssl_des_ede_cbc3_key[24] = {
	0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
	0xf1, 0xe0, 0xd3, 0xc2, 0xb5, 0xa4, 0x97, 0x86,
	0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10
};

static const unsigned char ssl_des_ede_cbc3_iv[8] = {
	0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10
};

static const unsigned char ssl_des_ede_cbc3_input[32] = {
	0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x20,
	0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74,
	0x68, 0x65, 0x20, 0x74, 0x69, 0x6D, 0x65, 0x20,
	0x66, 0x6F, 0x72, 0x20, 0x00, 0x00, 0x00, 0x00
};

static const unsigned char ssl_des_ede_cbc3_output[32] = {
    0x3F, 0xE3, 0x01, 0xC9, 0x62, 0xAC, 0x01, 0xD0,
	0x22, 0x13, 0x76, 0x3C, 0x1C, 0xBD, 0x4C, 0xDC,
	0x79, 0x96, 0x57, 0xC0, 0x64, 0xEC, 0xF5, 0xD4,
	0x1C, 0x67, 0x38, 0x12, 0xCF, 0xDE, 0x96, 0x75
};

// AES test

static const unsigned char ssl_aes_data_len[1] = {16};

// AES-128-CBC


static const unsigned char ssl_aes_128_cbc_key[5][16] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C},
	{0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C},
	{0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C},
	{0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6, 0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C},
};

static const unsigned char ssl_aes_128_cbc_iv[5][16] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F},
	{0x76, 0x49, 0xAB, 0xAC, 0x81, 0x19, 0xB2, 0x46, 0xCE, 0xE9, 0x8E, 0x9B, 0x12, 0xE9, 0x19, 0x7D},
	{0x50, 0x86, 0xCB, 0x9B, 0x50, 0x72, 0x19, 0xEE, 0x95, 0xDB, 0x11, 0x3A, 0x91, 0x76, 0x78, 0xB2},
	{0x73, 0xBE, 0xD6, 0xB8, 0xE3, 0xC1, 0x74, 0x3B, 0x71, 0x16, 0xE6, 0x9E, 0x22, 0x22, 0x95, 0x16},
};

static const unsigned char ssl_aes_128_cbc_input[5][16] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A},
	{0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C, 0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51},
	{0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11, 0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF},
	{0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17, 0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10},
};

static const unsigned char ssl_aes_128_cbc_output[5][16] = {
	{0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84, 0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D},
	{0x76, 0x49, 0xAB, 0xAC, 0x81, 0x19, 0xB2, 0x46, 0xCE, 0xE9, 0x8E, 0x9B, 0x12, 0xE9, 0x19, 0x7D},
	{0x50, 0x86, 0xCB, 0x9B, 0x50, 0x72, 0x19, 0xEE, 0x95, 0xDB, 0x11, 0x3A, 0x91, 0x76, 0x78, 0xB2},
	{0x73, 0xBE, 0xD6, 0xB8, 0xE3, 0xC1, 0x74, 0x3B, 0x71, 0x16, 0xE6, 0x9E, 0x22, 0x22, 0x95, 0x16},
	{0x3F, 0xF1, 0xCA, 0xA1, 0x68, 0x1F, 0xAC, 0x09, 0x12, 0x0E, 0xCA, 0x30, 0x75, 0x86, 0xE1, 0xA7},
};



// AES-256-CBC


static const unsigned char ssl_aes_256_cbc_key[5][32] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4},
	{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4},
	{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4},
	{0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE, 0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81, 0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7, 0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4},
};

static const unsigned char ssl_aes_256_cbc_iv[5][16] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F},
	{0xF5, 0x8C, 0x4C, 0x04, 0xD6, 0xE5, 0xF1, 0xBA, 0x77, 0x9E, 0xAB, 0xFB, 0x5F, 0x7B, 0xFB, 0xD6},
	{0x9C, 0xFC, 0x4E, 0x96, 0x7E, 0xDB, 0x80, 0x8D, 0x67, 0x9F, 0x77, 0x7B, 0xC6, 0x70, 0x2C, 0x7D},
	{0x39, 0xF2, 0x33, 0x69, 0xA9, 0xD9, 0xBA, 0xCF, 0xA5, 0x30, 0xE2, 0x63, 0x04, 0x23, 0x14, 0x61},
};

static const unsigned char ssl_aes_256_cbc_input[5][16] = {
	{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
	{0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96, 0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A},
	{0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C, 0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51},
	{0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11, 0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF},
	{0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17, 0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10},
};

static const unsigned char ssl_aes_256_cbc_output[5][16] = {
	{0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5, 0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0},
	{0xF5, 0x8C, 0x4C, 0x04, 0xD6, 0xE5, 0xF1, 0xBA, 0x77, 0x9E, 0xAB, 0xFB, 0x5F, 0x7B, 0xFB, 0xD6},
	{0x9C, 0xFC, 0x4E, 0x96, 0x7E, 0xDB, 0x80, 0x8D, 0x67, 0x9F, 0x77, 0x7B, 0xC6, 0x70, 0x2C, 0x7D},
	{0x39, 0xF2, 0x33, 0x69, 0xA9, 0xD9, 0xBA, 0xCF, 0xA5, 0x30, 0xE2, 0x63, 0x04, 0x23, 0x14, 0x61},
	{0xB2, 0xEB, 0x05, 0xE2, 0xC3, 0x9B, 0xE9, 0xFC, 0xDA, 0x6C, 0x19, 0x07, 0x8C, 0x6A, 0x9D, 0x1B},
};


int TestEncrypt(SSL_BulkCipherType ciphertype, const unsigned char *key, const unsigned char *iv,
			const unsigned char *plain, int plain_len,
			const unsigned char *encrypted, unsigned int encrypted_len)
{
	SSL_GeneralCipher *cipher = NULL;
	unsigned char *output_data = (unsigned char *)g_memory_manager->GetTempBuf2k();
	uint32 count=0, count1=0;
	unsigned int buf_len = g_memory_manager->GetTempBuf2kLen();

	OP_STATUS op_err = OpStatus::ERR;
	cipher = g_ssl_api->CreateSymmetricCipher(ciphertype, op_err);
	if(OpStatus::IsError(op_err) || cipher == NULL)
	   return -1;

	if(buf_len < encrypted_len)
		return -3;

	if(buf_len <= ((unsigned int) plain_len + (cipher->OutputBlockSize() > 1 ? cipher->OutputBlockSize() : 1)*2))
		return -4;

	cipher->SetCipherDirection(SSL_Encrypt);

	cipher->LoadKey(key);
	cipher->LoadIV(iv);
	cipher->SetPaddingStrategy(SSL_NO_PADDING);

	OPERA_cleanse(output_data, buf_len);

	cipher->InitEncrypt();
	cipher->Encrypt(plain, plain_len,output_data, count, buf_len);
	cipher->FinishEncrypt(output_data+count, count1, buf_len-count);

	count += count1;

	OP_DELETE(cipher);

	return (count == encrypted_len ? (op_memcmp(output_data, encrypted, count) == 0 ? 0 : -5) : -6);
}

int TestDecrypt(SSL_BulkCipherType ciphertype, const unsigned char *key, const unsigned char *iv,
			const unsigned char *plain, unsigned int plain_len,
			const unsigned char *encrypted, unsigned int encrypted_len)
{
	SSL_GeneralCipher *cipher = NULL;
	unsigned char *output_data = (unsigned char *) g_memory_manager->GetTempBuf2k();
	uint32 count=0, count1=0;
	unsigned int buf_len = g_memory_manager->GetTempBuf2kLen();

	OP_STATUS op_err = OpStatus::ERR;
	cipher = g_ssl_api->CreateSymmetricCipher(ciphertype, op_err);
	if(OpStatus::IsError(op_err) || cipher == NULL)
	   return -1;

	if(buf_len < encrypted_len)
		return -3;

	if(buf_len <= (plain_len + (cipher->OutputBlockSize() > 1 ? cipher->OutputBlockSize() : 1)*2))
		return -4;

	cipher->SetCipherDirection(SSL_Decrypt);

	cipher->LoadKey(key);
	cipher->LoadIV(iv);
	cipher->SetPaddingStrategy(SSL_NO_PADDING);

	OPERA_cleanse(output_data, buf_len);

	cipher->InitDecrypt();
	cipher->Decrypt(encrypted, encrypted_len,output_data, count, buf_len);
	cipher->FinishDecrypt(output_data+count, count1, buf_len-count);

	count += count1;


	if(cipher->OutputBlockSize() != 1)
	{
		if(count % cipher->OutputBlockSize() != 0)
			return -6;
		if(count < plain_len)
			return -7;
		else if(count != plain_len && count - plain_len >= cipher->OutputBlockSize())
			return -8;
		OP_DELETE(cipher);

		return (op_memcmp(output_data, plain, plain_len) == 0 ? 0 : -9);
	}
	OP_DELETE(cipher);

	return (count == plain_len ? (op_memcmp(output_data, plain, count) == 0 ? 0  : -5) : -6);
}

}


table testlist(const char *, int ,
			SSL_BulkCipherType, const unsigned char *, const unsigned char *,
			const unsigned char *, const unsigned char *,
			const unsigned char *, const unsigned char *) {
	{"Null",    0,  SSL_NoCipher, ssl_null_keys[0], NULL,   ssl_null_data[0],   &ssl_null_data_len,     ssl_null_data[0],   &ssl_null_data_len},
	{"Null",    1,  SSL_NoCipher, ssl_null_keys[1], NULL,   ssl_null_data[1],   &ssl_null_data_len,     ssl_null_data[1],   &ssl_null_data_len},
	{"Null",    2,  SSL_NoCipher, ssl_null_keys[2], NULL,   ssl_null_data[2],   &ssl_null_data_len,     ssl_null_data[2],   &ssl_null_data_len},
	{"Null",    3,  SSL_NoCipher, ssl_null_keys[0], NULL,   ssl_null_data[1],   &ssl_null_data_len,     ssl_null_data[1],   &ssl_null_data_len},
	{"Null",    4,  SSL_NoCipher, ssl_null_keys[1], NULL,   ssl_null_data[2],   &ssl_null_data_len,     ssl_null_data[2],   &ssl_null_data_len},
	{"Null",    5,  SSL_NoCipher, ssl_null_keys[2], NULL,   ssl_null_data[0],   &ssl_null_data_len,     ssl_null_data[0],   &ssl_null_data_len},
	{"Null",    6,  SSL_NoCipher, ssl_null_keys[0], NULL,   ssl_null_data[2],   &ssl_null_data_len,     ssl_null_data[2],   &ssl_null_data_len},
	{"Null",    7,  SSL_NoCipher, ssl_null_keys[1], NULL,   ssl_null_data[0],   &ssl_null_data_len,     ssl_null_data[0],   &ssl_null_data_len},
	{"Null",    8,  SSL_NoCipher, ssl_null_keys[2], NULL,   ssl_null_data[1],   &ssl_null_data_len,     ssl_null_data[1],   &ssl_null_data_len},
	{"RC4",		0,	SSL_RC4,	ssl_rc4_keys[0],	NULL,	ssl_rc4_data[0],	&ssl_rc4_data_len[0],	ssl_rc4_output[0],	&ssl_rc4_data_len[0]},
	{"RC4",		1,	SSL_RC4,	ssl_rc4_keys[1],	NULL,	ssl_rc4_data[1],	&ssl_rc4_data_len[1],	ssl_rc4_output[1],	&ssl_rc4_data_len[1]},
	{"RC4",		2,	SSL_RC4,	ssl_rc4_keys[2],	NULL,	ssl_rc4_data[2],	&ssl_rc4_data_len[2],	ssl_rc4_output[2],	&ssl_rc4_data_len[2]},
	{"RC4",		3,	SSL_RC4,	ssl_rc4_keys[3],	NULL,	ssl_rc4_data[3],	&ssl_rc4_data_len[3],	ssl_rc4_output[3],	&ssl_rc4_data_len[3]},
	{"RC4",		4,	SSL_RC4,	ssl_rc4_keys[4],	NULL,	ssl_rc4_data[4],	&ssl_rc4_data_len[4],	ssl_rc4_output[4],	&ssl_rc4_data_len[4]},
	{"RC4",		5,	SSL_RC4,	ssl_rc4_keys[5],	NULL,	ssl_rc4_data[5],	&ssl_rc4_data_len[5],	ssl_rc4_output[5],	&ssl_rc4_data_len[5]},
	//{"DES",		0,	SSL_DES,	ssl_cbc_key,	ssl_cbc_iv,	ssl_cbc_data,		&ssl_des_cbc_size[0],	ssl_cbc_ok,			&ssl_des_cbc_size[1]},
	//{"3DES",	0,	SSL_3DES,	ssl_cbc3_key,	ssl_cbc_iv,	ssl_cbc_data,		&ssl_des_cbc_size[0],	ssl_cbc3_ok,		&ssl_des_cbc_size[2]},
	{"3DES",	1,	SSL_3DES,	ssl_des_ede_cbc3_key,	  ssl_des_ede_cbc3_iv,   ssl_des_ede_cbc3_input,   &ssl_des_ede_cbc3_data_len[0],	ssl_des_ede_cbc3_output, &ssl_des_ede_cbc3_data_len[0]},
	//{"AES-128",	0,	SSL_AES_128_CBC,  ssl_aes_128_cbc_key[0], ssl_aes_128_cbc_iv[0], ssl_aes_128_cbc_input[0], &ssl_aes_data_len[0], ssl_aes_128_cbc_output[0], &ssl_aes_data_len[0]},
	{"AES-128",	1,	SSL_AES_128_CBC,  ssl_aes_128_cbc_key[1], ssl_aes_128_cbc_iv[1], ssl_aes_128_cbc_input[1], &ssl_aes_data_len[0], ssl_aes_128_cbc_output[1], &ssl_aes_data_len[0]},
	{"AES-128",	2,	SSL_AES_128_CBC,  ssl_aes_128_cbc_key[2], ssl_aes_128_cbc_iv[2], ssl_aes_128_cbc_input[2], &ssl_aes_data_len[0], ssl_aes_128_cbc_output[2], &ssl_aes_data_len[0]},
	{"AES-128",	3,	SSL_AES_128_CBC,  ssl_aes_128_cbc_key[3], ssl_aes_128_cbc_iv[3], ssl_aes_128_cbc_input[3], &ssl_aes_data_len[0], ssl_aes_128_cbc_output[3], &ssl_aes_data_len[0]},
	{"AES-128",	4,	SSL_AES_128_CBC,  ssl_aes_128_cbc_key[4], ssl_aes_128_cbc_iv[4], ssl_aes_128_cbc_input[4], &ssl_aes_data_len[0], ssl_aes_128_cbc_output[4], &ssl_aes_data_len[0]},
	//{"AES-256",	0,	SSL_AES_256_CBC,  ssl_aes_256_cbc_key[0], ssl_aes_256_cbc_iv[0], ssl_aes_256_cbc_input[0], &ssl_aes_data_len[0], ssl_aes_256_cbc_output[0], &ssl_aes_data_len[0]},
	{"AES-256",	1,	SSL_AES_256_CBC,  ssl_aes_256_cbc_key[1], ssl_aes_256_cbc_iv[1], ssl_aes_256_cbc_input[1], &ssl_aes_data_len[0], ssl_aes_256_cbc_output[1], &ssl_aes_data_len[0]},
	{"AES-256",	2,	SSL_AES_256_CBC,  ssl_aes_256_cbc_key[2], ssl_aes_256_cbc_iv[2], ssl_aes_256_cbc_input[2], &ssl_aes_data_len[0], ssl_aes_256_cbc_output[2], &ssl_aes_data_len[0]},
	{"AES-256",	3,	SSL_AES_256_CBC,  ssl_aes_256_cbc_key[3], ssl_aes_256_cbc_iv[3], ssl_aes_256_cbc_input[3], &ssl_aes_data_len[0], ssl_aes_256_cbc_output[3], &ssl_aes_data_len[0]},
	{"AES-256",	4,	SSL_AES_256_CBC,  ssl_aes_256_cbc_key[4], ssl_aes_256_cbc_iv[4], ssl_aes_256_cbc_input[4], &ssl_aes_data_len[0], ssl_aes_256_cbc_output[4], &ssl_aes_data_len[0]},
};


setup
{
	SSL_initialized = TRUE;
}

test("Test SSL initialized")
{
	verify(SSL_initialized);
}

test("Test Symmetric Encryption")  require success "Test SSL initialized";
{
	iterate (name, test_num, func,key, iv, plain, plain_len, encrypted, encrypted_len) from testlist
	{
		output("\ntesting %s set %d ", name, test_num);
		verify(plain_len != NULL);
		verify(encrypted_len != NULL);
		verify(TestEncrypt(func,key, iv, plain, (unsigned int) *plain_len, encrypted, (unsigned int) *encrypted_len) == 0);
	}
}

test("Test Symmetric Decryption")  require success "Test SSL initialized";
{
	iterate (name, test_num, func,key, iv, plain, plain_len, encrypted, encrypted_len) from testlist
	{
		output("\ntesting %s set %d ", name, test_num);
		verify(plain_len != NULL);
		verify(encrypted_len != NULL);
		verify(TestDecrypt(func,key, iv, plain, (unsigned int) *plain_len, encrypted, (unsigned int) *encrypted_len) == 0);
	}
}


