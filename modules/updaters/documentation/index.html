<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
          "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<link rel=stylesheet href="../../coredoc/coredoc.css" />
<title>Module: URL</title>
</head>

<body>

<h1>Module: Updaters</h1>

<h2>About this module</h2>

<p>The updaters module will retrieve documents from a location specified by a URL provided by the application. 
After download, the file can then be processed and actions taken based on the data. Multiple downloads can 
be organized using AutoFetch_Manager, which can also be customized.</p>

<p>Currently the only format directly supported is on based on XML. When received, the document's digital 
signature will be (optionally) verified, and the file parsed as an XMLFragement. The parsing is then handed 
over to the implementation.</p>

<h2>Interface overview and API documentation</h2>

<p><a href="api/index.html">API documentation generated by
Doxygen</a> contains all necessary information for the external APIs.</p>

<p>The module currently have 3 classes:<p>

<h3>The basic APIs</h3>

<dl>
	<dt>AutoFetch_Element
		<dd><p>Organizes the fundamental API and the application specific finished message posting. It does not handle any URLs directly</p>
			<p>Usage:</p>
			<dl>
				<dt>Construction (Construct())
					<dd><p>Specify the message to be posted (Will be posted with Id() of the element as par1 when PostFinished is called,
						par 2 is a application specific result code).</p>
				<dt>StartLoading()
					<dd><p>Application specific function to start the operation. Return OpStatus::OK if operations has started, but not finished; 
						OpRecStatus::FINISHED if the operation completely finished, and an error status if there was an error.</p>
				<dt>PostFinished()
					<dd><p>Called by implementation when finished with the result code to be posted back to the caller. After this call IsFinished()
					will return TRUE</p>
				<dt>IsFinished()
					<dd><p>Return TRUE if the operation is finished. Can be used to poll elements</p>
			</dl>
	<dt>AutoFetch_Manager
		<dd><p>Can organize multiple fetch elements and send an application specific message when all are finished. Which message(s) to listen for from
  	the elements have to be configured by the application; the class assumes any message with an ID in the list is a finished message</p>
			<p>Usage:</p>
			<dl>
				<dt>Construction/InitL
					<dd><p>The constructor is initialized with the Message code posted by the manager when all currently loading updaters are finished 
					(the message have no parameters).The owner/application MUST register the callbacks for the messages to listen for.</p>
				<dt>AddUpdater
					<dd>Adds a new updater to the list. Takes ownership and calls StartLoading(). When finished, the object will be automatically deleted.
			</dl>
</dl>

<h3>The midlevel API</h3>

<dl>
  <dt>URL_Updater
  	<dd><p>Downloads a URL and then passes it on to the application specific processing.</p>
			<p>Usage:</p>
			<dl>
				<dt>Construct()
					<dd><p>The object is initialized with the URL of the resource to be loaded and the message to post when finished</p>
				<dt>StartLoading()
					<dd>Starts loading the resource. Must not be called if added to a manager.
				<dt>SetLoadPolicy()
					<dd>This changes the load caching policy from always do a full load (the default) to the specified policy.
				<dt>ResourceLoaded()
					<dd><p>Application specific function that processes the file called if the loading is successful. 
						The loaded url is passed as an argument </p>
			</dl>
  <dt>XML_Updater
  	<dd><p>Downloads a URL and processes the file as an XML document, and can verify digital signatures that follows a specific prefix. Once the 
  				XML is parsed the processing is handed over to the implementations.</p>
			<p>Usage:</p>
			<dl>
				<dt>Construct()
					<dd><p>The object is initialized with the URL of the XML document to be loaded and the message to post when finished</p>
				<dt>StartLoading()
					<dd>Starts loading the document. Must not be called if added to a manager.
				<dt>SetLoadPolicy()
					<dd>This changes the load caching policy from always do a full load (the default) to the specified policy.
				<dt>ProcessFile()
					<dd><p>Application specific function that processes the file. The "parser" member is initialized when this functionis called and can be 
					used to process the XML document.</p>
					<p>Helper functions</p>
						<dl>
							<dt>GetFlag
								<dd>Return TRUE if the specified element is in the current parser level.
							<dt>GetTextData
								<dd>Gets the text content of the current element
							<dt>GetBase64Data
								<dd>Processes the text content in the current element as Base64 encoded content and returns the decoded binary data. 
									Have both DataStream and SSL_varvector variants.
							<dt>GetHexData
								<dd>Processes the text content in the current element as hexadecimal encoded content and returns the decoded binary data. 
									Have both DataStream and SSL_varvector variants.
						</dl>
				<dt>VerifyFile()
					<dd><p>Application specific function that verifies the signature on the file.</p>
						<p>The default implementation is configured using this API (applications overrding the default should not use this):</p>
						<dl>
							<dt>SetVerifyFile()
								<dd><p>This function specifies whether or not the loading document should be verifies, and if so,
									 which public key and algorithm to use. The default is to use the rootstore module's 
									public key and SHA-256.</p>
						</dl>
						<p>By default the verification function uses (cstring-style)<tt>"&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;\n&lt;!--"</tt> as a prefix
					before the signature followed by a CRLF and the signed content (which must include the comment end tag).</p>
			</dl>
</dl>

<h2>Implementation description</h2>

<p><a href="all/index.html">API documentation generated by
Doxygen</a> contains information about the internal organization of the module.</p>

<h3>Footprint</h3>

<p>The module is fairly small, about 5KB. It implements basic functionality imported by other modules as a foundation for their functionality, 
while most of the actual functionality is implemented in, and imported, from other modules, primarily url, xml, and libcrypto. </p>

<h3>Dynamic memory use and OOM handling</h3>

<dl>
<dt>OOM policies
<dd><p>In OOM situations the current operation is aborted and a failure notice is given to the action's owner, either 
	by message or OpStatus return value. Very few functions LEAVE.</p>
	<p>An OOM condition is raised when detected in the module itself</p>

<dt>Who handles OOM?
<dd><p>Currently OOM is handled locally by aborting the operation. In some operations, when it is possible, the caller is informed of the status</p>

<dt>Flow
<dd><p>Much of the module is message callback based, and these functions are not able to report OOM situations directly to the documents or UI. 
	In these cases the current operation will be terminated, and errormessages sent.</p>

<dt>Heap memory usage
<dd><p>There is no static heap memory use. A number of operations, like processing the XML file (read and parse) will keep the entire document in memory 
	for the duration of the operation. For large XML documents that MAY lead to OOM situation, and applications that may encounter such large files should 
use handlers that are designed for such sizes.</p>

<dt>Stack memory usage
<dd><p>Minimal. Most operations are done in heap allocated memory.</p>

<dt>Static memory usage
<dd><p>None</p>

<dt>Caching and freeing memory
<dd><p>Caching is managed by URLs. Memory is only used during actual operations and released immediately after use.</p>

<dt>Freeing memory on exit
<dd><p>Controlled by applications. Classes clean up their own memory use.</p>

<dt>Temp buffers
<dd><p>None.</p>

<dt>Memory tuning
<dd><p>Not possible, except as already available thorugh URL and possibly XML</p>

<dt>Tests
<dd><p>Selftests using libssl's automatic rootstore update and EV ability, and the pubsuffix module's tests.</p>

<dt>Coverage
<dd><p>Selftests</p>

<dt>Design choices
<dd><p>Classes are tailored for specific operations, AutoFetch_Element to provide the basic API, AutoFetch_Manager to manage multiple loads, XML_Updater
to handle digitally signed XML documents. Specific implementations in subclasses are needed to actually do something.</p>

<dt>Improvements
<dd> <p>Should the URL handling in XML Updater be moved down into the FetchElement? 
Or does the current arrangement make better sense? Alternatively, should XML updater be broken into two separate classes</p>

</dl>
