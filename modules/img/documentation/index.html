<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
          "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<link rel=stylesheet href="../../coredoc/coredoc.css" />
<title>Img module</title>
</head>

<body>

<h1>Img module</h1>

$Id$

<h2>Introduction</h2>

<h3>General description</h3>

The img module is repsonsible for all image decoding and the image cache.
It does not draw the images, that is done by display, it only decodes and
caches them and returns bitmaps when requested.
<p>The main purposes of the img module are
<ul>
	<li>Caches decoded images</li>
	<li>Decodes images (in some cases using image decoders in other modules</li>
	<li>Can animate between frames when requested</li>
	<li>Does not draw images, this is done by the doc module in core-1, and the display module in core-2</li>
	<li>Implements the following decoders: gif, xbm, bmp, wbmp, ico</li>
	<li>Related modules, jpg implemented with libjpeg in core-1, with jaypeg in core-2, png implemented with minpng in both
    core-1 and core-2.</li>
</ul>
</p>

<h3>Use-cases</h3>

<ul>
	<li>Load an image in the browser</li>
	<li>Load a page containing images</li>
</ul>
<p>In both these cases the image which is to be displayed by Opera
will be decoded and cached by the img module.</p>

<h3>Design goals</h3>

The design goals of img are:
<ul>
	<li>Support both core-1 and core-2 through the same interface</li>
	<li>Interface compatibility with dali_1 in many cases</li>
	<li>Does not draw images, belongs in display code</li>
	<li>Does not depend on other modules (except base modules), a
	clean interface is defined (for example, does not reference to
	the url module)
	<li>Does not animate images (that is, setting up timers, etc).
	This has to be decided by the document.</li>
	<li>Supports animations being out of sync in different
	documents with each other</li>
</ul>

<h3>Supported standards</h3>

<ul>
	<li>bmp (link to specification)</li>
	<li>gif (<a href="http://www.w3.org/Graphics/GIF/spec-gif89a.txt">specification</a>)</li>
	<li>ico (link to specification)</li>
	<li>jpeg (through jaypeg/libjpeg modules) (<a href="http://www.w3.org/Graphics/JPEG/">specification</a>)</li>
	<li>png (through minpng module) (<a href="http://www.w3.org/TR/PNG/">specification</a>)</li>
	<li>wbmp (<a href="http://www.wapforum.org/what/technical/SPEC-WAESpec-19990524.pdf">specification</a>)</li>
	<li>xbm (<a href="http://www.dcs.ed.ac.uk/home/mxr/gfx/2d/XBM.txt">specification</a>)</li>
</ul>

<h3>On decoding and memory</h3>
The image module guarantees that all completely decoded lines will contain no uninitialized data. In the case of indexed color data, the platform implementing AddLine will have to bounds-check color indices.

<h2>API documentation</h2>

The <a href="api/index.html">API documentation</a> is generated by Doxygen.

<h2>Memory handling</h2>

The memory usage and OOM handling is described in the mainpage of the 
<a href="api/index.html">API documentation</a>.

<h2>Implementation details</h2>

<p>Some implementation details are described in the mainpage of the 
<a href="api/index.html">API documentation</a>.</p>
<p>
The core functionality of the image module is the decode images and cache them.
</p>
<h3>Image representation</h3>
<p>The image object in the img module contains an ImageRep. The ImageRep 
contains the actual data and can be shared between multiple Image object. It is 
the ImageRep which is stored in the image cache.</p>
<p>The ImageRep contains a content provider, image loader, meta data, some flags
and most importently an image content. The image content can be of several 
different types. A null image content means the size is not yet known. There
is only one null image content. An empty image content means the size is known 
but the image is not yet decoded. A static image content is used for images with
a single frame, regardless if it is animated or not. An animated image content
is used for animated images.</p>

<h3>Image decoding</h3>
<p>
The decoding of images is done through image decoders. The image decoders 
factories, which can be used to create decoders are registered in the image 
manager and can then be used by the image module to decode images. You can 
register any number of image decoders. Most of the decoder factories are 
included in the img module.</p>
<p>
The image decoder factories are designed to be able to given a data stream 
detect if the data stream could be a supported image. This is used to 
determine which image decoder to use. If a factory detects a supported format it
will probably be asked to create an image decoder later on.
</p>
<p>
The image decoder factories are also able to check the size of an image 
without creating a decoder and decoding it. This is needed to check the size 
of image which are not visible without spending much time on it.
</p>
<p>The actual image decoders created by the factories must handle decoding of
data without having the entire data stream. The image module will call 
DecodeData repeatedly with chunks of data. If the decode cannot handle all of it
it must report how much data to resend.</p>

<h3>Image cache</h3>
<p>The image cache in the image module caches ImageReps. The current cache
strategy is to cache images on a MRU basis, but images which are visible in a 
document are always kept in the cache. This means that the cache can exceed the
cache limit.</p>
<p>The image cache consists of three different lists. One list for free images,
one list for decoded images which are not visible and one list for decoded 
images which are visible. When an image is marked as visible or not visible it 
is moved between the lists.</p>

</body>
</html>

