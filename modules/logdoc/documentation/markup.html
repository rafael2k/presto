<html>
<head>
 <link rel="stylesheet" type="text/css" href="doc.css" />
 <link rel="alternate stylesheet" title="Sand" type="text/css" href="sand.css" />
</head>

<body>
<span style="font-size: 10px">(if you don't like the colors, check out the alternate stylesheets or create your own:)</span>

<h1>Markup table generation</h1>

<p>Instead of storing the strings for the names of elements and attributes Opera has numeric codes
  that maps to string tables with the canonical names. The tables used for names and type codes for
  elements and attribute are generated at build-time by the script
  <tt>modules/logdoc/scripts/mkmarkup.py</tt>. The generated tables are based on the information
  found in files called <tt><a href="#module">module.markup</a></tt>, which can be put in any module
  in the tree. The generated files will combine all the element and attribute names found in all
  the <tt><a href="#module">module.markup</a></tt> files.</p>

<p>The files generated resides in the <tt>modules/logdoc/src/html5</tt> folder. The following files
  are generated:</p>

<dl>
 <dt><tt>elementtypes.h</tt></dt>
 <dd>Type codes for element names.</dd>

 <dt><tt>elementnames.h</tt></dt>
 <dd>The strings for canonical names in <a href="#flattening">flattened</a> lowercase (for when
 parsed as HTML), mixed case (for when parsed as XML or foreign content in HTML) and uppercase
 (returned by DOM in some cases).</dd>

 <dt><tt>attrtypes.h</tt></dt>
 <dd>Type codes for all attribute names.</dd>

 <dt><tt>attrnames.h</tt></dt>
 <dd>The strings for canonical names in <a href="#flattening">flattened</a> lowercase (for when
 parsed as HTML), mixed case (for when parsed as XML or foreign content in HTML) and uppercase
 (returned by DOM in some cases)</dd>
</dl>

<p>In addition there are two files <tt>elementhashbase.h</tt> and <tt>attrhashbase.h</tt> in the
  same folder which are also generated by the same script but usually not during building.</p>

<div id="tables" class="section">
<h2>The tables</h2>

<h3><tt>g_html5_tag_names</tt></h3>

<p>Holds all <a href="#flattening">flattened</a> and mixed case strings of all the elements. Each
  entry that has a mixed case representation also has a namespace (<tt>Markup::Ns</tt>) field
  indicating when to use the mixed case version.</p>
<p>The table is a one dimentional array since the length of the entires can differ quite a
  lot. The <tt>g_html5_tag_indices</tt> gives the offset into the array for each type.</p>

<p><tt></tt></p>

<h3><tt>g_html5_tag_names_upper</tt></h3>

<p>Holds the uppercased versions of all the element names. Used by some DOM functions.</p>

<h3><tt>g_html5_attr_names</tt></h3>

<p>Holds all <a href="#flattening">flattened</a> and mixed case strings of all the attributes. Each
  entry that has a mixed case representation also has a namespace (<tt>Markup::Ns</tt>) field
  indicating when to use the mixed case version.</p>
<p>The table is a one dimentional array since the length of the entires can differ quite a
  lot. The <tt>g_html5_attr_indices</tt> gives the offset into the array for each type.</p>

<h3><tt>g_html5_attr_names_upper</tt></h3>

<p>Holds the uppercased versions of all the attribute names. Used by some DOM functions.</p>

<h2>The Markup class</h2>

<p>The <tt>Markup</tt> class acts as a namespace for the element and attribute type constants. It
  contains enums for element codes (<tt>Markup::Type</tt>, attribute codes
  (<tt>Markup::AttrType</tt>) and namespace constants (<tt>Markup::Ns</tt>) used by the HTML 5
  parser.</p>

<h3><tt>Markup::Type</tt></h3>

<p>A long enum representing all the normal elements and the special ones. Entries are categorized as
  real elements (with a string representation), special elements (without a string representation),
  placeholders (for keeping the values increasing monotonically) and delimiters.</p>

<h4>Real elements</h4>

<p>Real elements will have the format <code>prefix + 'E_' + name</code>, where <tt>prefix</tt> is to
  indicate which namespace it usually belongs to, like <tt>HT</tt> for HTML or <tt>SVG</tt> for
  SVG, and <tt>name</tt> is the uppercased name of the element name string it
  represents. <b>Example:</b> <tt>HTE_SPAN</tt> for the <tt>span</tt> element.</p>

<h4>Special elements</h4>

<p>Special elements does not have a normal string representation of the name
  (like <tt>HTE_TEXTGROUP</tt>), even though some of them can appear in markup
  (like <tt>HTE_DOCTYPE</tt>). They will have the same format as the real elements, except
  the <tt>name</tt> part will not be matching any string representation. They will all be
  placed after the <tt>HTE_LAST</tt> entry in the enum. Some of the special elements are even more
  special in that they are sometimes considered to be real elements for layout purposes
  (like <tt>HTE_TEXT</tt> and they are placed between <tt>HTE_LAST</tt>
  and <tt>HTE_FIRST_SPECIAL</tt>. Sounds confusing? It is ;-)</p>

<h4>Placeholders</h4>

<p>Placeholders are inserted after the first of several consecutive entries of the same string. If
  more than one namespace has the same string, an entry with the different prefixes will be added to
  the enum, but they will all have the same numerical value as the first entry. To make the next
  unique entry have the value immediately following the last one, it will be assigned the value the
  placeholder has. The format for placeholder entries is <code>next + '__PLACEHOLDER'</code>
  where <tt>next</tt> is the name of the next unique entry (so that it is easy to see which element
  it really is in a debugger).</p>

<h4>Delimiters</h4>

<p>Some of the entries are really just there to hold the value of some important properties of the
  table, like where it starts and where it ends. The value of the first entry will always
  be <tt>HTE_FIRST</tt>. The last of the normal elements will have the value of <tt>HTE_LAST</tt>
  and the absolutely last, after all the special elements, will be <tt>HTE_ABSOLUTELY_LAST</tt>. The
  group of really special elements will be between <tt>HTE_LAST</tt>
  and <tt>HTE_FIRST_SPECIAL</tt>.</p>

<h3><tt>Markup::AttrType</tt></h3>

<p>A long enum representing all the normal attributes and the special ones. Entries are categorized
  as real attributes (with a string representation), special attributes (without a string
  representation), placeholders (for keeping the values increasing monotonically) and
  delimiters.</p>

<h4>Real attributes</h4>

<p>Real attributes will have the format <code>prefix + 'A_' + name</code>, where <tt>prefix</tt> is
  to indicate which namespace it usually belongs to, like <tt>H</tt> for HTML or <tt>W</tt> for
  WML, and <tt>name</tt> is the uppercased name of the attribute name string it
  represents. <b>Example:</b> <tt>HA_HREF</tt> for the <tt>href</tt> attribute.</p>

<h4>Special attributes</h4>

<p>Special attributes does not have a normal string representation of the name
  (like <tt>HA_XML</tt>). They will have the same format as the real attributes, except
  the <tt>name</tt> part will not be matching any string representation. They will all be placed
  after the <tt>HA_LAST</tt> entry in the enum.</p>

<h4>Placeholders</h4>

<p>Placeholders are inserted after the first of several consecutive entries of the same string. If
  more than one namespace has the same string, an entry with the different prefixes will be added to
  the enum, but they will all have the same numerical value as the first entry. To make the next
  unique entry have the value immediately following the last one, it will be assigned the value the
  placeholder has. The format for placeholder entries is <code>next + '__PLACEHOLDER'</code>
  where <tt>next</tt> is the name of the next unique entry (so that it is easy to see which
  attribute it really is in a debugger).</p>

<h4>Delimiters</h4>

<p>Some of the entries are really just there to hold the value of some important properties of the
  table, like where it starts and where it ends. The value of the first entry will always
  be <tt>HA_FIRST</tt>. The last of the normal attributes will have the value of <tt>HA_LAST</tt>
  and the absolutely last, after all the special attributes, will
  be <tt>HA_ABSOLUTELY_LAST</tt>.</p>

<h3><tt>Markup::Ns</tt></h3>

<p>This enum holds the constants for the namespaces used by the HTML 5 parser.</p>
</div>

<div id="module" class="section">
<h2><tt>module.markup</tt></h2>

<p>All elements and attributes are specified in a <tt>module.markup</tt> file that can be placed in
the root directory of any module. This means that any module can specify their own elements or
attributes.</p>

<h2>Format</h2>

<p>The format of the <tt>module.markup</tt> file is an XML application with the DTD specified
below.</p>

<h3>DTD</h3>
<code>&lt;!ELEMENT <a href="#elm-markup">markup</a> (elements | attributes)&gt;
&lt;!ELEMENT <a href="#elm-elements">elements</a> (elm)&gt;
&lt;!ATTLIST elements
  prefix  CDATA    #REQUIRED
  ns      CDATA    #REQUIRED
&gt;
&lt;!ELEMENT <a href="#elm-attributes">attributes</a> (attr)&gt;
&lt;!ATTLIST attributes
  prefix  CDATA    #REQUIRED
  ns      CDATA    #REQUIRED
&gt;
&lt;!ELEMENT <a href="#elm-elm">elm</a> EMPTY&gt;
&lt;!ATTLIST elm
  name    CDATA    #REQUIRED
  str     CDATA    #REQUIRED
&gt;
&lt;!ELEMENT <a href="#elm-attr">attr</a> EMPTY&gt;
&lt;!ATTLIST attr
  name    CDATA    #REQUIRED
  str     CDATA    #REQUIRED
&gt;
</code>

<h4 id="elm-markup">The <tt>markup</tt> element</h4>

<p>This element is just a placeholder for the other elements.</p>
<p>It has no attributes.</p>
<p>It can contain any number of <tt><a href="#elm-elements">elements</a></tt>
  or <tt><a href="#elm-attributes">attributes</a></tt> elements.</p>

<h4 id="elm-elements">The <tt>elements</tt> element</h4>

<p>This element surrounds a group of elements with the same namespace and code prefix.</p>
<p>
It has two attributes that must be specified: <tt>prefix</tt> and <tt>ns</tt></p>
<dl>
 <dt><tt>prefix</tt></dt>
 <dd>
  Contains the prefix that will precede the element type code. The value will be uppercased when
  used. <b>Example</b>: <tt>prefix="HT"</tt> will yield a code name like <tt>HTE_MYELEMENT</tt>.
 </dd>
 <dt><tt>ns</tt></dt>
 <dd>
  Contains a constant describing the XML namespace that the element will be used in.  This is used
  for differentiating between the case flattened or original string. The value for this attribute is
  the same as in the <tt>Markup::Ns</tt> enum found in <tt>modules/logdoc/markup.h</tt>.
 </dd>
</dl>
<p>It can contain any number of <tt><a href="#elm-elm">elm</a></tt> elements.</p>

<h4 id="elm-attributes">The <tt>attributes</tt> element</h4>

<p>This element surrounds a group of attributes with the same namespace and code prefix.</p>
<p>It has two attributes that must be specified: <tt>prefix</tt> and <tt>ns</tt></p>
<dl>
 <dt><tt>prefix</tt></dt>
 <dd>
  Contains the prefix that will precede the attribute type code. The value will be uppercased when
  used. <b>Example</b>: <tt>prefix="H"</tt> will yield a code name like <tt>HA_MYATTRIBUTE</tt>.
 </dd>
 <dt><tt>ns</tt></dt>
 <dd>
  Contains a constant describing the XML namespace that the attribute will be used in.  This is used
  for differentiating between the case flattened or original string. The value for this attribute is
  the same as in the <tt>Markup::Ns</tt> enum found in <tt>modules/logdoc/markup.h</tt>.
 </dd>
</dl>
<p>It can contain any number of <tt><a href="#elm-attr">attr</a></tt> elements.</p>

<h4 id="elm-elm">The <tt>elm</tt> element</h4>

<p>This element describes an entry in the element name and code tables.</p>
<p>It has two attributes which of at least one must be specified: <tt>str</tt> and <tt>name</tt></p>
<dl>
 <dt>str</dt>
 <dd>Case sensitive. This attribute is used to specify a normal element that has a string
 representation. <b>Example:</b> the "a" element in HTML.</dd>

 <dt>name</dt>
 <dd>This attribute is used to specify an element that has no normal string representation, but
 can be inserted into the tree as a placeholder or elements that behave in a special way like a
 processing instruction or doctype. <b>Example:</b> The SVGE_BASE_SHADOWROOT element.</dd>
</dl>
<p>This element cannot have any content.</p>

<h4 id="elm-attr">The <tt>attr</tt> element</h4>

<p>This element describes an entry in the attribute name and code tables.</p>
<p>It has two attributes that must be specified: <tt>prefix</tt> and <tt>ns</tt></p>
<dl>
 <dt>str</dt>
 <dd>Case sensitive. This attribute is used to specify a normal attribute that has a string
 representation. <b>Example:</b> the "viewBox" attribute in SVG.</dd>

 <dt>name</dt>
 <dd>This attribute is used to specify an attribute that has no normal string representation, but
 can be set on an element as a placeholder or attribute that behave in a special way like holding
 both the name and value of an unknown attribute. <b>Example:</b> The ANIMATED_MARKER_PROP
 attribute.</dd>
</dl>
<p>This element cannot have any content.</p>

<h3>Example:</h3>
<code>&lt;?xml version="1.0"?&gt;
&lt;markup&gt;
 &lt;elements prefix="HT" ns="HTML"&gt;
  &lt;elm name="MY_SPECIAL_ELM"/&gt;
  &lt;elm str="div"/&gt;
 &lt;/elements&gt;
 &lt;elements prefix="SVG" ns="SVG"&gt;
  &lt;elm str="niceElm"/&gt;
 &lt;/elements&gt;
 &lt;attributes prefix="W" ns="WML"&gt;
  &lt;attr name="MY_SPECIAL_ATTR"/&gt;
  &lt;attr str="niceAttr"/&gt;
 &lt;/attributes&gt;
&lt;/markup&gt;
</code>
That file will generate the following data (in different tables, this is just a short-hand notation):
<code>elements:
 {Markup::HTE_DIV, "div", "DIV"}
 {Markup::SVGE_NICEELM, ns == Markup::SVG ? "niceElm" : "niceelm", "NICEELM"}
 {Markup::HTE_MY_SPECIAL_ELM, "", "", ""}
attributes:
 {Markup::WA_NICEATTR, ns == Markup::WML ? "niceAttr" : "niceattr", "NICEATTR"}
 {Markup::WA_MY_SPECIAL_ATTR, "", "", ""}
</code>
</div>

<div id="flattening" class="section">
<h2>Case flattening</h2>

<p>The HTML 5 specification says that, during tokenization, all element and attribute names should
  be treated as lowercase. That means that if a document contains <tt>&lt;A
  hRef="fisk"&gt;Fish&lt;/a&gt;</tt> the resulting element would be named <tt>a</tt>, have an
  attribute called <tt>href</tt> and the end tag would match the start tag.</p>

<p>In order to be able to get SVG and MathML elements with mixed case to work, there is an
  adjustment process for elements in foreign content. If the element or attribute names match a
  certain list of names, it will be replaced with the correct case before the element is
  created.</p>

<div class="section">
 <b>Example:</b>
 <code>&lt;svg&gt;&lt;radialGradient gradientUnits="foo"&gt;&lt;/svg&gt;</code>
 would be tokenized to:
 <code>| svg
|   radialgradient
|     gradientunits = "foo"</code>
 and when inserted into the tree, the names would be adjusted to (extra elements inserted
 automatically by the tree building process):
 <code>| html
|   head
|   body
|     svg
|       radialGradient
|         gradientUnits = "foo"</code>
</div>

<p>If the mixed case names are used on an element with another namespace than it was meant for on
  the other hand (like when SVG elements are used in a HTML context), the names should not be
  adjusted.</p>

<div class="section">
 <b>Example:</b>
 <code>&lt;html&gt;&lt;radialGradient gradientUnits="foo"&gt;&lt;/html&gt;</code>
 would be tokenized to:
 <code>| html
|   radialgradient
|     gradientunits</code>
 and when inserted into the tree, the element is in the HTML namespace and no adjustment will take place and the resulting element will be (extra elements inserted automatically by the tree building process):
 <code>| html
|   head
|   body
|     radialgradient
|       gradientunits = "foo"</code>
 and it will of course not work as an SVG element anymore.
</div>

<p>For this reason the name tables have both a lowercase entry and a mixed case entry for the names
  that are not the same when lowercased. <b>Special case:</b> The <tt>textarea</tt> element exists
  in both HTML and SVG, but the element is called <tt>textArea</tt> in SVG. This is treated as a
  special case in the <tt>markup.py</tt> script where the HTML entry in <tt>module.markup</tt> is
  set to <tt>textArea</tt> as well, but the real representation will be <tt>textarea</tt> in
  HTML.</p>

<p>Some DOM EcmaScript functions, like Element.tagName, are specified to return the uppercased
  version of the element or attribute names, so we have a table with the uppercased names as well to
  avoid having to do the transformation on-the-fly.</p>
</div>

<hr/>
<span style="font-size: 10px">2011-08-30, stighal</span>
</body>
</html>
