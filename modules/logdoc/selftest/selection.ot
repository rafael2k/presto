/* -*- Mode: c++; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */

group "logdoc.selection";
require init;

include "modules/logdoc/selection.h";
include "modules/logdoc/selectionpoint.h";
include "modules/logdoc/htm_elm.h";
include "modules/doc/html_doc.h";
include "modules/doc/frm_doc.h";

language C++;

html
{
	//! <body>abc</body>
}
test("SetElementsIsInSelection - single element")
{
	HTML_Element* body = find_element("body");
	SelectionBoundaryPoint start(body, 0);
	SelectionBoundaryPoint stop(body, 1);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(body->FirstChild()->IsInSelection());
}

html
{
	//! <body><span>abc</span><p>def</p></body>
}
test("SetElementsIsInSelection - multiple elements")
{
	HTML_Element* body = find_element("body");
	HTML_Element* span = find_element("span");
	HTML_Element* p = find_element("p");
	SelectionBoundaryPoint start(body, 0);
	SelectionBoundaryPoint stop(body, 2);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(span->IsInSelection());
	verify(span->FirstChild()->IsInSelection());
	verify(p->IsInSelection());
	verify(p->FirstChild()->IsInSelection());
}

html
{
	//! <body><span>abc</span><div>def</div><p>ghi</p></body>
}
test("SetElementsIsInSelection - selection starts and ends in the same element")
{
	HTML_Element* body = find_element("body");
	HTML_Element* span = find_element("span");
	HTML_Element* p = find_element("p");
	HTML_Element* div = find_element("div");
	SelectionBoundaryPoint start(body, 1);
	SelectionBoundaryPoint stop(body, 2);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(!span->IsInSelection());
	verify(!span->FirstChild()->IsInSelection());
	verify(div->IsInSelection());
	verify(div->FirstChild()->IsInSelection());
	verify(!p->IsInSelection());
	verify(!p->FirstChild()->IsInSelection());
}

html
{
	//! <body><span>abc</span>def<p>ghi</p></body>
}
test("SetElementsIsInSelection - selection starts and ends in the same text element")
{
	HTML_Element* body = find_element("body");
	HTML_Element* body_text = body->FirstChild()->Suc();
	HTML_Element* span = find_element("span");
	HTML_Element* p = find_element("p");

	verify(body_text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(body_text, 1);
	SelectionBoundaryPoint stop(body_text, 2);
	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(!span->IsInSelection());
	verify(!span->FirstChild()->IsInSelection());
	verify(body_text->IsInSelection());
	verify(!p->IsInSelection());
	verify(!p->FirstChild()->IsInSelection());
}

html
{
	//! <body><span>abc</span><p>def</p>
}
test("SetElementsIsInSelection - start selection after the last child")
{
	HTML_Element* span = find_element("span");
	HTML_Element* p = find_element("p");
	SelectionBoundaryPoint start(span, 1);
	SelectionBoundaryPoint stop(p, 0);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!span->IsInSelection());
	verify(!span->FirstChild()->IsInSelection());
	verify(p->IsInSelection());
	verify(!p->FirstChild()->IsInSelection());
}

html
{
	//! <body><span>abc</span><p>def</p>
}
test("SetElementsIsInSelection - start selection before the first child")
{
	HTML_Element* span = find_element("span");
	HTML_Element* p = find_element("p");
	SelectionBoundaryPoint start(span, 0);
	SelectionBoundaryPoint stop(p, 0);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!span->IsInSelection());
	verify(span->FirstChild()->IsInSelection());
	verify(p->IsInSelection());
	verify(!p->FirstChild()->IsInSelection());
}

html
{
	//! <body><span>abc</span><p>def</p><h1></h1>
}
test("SetElementsIsInSelection - end selection after the last child")
{
	HTML_Element* span = find_element("span");
	HTML_Element* p = find_element("p");
	HTML_Element* h1 = find_element("h1");
	SelectionBoundaryPoint start(span, 0);
	SelectionBoundaryPoint stop(p, 1);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!span->IsInSelection());
	verify(span->FirstChild()->IsInSelection());
	verify(p->IsInSelection());
	verify(p->FirstChild()->IsInSelection());
	verify(!h1->IsInSelection());
}

html
{
	"<body><span><p></p></span></body>" // No newline at the end.
}
test("SetElementIsInSelection - end selection at the last element in the tree")
{
	HTML_Element* body = find_element("body");
	HTML_Element* p = find_element("p");
	SelectionBoundaryPoint start(body, 0);
	SelectionBoundaryPoint stop(p, 0);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(p->IsInSelection());
}

html
{
	//! <body><span>abc</span><p></p></body>
}
test("SetElementsIsInSelection - don't unselect first text element")
{
	HTML_Element* body = find_element("body");
	HTML_Element* span = find_element("span");
	HTML_Element* p = find_element("p");
	HTML_Element* text = span->FirstChild();
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint body_start(body, 0);
	SelectionBoundaryPoint body_stop(body, 2);

	TextSelection::SetElementsIsInSelection(body_start, body_stop, TRUE);

	verify(span->IsInSelection());
	verify(text->IsInSelection());
	verify(p->IsInSelection());

	SelectionBoundaryPoint unselect_start(text, 2);
	TextSelection::SetElementsIsInSelection(unselect_start, body_stop, FALSE, TRUE, FALSE);

	verify(span->IsInSelection());
	verify(text->IsInSelection());
	verify(!p->IsInSelection());
}

html
{
	//! <body><span>abc</span><p></p></body>
}
test("SetElementsIsInSelection - don't unselect last text element")
{
	HTML_Element* body = find_element("body");
	HTML_Element* span = find_element("span");
	HTML_Element* p = find_element("p");
	HTML_Element* text = span->FirstChild();
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint body_start(body, 0);
	SelectionBoundaryPoint body_stop(body, 2);

	TextSelection::SetElementsIsInSelection(body_start, body_stop, TRUE);

	verify(span->IsInSelection());
	verify(text->IsInSelection());
	verify(p->IsInSelection());

	SelectionBoundaryPoint unselect_stop(text, 2);
	TextSelection::SetElementsIsInSelection(body_start, unselect_stop, FALSE, FALSE, TRUE);

	verify(!span->IsInSelection());
	verify(text->IsInSelection());
	verify(p->IsInSelection());
}

html
{
	//! <body><div>abc</div></body>
}
test("SetElementsIsInSelection - empty selection")
{
	HTML_Element* div = find_element("div");
	HTML_Element* text = div->FirstChild();
	verify(text->Type() == Markup::HTE_TEXT);
	SelectionBoundaryPoint start(div, 0);
	SelectionBoundaryPoint stop(div, 0);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!div->IsInSelection());
	verify(!text->IsInSelection());
}

html
{
	//! <body><div><br></div></body>
}
test("SetElementsIsInSelection - selection with no elements")
{
	HTML_Element* div = find_element("div");
	HTML_Element* br = find_element("br");
	SelectionBoundaryPoint start(br, 0);
	SelectionBoundaryPoint stop(div, 1);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!div->IsInSelection());
	verify(!br->IsInSelection());
}

html
{
	//! <body><span>abc</span><p>def</p>
}
test("SetElementsIsInSelection - start selection inside text")
{
	HTML_Element* span = find_element("span");
	HTML_Element* text = span->FirstChild();
	HTML_Element* p = find_element("p");
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint stop(p, 0);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!span->IsInSelection());
	verify(text->IsInSelection());
	verify(p->IsInSelection());
	verify(!p->FirstChild()->IsInSelection());
}

html
{
	//! <body><p>def</p><h1></h1>
}
test("SetElementsIsInSelection - end selection inside text")
{
	HTML_Element* body = find_element("body");
	HTML_Element* p = find_element("p");
	HTML_Element* text = p->FirstChild();
	HTML_Element* h1 = find_element("h1");
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(body, 0);
	SelectionBoundaryPoint stop(text, 2);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(p->IsInSelection());
	verify(text->IsInSelection());
	verify(!h1->IsInSelection());
}

html
{
	//! <body><br></body>
}
test("SetElementsIsInSelection - select a single <br>")
{
	HTML_Element* body = find_element("body");
	HTML_Element* br = find_element("br");
	SelectionBoundaryPoint start(body, 0);
	SelectionBoundaryPoint stop(body, 1);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(br->IsInSelection());
}

html
{
	//! <body><br>abc</body>
}
test("SetElementsIsInSelection - selection starting at a <br>")
{
	HTML_Element* body = find_element("body");
	HTML_Element* br = find_element("br");
	HTML_Element* text = br->Suc();
	if (text->Type() == Markup::HTE_TEXTGROUP)
		text = text->FirstChild();

	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(br, 0);
	SelectionBoundaryPoint stop(text, 3);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(!br->IsInSelection());
	verify(text->IsInSelection());
}

html
{
	//! <body>abc<br></body>
}
test("SetElementsIsInSelection - selection ending at a <br>")
{
	HTML_Element* body = find_element("body");
	HTML_Element* br = find_element("br");
	HTML_Element* text = body->FirstChild();
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 0);
	SelectionBoundaryPoint stop(br, 0);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(br->IsInSelection());
	verify(text->IsInSelection());
}

html
{
	//! <style>div:after { content: "def"; }</style>
	//! <body>
	//! <div>abc</div>
	//! </body>
}
test("SetElementsIsInSelection - selection ends with actual element")
{
	HTML_Element* div = find_element("div");
	SelectionBoundaryPoint start(div, 0);
	SelectionBoundaryPoint stop(div, 1);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	HTML_Element* text_in_div = div->FirstChild();
	verify(text_in_div != NULL);
	HTML_Element* generated_content_in_div = text_in_div->Suc();
	verify(generated_content_in_div != NULL);

	verify(!div->IsInSelection());
	verify(text_in_div->IsInSelection());
	verify(!generated_content_in_div->IsInSelection());
}

html
{
	//! <body><div><p>abc<span>def</span></p></div></body>
}
test("SetElementsIsInSelection - selection starts in ancestor of its end, several levels up")
{
	HTML_Element* body = find_element("body");
	HTML_Element* div = find_element("div");
	HTML_Element* p = find_element("p");
	HTML_Element* span = find_element("span");
	HTML_Element* text = p->FirstChild();
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(body, 0);
	SelectionBoundaryPoint stop(text, 1);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(div->IsInSelection());
	verify(p->IsInSelection());
	verify(text->IsInSelection());
	verify(!span->IsInSelection());
}

html
{
	//! <body><div><p>abc</p></div><span>def</span></body>
}
test("SetElementsIsInSelection - selection ends in ancestor of its start, several levels up")
{
	HTML_Element* body = find_element("body");
	HTML_Element* div = find_element("div");
	HTML_Element* p = find_element("p");
	HTML_Element* span = find_element("span");
	HTML_Element* text = p->FirstChild();
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint stop(body, 2);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!body->IsInSelection());
	verify(!div->IsInSelection());
	verify(!p->IsInSelection());
	verify(text->IsInSelection());
	verify(span->IsInSelection());
}

html
{
	//! <body><div><p><span>abc</span></p></div></body>
}
test("SetElementsIsInSelection - single element selection ends in ancestor of its start, several levels up")
{
	HTML_Element* div = find_element("div");
	HTML_Element* p = find_element("p");
	HTML_Element* span = find_element("span");
	HTML_Element* text = span->FirstChild();
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 2);
	SelectionBoundaryPoint stop(div, 1);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!div->IsInSelection());
	verify(!p->IsInSelection());
	verify(!span->IsInSelection());
	verify(text->IsInSelection());
}

html
{
	//! <body><div><p><span><br></span></p></div></body>
}
test("SetElementsIsInSelection - selection with no elements ends in ancestor of its start, several levels up")
{
	HTML_Element* div = find_element("div");
	HTML_Element* p = find_element("p");
	HTML_Element* span = find_element("span");
	HTML_Element* br = find_element("br");

	SelectionBoundaryPoint start(br, 0);
	SelectionBoundaryPoint stop(div, 1);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!div->IsInSelection());
	verify(!p->IsInSelection());
	verify(!span->IsInSelection());
	verify(!br->IsInSelection());
}

html
{
	//! <body><div><span></span><br></div></body>
}
test("SetElementsIsInSelection - selection with no elements ends on a <br>")
{
	HTML_Element* div = find_element("div");
	HTML_Element* span = find_element("span");
	HTML_Element* br = find_element("br");

	SelectionBoundaryPoint start(span, 0);
	SelectionBoundaryPoint stop(br, 0);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!div->IsInSelection());
	verify(!span->IsInSelection());
	verify(br->IsInSelection());
}

html
{
	//! <style>div:after { content: "def"; }</style>
	//! <body>
	//! <div><br></div>
	//! </body>
}
test("SetElementsIsInSelection - empty selection just before a non-actual element")
{
	HTML_Element* div = find_element("div");

	HTML_Element* br = find_element("br");
	HTML_Element* generated_content_in_div = br->Suc();
	verify(generated_content_in_div != NULL);

	SelectionBoundaryPoint start(br, 0);
	SelectionBoundaryPoint stop(div, 1);

	TextSelection::SetElementsIsInSelection(start, stop, TRUE);

	verify(!div->IsInSelection());
	verify(!br->IsInSelection());
	verify(!generated_content_in_div->IsInSelection());
}

html
{
	"<html>"
}

test("Constructor")
{
	TextSelection selection;
	verify(selection.IsEmpty());
}

html
{
	"<body><span></span><span></span></body>"
}

test("TextSelection - sibling elements removed #1")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* body = find_element("body");
	SelectionBoundaryPoint start(body, 0);
	SelectionBoundaryPoint end(body, 1);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	HTML_Element* second_span = find_element("span", 2);
	verify(second_span);
	second_span->Remove(state.doc);
	if (second_span->Clean(state.doc))
		second_span->Free(state.doc);
	second_span = NULL;

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	HTML_Element* first_span = find_element("span", 1);
	verify(first_span);
	first_span->Remove(state.doc);
	if (first_span->Clean(state.doc))
		first_span->Free(state.doc);
	first_span = NULL;

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(!(selection->GetEndSelectionPoint() == end));
	verify(selection->GetEndSelectionPoint().GetElement() == body);
	verify(selection->GetEndSelectionPoint().GetOffset() == 0);
}

html
{
	"<body><span></span><span></span></body>"
}

test("TextSelection - sibling elements removed #2")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* body = find_element("body");
	SelectionBoundaryPoint start(body, 1);
	SelectionBoundaryPoint end(body, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	HTML_Element* second_span = find_element("span", 2);
	verify(second_span);
	second_span->Remove(state.doc);
	if (second_span->Clean(state.doc))
		second_span->Free(state.doc);
	second_span = NULL;

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(!(selection->GetEndSelectionPoint() == end));
	verify(selection->GetEndSelectionPoint().GetElement() == body);
	verify(selection->GetEndSelectionPoint().GetOffset() == 1);

	HTML_Element* first_span = find_element("span", 1);
	verify(first_span);
	first_span->Remove(state.doc);
	if (first_span->Clean(state.doc))
		first_span->Free(state.doc);
	first_span = NULL;

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(!(selection->GetStartSelectionPoint() == start));
	verify(!(selection->GetEndSelectionPoint() == end));
	verify(selection->GetStartSelectionPoint().GetElement() == body);
	verify(selection->GetStartSelectionPoint().GetOffset() == 0);
	verify(selection->GetEndSelectionPoint().GetElement() == body);
	verify(selection->GetEndSelectionPoint().GetOffset() == 0);
}

html
{
	"<body><span></span><span></span></body>"
}

test("TextSelection - sibling elements removed #3")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* body = find_element("body");
	SelectionBoundaryPoint start(body, 1);
	SelectionBoundaryPoint end(body, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	HTML_Element* first_span = find_element("span", 1);
	verify(first_span);
	HTML_Element* second_span = find_element("span", 2);
	verify(second_span);

	first_span->Remove(state.doc);
	if (first_span->Clean(state.doc))
		first_span->Free(state.doc);
	first_span = NULL;

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(!(selection->GetStartSelectionPoint() == start));
	verify(!(selection->GetEndSelectionPoint() == end));
	verify(selection->GetStartSelectionPoint().GetElement() == body);
	verify(selection->GetStartSelectionPoint().GetOffset() == 0);
	verify(selection->GetEndSelectionPoint().GetElement() == body);
	verify(selection->GetEndSelectionPoint().GetOffset() == 1);

	second_span->Remove(state.doc);
	if (second_span->Clean(state.doc))
		second_span->Free(state.doc);
	second_span = NULL;

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(!(selection->GetStartSelectionPoint() == start));
	verify(!(selection->GetEndSelectionPoint() == end));
	verify(selection->GetStartSelectionPoint().GetElement() == body);
	verify(selection->GetStartSelectionPoint().GetOffset() == 0);
	verify(selection->GetEndSelectionPoint().GetElement() == body);
	verify(selection->GetEndSelectionPoint().GetOffset() == 0);
}

html
{
	"<body><div><span></span><span></span></div><span></span></body>"
}

test("TextSelection - parent element removed #1")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* body = find_element("body");
	verify(body);
	HTML_Element* div = find_element("div");
	verify(div);
	SelectionBoundaryPoint start(div, 1);
	SelectionBoundaryPoint end(body, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	HTML_Element* first_span = find_element("span", 1);
	verify(first_span);
	HTML_Element* second_span = find_element("span", 2);
	verify(second_span);
	HTML_Element* third_span = find_element("span", 3);
	verify(third_span);

	div->Remove(state.doc);
	if (div->Clean(state.doc))
		div->Free(state.doc);
	div = first_span = second_span = NULL;

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(!(selection->GetStartSelectionPoint() == start));
	verify(!(selection->GetEndSelectionPoint() == end));
	verify(selection->GetEndSelectionPoint().GetElement() == body);
	verify(selection->GetEndSelectionPoint().GetOffset() == 1);
	verify(selection->GetStartSelectionPoint().GetElement() == body);
	verify(selection->GetStartSelectionPoint().GetOffset() == 0);
}

html
{
	"<body><span></span><span></span></body>"
}

test("TextSelection - sibling elements inserted #1")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* body = find_element("body");
	SelectionBoundaryPoint start(body, 1);
	SelectionBoundaryPoint end(body, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	HTML_Element* first_span = find_element("span", 1);
	verify(first_span);
	HTML_Element* second_span = find_element("span", 2);
	verify(second_span);

	OpAutoPtr<HTML_Element> new_span(OP_NEW(HTML_Element, ()));
	verify(new_span.get());
	verify_success(new_span->Construct(state.doc->GetHLDocProfile(),
									   NS_IDX_DEFAULT,
									   HE_SPAN,
									   NULL));

	new_span->UnderSafe(state.doc, body);
	new_span.release();

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);
	verify(selection->GetStartSelectionPoint().GetElement() == body);
	verify(selection->GetStartSelectionPoint().GetOffset() == 1);
	verify(selection->GetEndSelectionPoint().GetElement() == body);
	verify(selection->GetEndSelectionPoint().GetOffset() == 2);
}

test("TextSelection - sibling elements inserted #2")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* body = find_element("body");
	SelectionBoundaryPoint start(body, 1);
	SelectionBoundaryPoint end(body, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	HTML_Element* first_span = find_element("span", 1);
	verify(first_span);
	HTML_Element* second_span = find_element("span", 2);
	verify(second_span);

	OpAutoPtr<HTML_Element> new_span(OP_NEW(HTML_Element, ()));
	verify(new_span.get());
	verify_success(new_span->Construct(state.doc->GetHLDocProfile(),
									   NS_IDX_DEFAULT,
									   HE_SPAN,
									   NULL));

	new_span->PrecedeSafe(state.doc, second_span);
	new_span.release();

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(!(selection->GetEndSelectionPoint() == end));
	verify(selection->GetStartSelectionPoint().GetElement() == body);
	verify(selection->GetStartSelectionPoint().GetOffset() == 1);
	verify(selection->GetEndSelectionPoint().GetElement() == body);
	verify(selection->GetEndSelectionPoint().GetOffset() == 3);
}

test("TextSelection - sibling elements inserted #3")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* body = find_element("body");
	SelectionBoundaryPoint start(body, 1);
	SelectionBoundaryPoint end(body, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	HTML_Element* first_span = find_element("span", 1);
	verify(first_span);
	HTML_Element* second_span = find_element("span", 2);
	verify(second_span);

	OpAutoPtr<HTML_Element> new_span(OP_NEW(HTML_Element, ()));
	verify(new_span.get());
	verify_success(new_span->Construct(state.doc->GetHLDocProfile(),
									   NS_IDX_DEFAULT,
									   HE_SPAN,
									   NULL));

	new_span->PrecedeSafe(state.doc, first_span);
	new_span.release();

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(!(selection->GetStartSelectionPoint() == start));
	verify(!(selection->GetEndSelectionPoint() == end));
	verify(selection->GetStartSelectionPoint().GetElement() == body);
	verify(selection->GetStartSelectionPoint().GetOffset() == 2);
	verify(selection->GetEndSelectionPoint().GetElement() == body);
	verify(selection->GetEndSelectionPoint().GetOffset() == 3);
}

html
{
	"<body><div>ABC</div></body>"
}

test("TextSelection - textdata changed #1")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("ABC"), 3);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("AB"), 2);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("A"), 1);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(!(selection->GetEndSelectionPoint() == end));
	verify(selection->GetEndSelectionPoint().GetElement() == text);
	verify(selection->GetEndSelectionPoint().GetOffset() == 1);

	text->SetText(state.doc, UNI_L(""), 0);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(!(selection->GetStartSelectionPoint() == start));
	verify(!(selection->GetEndSelectionPoint() == end));
	verify(selection->GetStartSelectionPoint().GetElement() == text);
	verify(selection->GetStartSelectionPoint().GetOffset() == 0);
	verify(selection->GetEndSelectionPoint().GetElement() == text);
	verify(selection->GetEndSelectionPoint().GetOffset() == 0);
}

html
{
	"<body>ABC</body>D"
}

test("TextSelection - textdata changed #2")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* body = find_element("body");
	verify(body);
	HTML_Element* text = body->FirstChildActual();
	verify(text);
	HTML_Element* text_node = text;
	if (text->Type() == Markup::HTE_TEXTGROUP)
	{
		text = text->FirstChild();
		verify(text);
	}
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text_node->SetText(state.doc, UNI_L("ABC"), 3);
	text = NULL; // Most likely no longer a valid pointer.

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement()->Type() == Markup::HTE_TEXT);
	verify(selection->GetStartSelectionPoint().GetOffset() == 1);
	verify(selection->GetEndSelectionPoint().GetElement()->Type() == Markup::HTE_TEXT);
	verify(selection->GetEndSelectionPoint().GetOffset() == 2);

	text_node->SetText(state.doc, UNI_L("AB"), 2);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement()->Type() == Markup::HTE_TEXT);
	verify(selection->GetStartSelectionPoint().GetOffset() == 1);
	verify(selection->GetEndSelectionPoint().GetElement()->Type() == Markup::HTE_TEXT);
	verify(selection->GetEndSelectionPoint().GetOffset() == 2);

	text_node->SetText(state.doc, UNI_L("A"), 1);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement()->Type() == Markup::HTE_TEXT);
	verify(selection->GetStartSelectionPoint().GetOffset() == 1);
	verify(selection->GetEndSelectionPoint().GetElement()->Type() == Markup::HTE_TEXT);
	verify(selection->GetEndSelectionPoint().GetOffset() == 1);

	// This will have an interesting and unique effect since it will create an empty HTE_TEXTGROUP.
	text_node->SetText(state.doc, UNI_L(""), 0);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement()->IsText());
	verify(selection->GetStartSelectionPoint().GetOffset() == 0);
	verify(selection->GetEndSelectionPoint().GetElement()->IsText());
	verify(selection->GetEndSelectionPoint().GetOffset() == 0);
}

html
{
	"<body><div>abc</div></body>"
}

test("TextSelection - textdata changed #3")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("BC"), 2, HTML_Element::MODIFICATION_DELETING, 0, 1);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement() == text);
	verify(selection->GetStartSelectionPoint().GetOffset() == 0);
	verify(selection->GetEndSelectionPoint().GetElement() == text);
	verify(selection->GetEndSelectionPoint().GetOffset() == 1);
}

html
{
	"<body><div>abc</div></body>"
}

test("TextSelection - textdata changed #4")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("C"), 1, HTML_Element::MODIFICATION_DELETING, 0, 2);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement() == text);
	verify(selection->GetStartSelectionPoint().GetOffset() == 0);
	verify(selection->GetEndSelectionPoint().GetElement() == text);
	verify(selection->GetEndSelectionPoint().GetOffset() == 0);
}

html
{
	"<body><div>abc</div></body>"
}

test("TextSelection - textdata changed #5")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("AC"), 2, HTML_Element::MODIFICATION_DELETING, 1, 1);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement() == text);
	verify(selection->GetStartSelectionPoint().GetOffset() == 1);
	verify(selection->GetEndSelectionPoint().GetElement() == text);
	verify(selection->GetEndSelectionPoint().GetOffset() == 1);
}

html
{
	"<body><div>abc</div></body>"
}

test("TextSelection - textdata changed #6")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("AB"), 2, HTML_Element::MODIFICATION_DELETING, 2, 1);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement() == text);
	verify(selection->GetStartSelectionPoint().GetOffset() == 1);
	verify(selection->GetEndSelectionPoint().GetElement() == text);
	verify(selection->GetEndSelectionPoint().GetOffset() == 2);
}

html
{
	"<body><div>abc</div></body>"
}

test("TextSelection - textdata changed #7")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("ABCD"), 4, HTML_Element::MODIFICATION_INSERTING, 3, 1);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement() == text);
	verify(selection->GetStartSelectionPoint().GetOffset() == 1);
	verify(selection->GetEndSelectionPoint().GetElement() == text);
	verify(selection->GetEndSelectionPoint().GetOffset() == 2);
}

html
{
	"<body><div>abc</div></body>"
}

test("TextSelection - textdata changed #8")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("ABDC"), 4, HTML_Element::MODIFICATION_INSERTING, 2, 1);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement() == text);
	verify(selection->GetStartSelectionPoint().GetOffset() == 1);
	verify(selection->GetEndSelectionPoint().GetElement() == text);
	verify(selection->GetEndSelectionPoint().GetOffset() == 2);
}

html
{
	"<body><div>abc</div></body>"
}

test("TextSelection - textdata changed #9")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("ADBC"), 4, HTML_Element::MODIFICATION_INSERTING, 1, 1);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement() == text);
	verify(selection->GetStartSelectionPoint().GetOffset() == 1);
	verify(selection->GetEndSelectionPoint().GetElement() == text);
	verify(selection->GetEndSelectionPoint().GetOffset() == 3);
}

html
{
	"<body><div>abc</div></body>"
}

test("TextSelection - textdata changed #10")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, UNI_L("DABC"), 4, HTML_Element::MODIFICATION_INSERTING, 0, 1);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement() == text);
	verify(selection->GetStartSelectionPoint().GetOffset() == 2);
	verify(selection->GetEndSelectionPoint().GetElement() == text);
	verify(selection->GetEndSelectionPoint().GetOffset() == 3);
}

html
{
	"<body><div>abc</div></body>"
}

test("TextSelection - textdata changed #11")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(text, 1);
	SelectionBoundaryPoint end(text, 2);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	// Force a Textgroup.
	TempBuffer long_text;
	while (long_text.Length() < 70000)
		verify_success(long_text.Append("1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"));

	int insert_length = long_text.Length();
	verify_success(long_text.Append("abc"));

	text->SetText(state.doc, long_text.GetStorage(), long_text.Length(), HTML_Element::MODIFICATION_INSERTING, 0, insert_length);
	verify(text->Type() == Markup::HTE_TEXTGROUP);

	HTML_Element* elm = text->FirstChild();
	verify(elm);
	verify(elm->Type() == Markup::HTE_TEXT);

	unsigned expected_start_offset = insert_length + 1;
	HTML_Element* expected_start_elm = elm;

	while (expected_start_elm && expected_start_elm->ContentLength() < expected_start_offset)
	{
		expected_start_offset -= elm->ContentLength();
		expected_start_elm = expected_start_elm->Suc();
	}

	verify(expected_start_elm);
	verify(expected_start_elm->Type() == Markup::HTE_TEXT);

	unsigned expected_end_offset = insert_length + 2;
	HTML_Element* expected_end_elm = elm;

	while (expected_end_elm && expected_end_elm->ContentLength() < expected_end_offset)
	{
		expected_end_offset -= elm->ContentLength();
		expected_end_elm = expected_end_elm->Suc();
	}

	verify(expected_end_elm);
	verify(expected_end_elm->Type() == Markup::HTE_TEXT);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement() == expected_start_elm);
	int expected_offset = static_cast<int>(expected_start_offset);
	verify(selection->GetStartSelectionPoint().GetOffset() == expected_offset);
	verify(selection->GetEndSelectionPoint().GetElement() == expected_end_elm);
	expected_offset = static_cast<int>(expected_end_offset);
	verify(selection->GetEndSelectionPoint().GetOffset() == expected_offset);
}

html
{
	"<body><div>abc</div></body>"
}

test("TextSelection - textdata changed #12")
require undefined HAS_NOTEXTSELECTION;
{
	HTML_Element* div = find_element("div");
	verify(div);
	HTML_Element* text = div->FirstChildActual();
	verify(text);
	verify(text->Type() == Markup::HTE_TEXT);

	// Force a Textgroup.
	TempBuffer long_text;
	while (long_text.Length() < 70000)
		verify_success(long_text.Append("1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"));

	int insert_length = long_text.Length();
	verify_success(long_text.Append("abc"));

	text->SetText(state.doc, long_text.GetStorage(), long_text.Length(), HTML_Element::MODIFICATION_INSERTING, 0, insert_length);
	verify(text->Type() == Markup::HTE_TEXTGROUP);

	HTML_Element* elm = text->FirstChild();
	verify(elm);
	verify(elm->Type() == Markup::HTE_TEXT);

	unsigned expected_start_offset = insert_length + 1;
	HTML_Element* expected_start_elm = elm;

	while (expected_start_elm && expected_start_elm->ContentLength() < expected_start_offset)
	{
		expected_start_offset -= elm->ContentLength();
		expected_start_elm = expected_start_elm->Suc();
	}

	verify(expected_start_elm);
	verify(expected_start_elm->Type() == Markup::HTE_TEXT);

	unsigned expected_end_offset = insert_length + 2;
	HTML_Element* expected_end_elm = elm;

	while (expected_end_elm && expected_end_elm->ContentLength() < expected_end_offset)
	{
		expected_end_offset -= elm->ContentLength();
		expected_end_elm = expected_end_elm->Suc();
	}

	verify(expected_end_elm);
	verify(expected_end_elm->Type() == Markup::HTE_TEXT);

	SelectionBoundaryPoint start(expected_start_elm, expected_start_offset);
	SelectionBoundaryPoint end(expected_end_elm, expected_end_offset);
	state.doc->GetHtmlDocument()->SetSelection(&start, &end);

	TextSelection* selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint() == start);
	verify(selection->GetEndSelectionPoint() == end);

	text->SetText(state.doc, long_text.GetStorage(), long_text.Length());

	verify(text->Type() == Markup::HTE_TEXTGROUP);

	elm = text->FirstChild();
	verify(elm);
	verify(elm->Type() == Markup::HTE_TEXT);

	expected_start_offset = insert_length + 1;
	expected_start_elm = elm;

	while (expected_start_elm && expected_start_elm->ContentLength() < expected_start_offset)
	{
		expected_start_offset -= elm->ContentLength();
		expected_start_elm = expected_start_elm->Suc();
	}

	verify(expected_start_elm);
	verify(expected_start_elm->Type() == Markup::HTE_TEXT);

	expected_end_offset = insert_length + 2;
	expected_end_elm = elm;

	while (expected_end_elm && expected_end_elm->ContentLength() < expected_end_offset)
	{
		expected_end_offset -= elm->ContentLength();
		expected_end_elm = expected_end_elm->Suc();
	}

	verify(expected_end_elm);
	verify(expected_end_elm->Type() == Markup::HTE_TEXT);

	selection = state.doc->GetTextSelection();
	verify(selection);
	verify(selection->GetStartSelectionPoint().GetElement() == expected_start_elm);
	int expected_offset = static_cast<int>(expected_start_offset);
	verify(selection->GetStartSelectionPoint().GetOffset() == expected_offset);
	verify(selection->GetEndSelectionPoint().GetElement() == expected_end_elm);
	expected_offset = static_cast<int>(expected_end_offset);
	verify(selection->GetEndSelectionPoint().GetOffset() == expected_offset);
}
