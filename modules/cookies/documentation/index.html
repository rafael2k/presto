<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
          "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<link rel=stylesheet href="../../coredoc/coredoc.css" />
<title>Module: Cookies</title>
</head>

<body>

<h1>Module: Cookies</h1>

<h2>About this module</h2>

The Cookie module parses received cookie headers, processes them, rejects invalid onces based on rules or filters, and stores the accepted ones for the specified period, and when requested generates a list of cookies currently stored for the domain of the URL for which the cookies are requested.

<p>
Supported protocols:
<p>
<UL>
<li> <a href="http://wp.netscape.com/newsref/std/cookie_spec.html">Netscape Cookies</a>
<li> <a href="http://www.ietf.org/rfc/rfc2965.txt">RFC 2965</a>
</UL>


<h2>Interface overview and API documentation</h2>

<p><a href="api/index.html">API documentation generated by
Doxygen</a> contains all necessary information for the external APIs.</p>

<p>The Cookie_Manager class is part of the URL_Manager class from the URL module, and is used as part of the API provided through the URL API and URL_Manager.</p>

<p>Cookie_Manager objects may be created as standalone objects used to administrate a separate cookie database, persistent or temporary, identified by a context ID stored in each URL_Rep object associated with the store. Management of these objects is done by the Cookie_Manager that is included in the URL_Manager class.</p>

<h3>Primary API</h3>

<dl>
<dt> g_url_api->GetCookiesL()
	<dd>This function is used to retrieve cookies for the specified URL
<dt>g_url_api->HandleSingleCookieL()
	<dd>This function is used by non-protocol callers to set cookies for the specified URL
<dt>g_url_manager->HandleCookiesL()
	<dd>This function is used by protocol callers to set cookies from headers for the specified URL.
</dl>

<h2>Implementation description</h2>

<p><a href="all/index.html">API documentation generated by
Doxygen</a> contains information about the internal organization of the module.</p>
<h3>Cookie_Manager</h3>

<p>The Cookie_Manager contains a database of all cookies, organized as a tree of domains, and for each domain there is a tree database organizing the cookies and the pathstructure for which cookies are set. This database is stored in the cookies4.dat file in a tree structure.</p>

<p>The cookies are processed either as a sequence of headers, provided by the URL module, or individual strings from the JavaScript document.cookie DOM object or HTML Meta tags.</p>

<p>When a cookies are received each individual header is broken up into individual name/value argument pairs by the formats module. Set-Cookie2 headers, which can set multiple cookies in a single header are initially broken up into the individual cookies before the name/value split.</p>

<p>After parsing, validation and preparation the cookies are inserted into a list of accepted cookies. This list is used to resolve duplicates. After all headers are processed the remaining cookies are passed on to be inserted into the database, optionally the user is asked first.</p>

<p>When cookies are retrieved for a given URL, a list of cookies are written to a temporary buffer, the selection of which are decided by the scheme, servername, port, and the path components of the request URL.</p>

<p>The filter rules used for cookies are maintained by the relevant ServerNames.</p>

<h3>Footprint</h3>

<p>The module is fairly small. </p>

<p>Various features can be enabled or disabled, either through feature defines or specific defines</p>

<h3>Dynamic memory use and OOM handling</h3>

<dl>
<dt>OOM policies
<dd><p>Most of the functions LEAVE in case of OOM</p>

<dt>Who handles OOM?
<dd>In the case of LEAVE functions the caller must TRAP the errors, and handle the OOM situations. In the case of the internal functions these usually aborts their operation with an error message, and a raised status flag, which must be handled either by the caller, or the document.

<dt>Flow
<dd><p>Part of the module is message callback based, and these functions are not able to report OOM situations directly to the documents or UI. In these cases the current operation will be terminated, and errormessages sent.</p>

<p> Much of the external API is based on direct calls. In many cases these are LEAVE bases, and callers must TRAP them and handle them appropriately.</p>

<dt>Heap memory usage
<dd>
<p> Cookies can consume up to 4 KB per cookie, but should usually average less than 300 bytes.<p>

<p>The maximum number of cookies range from 30 for some limited memory configuration, up to 300 for contexts and 65000 for desktop versions.</p>

<dt>Stack memory usage
<dd><p>Usually large objects are allocated. </p>

<p>In most cases stack consumption should be less than 300 bytes.</p>

<dt>Static memory usage
<dd><p>A couple of buffers in the Cookie manager (part of URL manager) will normally allocate 5-6KB. In additon to this, the object maintains all the stored cookies, which will range from less than 100 bytes to about 4KB</p>

<p>The maximum number of cookies range from 30 for some limited memory configuration, up to 300 for contexts and 65000 for desktop versions.</p>

<p>The allocated objects are deleted by URL_Manager or URL_API on exit</p>

<dt>Caching and freeing memory
<dd><p>The cookie databases can be destroyed by a call to g_url_api->ClearCookiesL() or g_url_api->PurgeData(). Calls to the latter can be restricted to session cookies (those that are not stored to disk) or delete all cookies.</p>

<dt>Freeing memory on exit
<dd>The destruction of the URL_Manager destroys the Cookie_Manager, and all temporary buffers, the stored cookies and all extra cookie contexts.

<dt>Temp buffers
<dd><p> The Cookie Manager maintains two temporary buffers that are used internally.</p>

<dt>Memory tuning
<dd>

<p>At present there are no opportunities to tune memory use.</p>

<dt>Improvements
<dd>

<p>Possible improvements</p>


</dl>
