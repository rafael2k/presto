group "Widgets";

include "modules/img/image.h";
include "modules/img/decoderfactorypng.h";
include "modules/widgets/OpWidget.h";
include "modules/widgets/OpButton.h";
include "modules/widgets/OpEdit.h";
include "modules/widgets/OpMultiEdit.h";
include "modules/widgets/OpListBox.h";
include "modules/widgets/OpDropDown.h";
include "modules/widgets/OpSlider.h";
include "modules/widgets/WidgetWindow.h";
include "modules/widgets/WidgetContainer.h";
include "modules/inputmanager/inputmanager.h";
include "modules/logdoc/htm_elm.h";
include "modules/forms/piforms.h";
include "modules/doc/frm_doc.h";
include "modules/dochand/win.h";
include "modules/dochand/fdelm.h";

// TODO: Add testcase for multiselectable listboxes as well.

require init;
require MDF_FREETYPE_SUPPORT;

global
{
	OpString test_path;
	int i;
	OpWidget *widget;
	void InsertText(OpWidget *widget, const uni_char* text)
	{
		if (widget->GetType() == OpTypedObject::WIDGET_TYPE_EDIT)
			((OpEdit*)widget)->InsertText(text);
		else
			((OpMultilineEdit*)widget)->InsertText(text);
	}
	OP_STATUS Paint()
	{
		VisualDevice* vd = state.doc->GetVisualDevice();

		int width = 1000;
		int height = 1000;
		OpBitmap* bitmap_to_paint;
		RETURN_IF_ERROR(OpBitmap::Create(&bitmap_to_paint, 10, 10, FALSE, FALSE, 0, 0, TRUE));

		OpPainter* painter = bitmap_to_paint->GetPainter();
		if (!painter)
		{
			OP_DELETE(bitmap_to_paint);
			return OpStatus::ERR;
		}

		painter->SetColor(0, 0, 0);
		painter->FillRect(OpRect(0, 0, width, height));

		CoreViewContainer* cview = vd->GetView()->GetContainer();
		cview->Paint(OpRect(0, 0, width, height), painter, 0, 0, TRUE);

		bitmap_to_paint->ReleasePainter();

		OP_DELETE(bitmap_to_paint);
		return OpStatus::OK;
	}
	OP_STATUS VerifyImage(const char* refimage, int width, int height)
	{
		VisualDevice* vd = state.doc->GetVisualDevice();

		OpBitmap* bitmap_to_paint;
		RETURN_IF_ERROR(OpBitmap::Create(&bitmap_to_paint, width, height, FALSE, FALSE, 0, 0, TRUE));

		OpPainter* painter = bitmap_to_paint->GetPainter();
		if (!painter)
		{
			OP_DELETE(bitmap_to_paint);
			return OpStatus::ERR;
		}

		CoreViewContainer* cview = vd->GetView()->GetContainer();
		cview->Paint(OpRect(0, 0, width, height), painter, 0, 0, TRUE);

		bitmap_to_paint->ReleasePainter();

		OP_STATUS status = DecoderFactoryPng::verify(refimage, bitmap_to_paint, height, 5, 0, FALSE);
		if (OpStatus::IsError(status))
		{
			OpString8 refimage_failed;
			refimage_failed.Set(refimage);
			refimage_failed.Insert(op_strlen(refimage) - 4, "_failed");
			DecoderFactoryPng::verify(refimage_failed.CStr(), bitmap_to_paint, height, 5, 0, TRUE);
		}

		OP_DELETE(bitmap_to_paint);

		return status;
	}
	int GetTextLength(OpWidget *widget)
	{
		OpString text;
		widget->GetText(text);
		return text.Length();
	}
}

table test_files(char *) filelist "selftest" name "*.png";
foreach (FILE) from test_files
{
	test("getpath_dummy")
	{
		test_path.Set(FILE);
		int i = test_path.Length() - 1;
		while (test_path[i] != '\\' && test_path[i] != '/')
			i--;
		test_path.Delete(i);
		test_path.Append(UNI_L("/"));
	}
}

test("Widgets constructs") language C++ /*leakcheck*/;
{
/*	WidgetWindow* window = OP_NEW(WidgetWindow, ());
	OP_STATUS status = window->Init(OpWindow::STYLE_DESKTOP);
	verify(status == OpStatus::OK);

	window->Show(TRUE, &OpRect(100, 100, 300, 300));

	OpButton* btn;
	status = OpButton::Construct(&btn);

	window->GetWidgetContainer()->GetRoot()->AddChild(btn);

	OP_DELETE(window);*/
}

test("OpListBox item leaktest") language C++ /*leakcheck*/;
{
	OpListBox* listbox;
	OpListBox::Construct(&listbox, FALSE);

	for(i = 0; i < 15; i++)
		listbox->AddItem(UNI_L("text1"), UNI_L("text2"));

	listbox->Delete();
}

test("OpDropDown optiongroups") language C++;
{
	INT32 got_index;
	OpDropDown* dropdown;
	OpDropDown::Construct(&dropdown, FALSE);

	dropdown->BeginGroup(UNI_L("grp"));
	dropdown->AddItem(UNI_L("item"), -1, &got_index);
	dropdown->EndGroup();

	verify(got_index == 0);
	verify(dropdown->GetSelectedItem() == 0);
	verify(dropdown->IsSelected(0));
	verify(dropdown->CountItems() == 1);

	dropdown->AddItem(UNI_L("item"), -1, &got_index);
	verify(got_index == 1);

	dropdown->AddItem(UNI_L("item"), 0, &got_index);
	verify(got_index == 0);
	verify(dropdown->GetSelectedItem() == 0);
	verify(dropdown->CountItems() == 3);

	dropdown->SelectItem(1, TRUE);
	verify(dropdown->GetSelectedItem() == 1);
	verify(dropdown->IsSelected(0) == FALSE);
	verify(dropdown->IsSelected(1) == TRUE);
	verify(dropdown->IsSelected(2) == FALSE);

	dropdown->Delete();
}

test("OpListBox select item test") language C++;
{
	OpListBox* listbox;
	OpListBox::Construct(&listbox, FALSE);

	verify(listbox->GetSelectedItem() == -1);

	for(i = 0; i < 3; i++)
		listbox->AddItem(UNI_L(""));

	verify(listbox->GetSelectedItem() == -1);

	listbox->SelectItem(1, TRUE);
	verify(listbox->GetSelectedItem() == 1);

	listbox->AddItem(UNI_L(""), 0);

	verify(listbox->GetSelectedItem() == 2);
	verify(listbox->IsSelected(0) == FALSE);
	verify(listbox->IsSelected(1) == FALSE);
	verify(listbox->IsSelected(2) == TRUE);
	verify(listbox->IsSelected(3) == FALSE);

	listbox->RemoveItem(0);
	verify(listbox->GetSelectedItem() == 1);
	verify(listbox->IsSelected(0) == FALSE);
	verify(listbox->IsSelected(1) == TRUE);
	verify(listbox->IsSelected(2) == FALSE);

	listbox->RemoveItem(1);
	verify(listbox->GetSelectedItem() == 1);
	verify(listbox->IsSelected(0) == FALSE);
	verify(listbox->IsSelected(1) == TRUE); // TRUE when it is a UI widget (common sense), FALSE when we have a form (standard)

	listbox->SelectItem(1, TRUE);
	listbox->RemoveItem(1);
	verify(listbox->GetSelectedItem() == 0);
	verify(listbox->IsSelected(0) == TRUE); // TRUE when it is a UI widget (common sense), FALSE when we have a form (standard)

	listbox->RemoveItem(0);
	verify(listbox->GetSelectedItem() == -1);

	listbox->Delete();
}

test("OpDropDown select item test") language C++;
{
	OpDropDown* dropdown;
	OpDropDown::Construct(&dropdown, FALSE);

	dropdown->AddItem(UNI_L(""));
	dropdown->AddItem(UNI_L(""));
	verify(dropdown->GetSelectedItem() == 0);
	verify(dropdown->IsSelected(0) == TRUE);
	verify(dropdown->IsSelected(1) == FALSE);

	dropdown->SelectItem(-1, TRUE);
	verify(dropdown->GetSelectedItem() == -1);
	verify(dropdown->IsSelected(0) == FALSE);
	verify(dropdown->IsSelected(1) == FALSE);

	dropdown->SelectItem(1, TRUE);
	verify(dropdown->GetSelectedItem() == 1);
	verify(dropdown->IsSelected(0) == FALSE);
	verify(dropdown->IsSelected(1) == TRUE);

	dropdown->AddItem(UNI_L(""), 0);
	verify(dropdown->GetSelectedItem() == 2);
	verify(dropdown->IsSelected(0) == FALSE);
	verify(dropdown->IsSelected(1) == FALSE);
	verify(dropdown->IsSelected(2) == TRUE);

	dropdown->RemoveItem(1);
	verify(dropdown->GetSelectedItem() == 1);
	verify(dropdown->IsSelected(0) == FALSE);
	verify(dropdown->IsSelected(1) == TRUE);

	dropdown->RemoveItem(1);
	verify(dropdown->GetSelectedItem() == 0);
	verify(dropdown->IsSelected(0) == TRUE);

	dropdown->RemoveItem(0);
	verify(dropdown->GetSelectedItem() == -1);

	dropdown->Delete();
}

html
{
	//! <body>
	//! <select size=10 multiple>
	//! <option>A
	//! <option disabled>B
	//! <option selected>C
	//! <option disabled selected>D
	//! <option>E
	//! </select>
	//! <select size=10>
	//! <option>A
	//! <option disabled>B
	//! <option selected>C
	//! <option selected>D
	//! <option>E
	//! </select>
	//! </body>
}

test("SelectSelectedStatus") language C++;
{
	HTML_Element* e;
	e = find_element("select", 1);
	verify(e && "OOM when fetching element");
	OpListBox *listbox1 = (OpListBox *) e->GetFormObject()->GetWidget();
	e = find_element("select", 2);
	verify(e && "OOM when fetching element");
	OpListBox *listbox2 = (OpListBox *) e->GetFormObject()->GetWidget();

	verify(listbox1->GetSelectedItem() == 3);
	verify(listbox1->IsSelected(0) == 0);
	verify(listbox1->IsSelected(1) == 0);
	verify(listbox1->IsSelected(2) == 1);
	verify(listbox1->IsSelected(3) == 1);
	verify(listbox1->IsSelected(4) == 0);

	verify(listbox2->GetSelectedItem() == 3);
	verify(listbox2->IsSelected(0) == 0);
	verify(listbox2->IsSelected(1) == 0);
	verify(listbox2->IsSelected(2) == 0);
	verify(listbox2->IsSelected(3) == 1);
	verify(listbox2->IsSelected(4) == 0);
}

test("SelectChangeFocusedItem") language C++;
{
	HTML_Element* e;
	e = find_element("select", 1);
	verify(e && "OOM when fetching element");
	OpListBox *listbox1 = (OpListBox *) e->GetFormObject()->GetWidget();
	e = find_element("select", 2);
	verify(e && "OOM when fetching element");
	OpListBox *listbox2 = (OpListBox *) e->GetFormObject()->GetWidget();

	OpInputAction previtem(OpInputAction::ACTION_PREVIOUS_ITEM);
	OpInputAction nextitem(OpInputAction::ACTION_NEXT_ITEM);

	verify(listbox1->ih.focused_item == 3);
	verify(listbox2->ih.focused_item == 3);

	listbox1->OnInputAction(&previtem);
	listbox1->OnInputAction(&previtem);
	// Should have jumped over the disabled item
	verify(listbox1->ih.focused_item == 0);
	listbox1->OnInputAction(&nextitem);
	listbox1->OnInputAction(&nextitem);
	verify(listbox1->ih.focused_item == 4);

	listbox2->OnInputAction(&previtem);
	listbox2->OnInputAction(&previtem);
	// Should have jumped over the disabled item
	verify(listbox2->ih.focused_item == 0);
	listbox2->OnInputAction(&nextitem);
	listbox2->OnInputAction(&nextitem);
	verify(listbox2->ih.focused_item == 3);
}

html
{
	//! <html>
	//! <style>textarea, input, select { border: 1px solid black; background-color: white; }</style>
	//! <script>
	//! function do_onload()
	//! {
	//! }
	//! </script>
	//! <body onload="do_onload()">
	//! <form action="dummy">
	//! <input type="radio" checked>
	//! <input type="checkbox" checked>
	//! <input type="file">
	//! <input type="button">
	//! <input type="pushbutton">
	//! <input type="reset">
	//! <input type="submit">
	//! <input type="text" value="text">
	//! <input type="password" value="text">
	//! <input type="url" value="http://www.opera.com">
	//! <input type="datetime" value="1970-01-01T05:00:00Z" min="1970-01-01T05:00:00Z" max="2000-01-01T05:00:00Z" step="60">
	//! <input type="date" value="1990-01-01" min="1970-01-01" max="2000-01-01" step="7">
	//! <input type="month" value="1990-03" min="1980-03" max="2000-03">
	//! <input type="number" value=".0">
	//! <input type="week" value="2006-W02" min="2005-W51" max="2006-W04">
	//! <input type="time" min="09:00" max="17:00" step="60">
	//! <input type="slider" value="100">
	//! <input type="email" value="emil@opera.com">
	//! <input type="range" step=".1">
	//! <textarea readonly>Some text in a textarea.
	//! Opera Software Opera Software Opera Software Opera Software Opera Software Opera Software.
	//!	a	tab
	//!	aa	tab
	//!	aaa	tab
	//! </textarea>
	//! <select size=1>
	//! <option>A
	//! <option>B
	//! </select>
	//! <select size=1>
	//! <optgroup>A Group
	//! <option>A
	//! <option>B
	//! </optgroup>
	//! </select>
	//! <select size=5>
	//! <option>A
	//! <option>B
	//! </select>
	//! <select size=5>
	//! <optgroup>A Group
	//! <option>A
	//! <option>B
	//! </optgroup>
	//! </select>
	//! </form>
	//! </body>
	//! </html>
}

test("AllWidgets") language C++;
{
	Paint();
	int i;

	// There's no good way to test popupmenus look & behaviour at the moment.
	// Just trig mousedown on all inputs so menus will at least be created and showed to see if they crash (better than nothing).
	HTML_Element* e;
	for(i = 0; i < 19; i++)
	{
		e = find_element("input", i + 1);
		verify(e && "OOM when fetching element");
		OpWidget *input = e->GetFormObject()->GetWidget();
		input->GenerateOnMouseDown(OpPoint(5, 5), MOUSE_BUTTON_1, 1);
		input->GenerateOnMouseMove(OpPoint(5, 5));
		input->GenerateOnMouseUp(OpPoint(5, 5), MOUSE_BUTTON_1, 1);
		input->GenerateOnMouseDown(OpPoint(input->GetBounds().width - 5, 5), MOUSE_BUTTON_1, 1);
		input->GenerateOnMouseMove(OpPoint(input->GetBounds().width - 5, 5));
		input->GenerateOnMouseUp(OpPoint(input->GetBounds().width - 5, 5), MOUSE_BUTTON_1, 1);
	}
	for(i = 0; i < 4; i++)
	{
		e = find_element("select", i + 1);
		verify(e && "OOM when fetching element");
		OpWidget *widget = e->GetFormObject()->GetWidget();
		widget->GenerateOnMouseDown(OpPoint(5, 5), MOUSE_BUTTON_1, 1);
		widget->GenerateOnMouseMove(OpPoint(5, 5));
		widget->GenerateOnMouseUp(OpPoint(5, 5), MOUSE_BUTTON_1, 1);
		widget->GenerateOnMouseDown(OpPoint(widget->GetBounds().width - 5, 5), MOUSE_BUTTON_1, 1);
		widget->GenerateOnMouseMove(OpPoint(widget->GetBounds().width - 5, 5));
		widget->GenerateOnMouseUp(OpPoint(widget->GetBounds().width - 5, 5), MOUSE_BUTTON_1, 1);
	}

	e = find_element("select", 1);
	verify(e && "OOM when fetching element");
	OpDropDown *dropdown = (OpDropDown *) e->GetFormObject()->GetWidget();
	dropdown->ShowMenu();
}

subtest UndoRedo()
require WIDGETS_UNDO_REDO_SUPPORT;
{
	OpString tmp;
	OpInputAction keypress(OpInputAction::ACTION_LOWLEVEL_KEY_PRESSED, OP_KEY_A, SHIFTKEY_SHIFT, FALSE, OpKey::LOCATION_STANDARD, OpInputAction::METHOD_KEYBOARD);
	keypress.SetActionKeyValue(UNI_L("A"));

	OpInputAction undo(OpInputAction::ACTION_UNDO);
	OpInputAction redo(OpInputAction::ACTION_REDO);
	OpInputAction deleteaction(OpInputAction::ACTION_DELETE);

	verify(!widget->HasReceivedUserInput());

	widget->OnInputAction(&keypress);
	widget->OnInputAction(&keypress);

	verify(widget->HasReceivedUserInput());
	// Basic test

	widget->GetText(tmp); verify_string(tmp, "AA");

	widget->OnInputAction(&undo);
	widget->GetText(tmp); verify_string(tmp, "");
	verify(widget->GetCaretOffset() == 0);

	widget->OnInputAction(&redo);
	widget->GetText(tmp); verify_string(tmp, "AA");
	verify(widget->GetCaretOffset() == 2);

	// Block test (no append)

	widget->SetText(UNI_L(""));
	widget->GetText(tmp); verify_string(tmp, "");

	verify(widget->HasReceivedUserInput());
	InsertText(widget, UNI_L("insert"));
	InsertText(widget, UNI_L("insert"));

	widget->OnInputAction(&undo);
	widget->GetText(tmp); verify_string(tmp, "insert");
	verify(widget->GetCaretOffset() == 6);

	widget->OnInputAction(&undo);
	widget->OnInputAction(&redo);
	widget->OnInputAction(&redo);
	widget->GetText(tmp); verify_string(tmp, "insertinsert");
	verify(widget->GetCaretOffset() == 12);

	// Different insert position

	widget->SetText(UNI_L("text"));
	widget->OnInputAction(&keypress);
	widget->OnInputAction(&keypress);

	widget->SetCaretOffset(0);
	widget->OnInputAction(&keypress);
	widget->OnInputAction(&keypress);
	widget->GetText(tmp); verify_string(tmp, "AAtextAA");

	widget->OnInputAction(&undo);
	widget->GetText(tmp); verify_string(tmp, "textAA");
	verify(widget->GetCaretOffset() == 0);

	widget->OnInputAction(&undo);
	widget->GetText(tmp); verify_string(tmp, "text");
	verify(widget->GetCaretOffset() == 4);

	widget->OnInputAction(&redo);
	verify(widget->GetCaretOffset() == 6);

	widget->OnInputAction(&redo);
	verify(widget->GetCaretOffset() == 2);

	widget->OnInputAction(&undo);
	widget->OnInputAction(&undo);

	// Remove selection
	widget->SelectAll();
	widget->OnInputAction(&deleteaction);
	widget->GetText(tmp); verify_string(tmp, "");
	widget->OnInputAction(&undo);
	widget->GetText(tmp); verify_string(tmp, "text");
	widget->OnInputAction(&redo);
	widget->GetText(tmp); verify_string(tmp, "");
	widget->OnInputAction(&undo);

	verify(widget->HasReceivedUserInput());
}

html
{
	//! <html><body>
	//! <input name="edit" type="text">
	//! <textarea name="multiedit"></textarea>
	//! </body></html>
}

test("Undo/Redo OpEdit") language C++;
require WIDGETS_UNDO_REDO_SUPPORT;
{
	HTML_Element* elm = find_element("input");
	verify(elm && "OOM when fetching element");
	widget = elm->GetFormObject()->GetWidget();
	verify(UndoRedo());
}

test("Undo/Redo OpMultilineEdit") language C++;
require WIDGETS_UNDO_REDO_SUPPORT;
{
	HTML_Element* elm = find_element("textarea");
	verify(elm && "OOM when fetching element");
	widget = elm->GetFormObject()->GetWidget();
	verify(UndoRedo());
}

html
{
	//! <html>
	//! <style>span, textarea { font-family: "Bitstream Vera Sans Mono", monospace; } </style>
	//! <body>
	//! <span>iiii</span>
	//! <span>wwww</span>
	//! <span>xxxx</span>
	//! <span>Blah</span>
	//! <textarea style="width: 10px;">iiii</textarea>
	//! <textarea style="width: 10px;">wwww</textarea>
	//! </body></html>
}

test("HasMonospaceFont") language C++;
{
	// Check that different characters have the same width in regular layout.
	RECT rect1, rect2, rect3, rect4;
	HTML_Element* e;
	e = find_element("span", 1);
	verify(e && "OOM when fetching element");
	verify(e->GetBoxRect(state.doc, BOUNDING_BOX, rect1) == TRUE);
	e = find_element("span", 2);
	verify(e && "OOM when fetching element");
	verify(e->GetBoxRect(state.doc, BOUNDING_BOX, rect2) == TRUE);
	e = find_element("span", 3);
	verify(e && "OOM when fetching element");
	verify(e->GetBoxRect(state.doc, BOUNDING_BOX, rect3) == TRUE);
	e = find_element("span", 4);
	verify(e && "OOM when fetching element");
	verify(e->GetBoxRect(state.doc, BOUNDING_BOX, rect4) == TRUE);
	verify(rect1.right - rect1.left == rect2.right - rect2.left);
	verify(rect2.right - rect2.left == rect3.right - rect3.left);
	verify(rect3.right - rect3.left == rect4.right - rect4.left);

	// Check that different characters have the same width in textarea (in case the monospace font for some reason didn't apply to forms).
	e = find_element("textarea", 1);
	verify(e && "OOM when fetching element");
	OpMultilineEdit *widget1 = (OpMultilineEdit *) e->GetFormObject()->GetWidget();
	e = find_element("textarea", 2);
	verify(e && "OOM when fetching element");
	OpMultilineEdit *widget2 = (OpMultilineEdit *) e->GetFormObject()->GetWidget();
	verify(widget1->GetContentWidth() == widget2->GetContentWidth());
}

html
{
	//! <html>
	//! <style>textarea { font-family: "Bitstream Vera Sans Mono", monospace; overflow-x: auto; overflow-y: scroll; }</style>
	//! <body>
	//! <textarea rows="5" cols="20">Blah blah blah spl&shy;it aaa aaaa.</textarea>
	//! <textarea rows="5" cols="20">Blah blah bl spl&shy;it aaa aaaa.</textarea>
	//! <textarea rows="5" cols="20">Blah blah blahaa spl&shy;it aaa aaaa.</textarea>
	//! </body></html>
}

test("Softhyphen.visible") language C++;
require success "HasMonospaceFont";
{
	OpString tmp;
	OpMultilineEdit *widget;

	HTML_Element* e;
	e = find_element("textarea", 1);
	verify(e && "OOM when fetching element");
	widget = (OpMultilineEdit *) e->GetFormObject()->GetWidget();
	widget->GetText(tmp, TRUE);

	const uni_char* wanted = UNI_L("Blah blah blah spl\xAD\r\nit aaa aaaa.");
	verify_string(tmp, wanted);
}

test("Softhyphen.beforebreak") language C++;
require success "HasMonospaceFont";
{
	OpString tmp;
	OpMultilineEdit *widget;

	HTML_Element* e = find_element("textarea", 2);
	widget = (OpMultilineEdit *) e->GetFormObject()->GetWidget();
	verify(e && "OOM when fetching element");
	widget->GetText(tmp, TRUE);

	const uni_char* wanted = UNI_L("Blah blah bl spl\xADit \r\naaa aaaa.");
	verify_string(tmp, wanted);
}

test("Softhyphen.afterbreak") language C++;
require success "HasMonospaceFont";
{
	OpString tmp;
	OpMultilineEdit *widget;

	HTML_Element* e = find_element("textarea", 3);
	verify(e && "OOM when fetching element");
	widget = (OpMultilineEdit *) e->GetFormObject()->GetWidget();
	widget->GetText(tmp, TRUE);

	const uni_char* wanted = UNI_L("Blah blah blahaa \r\nspl\xADit aaa aaaa.");
	verify_string(tmp, wanted);
}

html
{
	//! <html>
	//! <style>textarea { font-family: "Bitstream Vera Sans Mono", monospace; }</style>
	//! <body>
	//! <textarea rows="5" cols="20">Blah blah tjo blah blah blah blah blah blah hej blah blah blah blah.
	//! Blah blah blah blah blah trallala blah tjosan blah blah blah hej blah blah.
	//! </textarea>
	//! <input type="text" value="Blah blah tjo blah blah blah blah blah blah hej blah blah blah blah.  Blah blah blah blah blah trallala blah tjosan blah blah blah hej blah blah.">
	//! </body></html>
}

subtest SelectAndSearch()
{
	// Selection
	INT32 start_ofs, stop_ofs;
	widget->GetSelection(start_ofs, stop_ofs);
	verify(start_ofs == 0);
	verify(stop_ofs == 0);
	verify(widget->HasSelectedText() == FALSE);

	widget->SelectAll();
	widget->GetSelection(start_ofs, stop_ofs);
	verify(start_ofs == 0);
	verify(stop_ofs == GetTextLength(widget));
	verify(widget->HasSelectedText() == TRUE);

	// Search

	// find tjo
	verify(widget->SearchText(UNI_L("tjo"), 3, TRUE, FALSE, TRUE, SEARCH_FROM_BEGINNING, TRUE, TRUE));
	widget->GetSelection(start_ofs, stop_ofs);
	verify(start_ofs == 10);
	verify(stop_ofs == 13);

	// shouldn't find tjosan because of words is TRUE.
	verify(!widget->SearchText(UNI_L("tjo"), 3, TRUE, FALSE, TRUE, SEARCH_FROM_CARET, TRUE, TRUE));
	widget->GetSelection(start_ofs, stop_ofs);
	verify(start_ofs == 10);
	verify(stop_ofs == 13);

	// find hej backwards from end
	verify(widget->SearchText(UNI_L("hej"), 3, FALSE, FALSE, TRUE, SEARCH_FROM_END, TRUE, TRUE));
	widget->GetSelection(start_ofs, stop_ofs);
	verify(start_ofs == 131);
	verify(stop_ofs == 134);

	// find both tjo backwards from caret (with words FALSE)
	verify(widget->SearchText(UNI_L("tjo"), 3, FALSE, FALSE, FALSE, SEARCH_FROM_CARET, TRUE, TRUE));
	widget->GetSelection(start_ofs, stop_ofs);
	verify(start_ofs == 109);
	verify(stop_ofs == 112);
	verify(widget->SearchText(UNI_L("tjo"), 3, FALSE, FALSE, FALSE, SEARCH_FROM_CARET, TRUE, TRUE));
	widget->GetSelection(start_ofs, stop_ofs);
	verify(start_ofs == 10);
	verify(stop_ofs == 13);

	// Unselect
	widget->SelectNothing();
	widget->GetSelection(start_ofs, stop_ofs);
	verify(start_ofs == 0);
	verify(stop_ofs == 0);
}

test("SelectAndSearch_OpMultilineEdit") language C++;
require undefined HAS_NO_SEARCHTEXT;
{
	HTML_Element* e = find_element("textarea", 1);
	verify(e && "OOM when fetching element");
	OpMultilineEdit *multiedit = (OpMultilineEdit *) e->GetFormObject()->GetWidget();

	// Caret should be last
	verify(multiedit->CaretOnFirstInputLine() == FALSE);
	verify(multiedit->CaretOnLastInputLine() == TRUE);
	verify(multiedit->GetCaretOffset() == multiedit->GetTextLength(FALSE));

	widget = multiedit;
	verify(SelectAndSearch());
}

test("SelectAndSearch_OpEdit") language C++;
require undefined HAS_NO_SEARCHTEXT;
{
	HTML_Element* e = find_element("input", 1);
	verify(e && "OOM when fetching element");
	widget = e->GetFormObject()->GetWidget();

	// Caret should be last
	// THIS CASE FAILS! Due to a bug in the forms module and a bug in OpEdit::SetSelection that is too risky to change for core-2-final!
	//verify(widget->GetCaretOffset() == GetTextLength(widget));

	verify(SelectAndSearch());
}

test("OpMultilineEditCaretMovingAndPosition") language C++;
require success "HasMonospaceFont";
{
	HTML_Element* e = find_element("textarea", 1);
	verify(e && "OOM when fetching element");
	OpMultilineEdit *widget = (OpMultilineEdit *) e->GetFormObject()->GetWidget();

	OpInputAction go_to_start(OpInputAction::ACTION_GO_TO_START);
	OpInputAction go_to_line_start(OpInputAction::ACTION_GO_TO_LINE_START);
	OpInputAction go_to_line_end(OpInputAction::ACTION_GO_TO_LINE_END);
	OpInputAction next_char(OpInputAction::ACTION_NEXT_CHARACTER);
	OpInputAction prev_word(OpInputAction::ACTION_PREVIOUS_WORD);
	OpInputAction next_word(OpInputAction::ACTION_NEXT_WORD);

	// Start
	widget->OnInputAction(&go_to_start);
	verify(widget->GetCaretOffset() == 0);
	OpPoint caret_pos = widget->GetCaretPos();
	verify(caret_pos.x == 0 && caret_pos.y == 0);

	// Move by word
	widget->OnInputAction(&next_word);
	verify(widget->GetCaretOffset() == 5);
	widget->OnInputAction(&prev_word);
	verify(widget->GetCaretOffset() == 0);

	// End of line
	widget->OnInputAction(&go_to_line_end);
	verify(widget->GetCaretOffset() == 19);
	verify(widget->GetCaretPos().y == caret_pos.y);

	// Next (wrap to next line)
	widget->OnInputAction(&next_char);
	verify(widget->GetCaretOffset() == 19);
	verify(widget->GetCaretPos().y > caret_pos.y);

	// Start of line
	widget->OnInputAction(&go_to_line_start);
	verify(widget->GetCaretOffset() == 19);
	verify(widget->GetCaretPos().y > caret_pos.y);

	// Position from point (out of bounds)
	widget->SetCaretPos(OpPoint(-100, -100));
	verify(widget->GetCaretOffset() == 0);
	widget->SetCaretPos(OpPoint(10000, 10000));
	verify(widget->GetCaretOffset() == widget->GetTextLength(FALSE));
}

html
{
	//! <html>
	//! <body>
	//! <input name="edit" type="text" value="&#x05e2;&#x05d1;&#x05e8;abc&#x05e2;&#x05d1;&#x05e8;">
	//! <input name="edit" type="text" value="&#x05e2;&#x05d1;&#x05e8;abc&#x05e2;&#x05d1;&#x05e8;" style="direction: rtl;">
	//! <textarea rows="5" cols="20">&#x05e2;&#x05d1;&#x05e8;abc&#x05e2;&#x05d1;&#x05e8;</textarea>
	//! <textarea rows="5" cols="20" style="direction: rtl;">&#x05e2;&#x05d1;&#x05e8;abc&#x05e2;&#x05d1;&#x05e8;</textarea>
	//! </body></html>
}

test("BIDI moving caret") language C++;
require SUPPORT_TEXT_DIRECTION;
{
	// Test the logical and visual position of the caret when moving it in visual order (like with the arrowkeys)
	int i;
	HTML_Element* e;
	e = find_element("input", 1);
	verify(e && "OOM when fetching element");
	OpEdit *edit1 = (OpEdit *) e->GetFormObject()->GetWidget();
	e = find_element("input", 2);
	verify(e && "OOM when fetching element");
	OpEdit *edit2 = (OpEdit *) e->GetFormObject()->GetWidget();
	e =find_element("textarea", 1);
	OpMultilineEdit *textarea1 = (OpMultilineEdit *) e->GetFormObject()->GetWidget();
	e =find_element("textarea", 2);
	OpMultilineEdit *textarea2 = (OpMultilineEdit *) e->GetFormObject()->GetWidget();

	int currect_logical_pos_ltr_moving_right[] = { 0, 4, 5, 6, 8, 7, 6, 6, 6, 6 };
	int currect_logical_pos_ltr_moving_left[] = { 9, 5, 4, 3, 1, 2, 3, 3, 3, 3 };
	int currect_logical_pos_rtl_moving_right[] = { 9, 8, 7, 6, 4, 5, 6, 2, 1, 0 };
	int currect_logical_pos_rtl_moving_left[] = { 0, 1, 2, 3, 5, 4, 3, 7, 8, 9 };

	OpInputAction go_to_line_start(OpInputAction::ACTION_GO_TO_LINE_START);
	OpInputAction go_to_line_end(OpInputAction::ACTION_GO_TO_LINE_END);
	OpInputAction prev_char(OpInputAction::ACTION_PREVIOUS_CHARACTER);
	OpInputAction next_char(OpInputAction::ACTION_NEXT_CHARACTER);

	// LTR widgets

	edit1->OnInputAction(&go_to_line_start);
	for(i = 0; i < 10; i++)
	{
		verify(edit1->GetCaretOffset() == currect_logical_pos_ltr_moving_right[i]);
		edit1->OnInputAction(&next_char);
	}
	edit1->OnInputAction(&go_to_line_end);
	for(i = 0; i < 10; i++)
	{
		verify(edit1->GetCaretOffset() == currect_logical_pos_ltr_moving_left[i]);
		edit1->OnInputAction(&prev_char);
	}

	textarea1->OnInputAction(&go_to_line_start);
	for(i = 0; i < 10; i++)
	{
		verify(textarea1->GetCaretOffset() == currect_logical_pos_ltr_moving_right[i]);
		textarea1->OnInputAction(&next_char);
	}
	textarea1->OnInputAction(&go_to_line_end);
	for(i = 0; i < 10; i++)
	{
		verify(textarea1->GetCaretOffset() == currect_logical_pos_ltr_moving_left[i]);
		textarea1->OnInputAction(&prev_char);
	}

	// RTL widgets

	edit2->OnInputAction(&go_to_line_end);
	for(i = 0; i < 10; i++)
	{
		verify(edit2->GetCaretOffset() == currect_logical_pos_rtl_moving_right[i]);
		edit2->OnInputAction(&next_char);
	}
	edit2->OnInputAction(&go_to_line_start);
	for(i = 0; i < 10; i++)
	{
		verify(edit2->GetCaretOffset() == currect_logical_pos_rtl_moving_left[i]);
		edit2->OnInputAction(&prev_char);
	}

	textarea2->OnInputAction(&go_to_line_end);
	for(i = 0; i < 10; i++)
	{
		verify(textarea2->GetCaretOffset() == currect_logical_pos_rtl_moving_right[i]);
		textarea2->OnInputAction(&next_char);
	}
	textarea2->OnInputAction(&go_to_line_start);
	for(i = 0; i < 10; i++)
	{
		verify(textarea2->GetCaretOffset() == currect_logical_pos_rtl_moving_left[i]);
		textarea2->OnInputAction(&prev_char);
	}

	// Paint document (to have called DrawRTLString). The output is not really much interesting, the ordering is right if this test passed.
	Paint();
}

html
{
	//! <html>
	//! <style>
	//! body { margin: 5px; padding: 5px; font-family: "Bitstream Vera Sans"; font-size: 12px; line-height: 14px; }
	//! textarea { margin: 0px; padding: 0px; overflow: scroll; resize: none; }
	//! </style>
	//! <body>
	//! <textarea WRAP=OFF style="SCROLLBAR-BASE-COLOR: magenta; width: 50px; height: 50px; border: 1px solid black; background-color: white"></textarea>
	//! <textarea WRAP=OFF style="scrollbar-arrow-color: #000000;
	//!					scrollbar-base-color: #003300;
	//!					scrollbar-dark-shadow-color: #999900;
	//!					scrollbar-track-color: #557755;
	//!					scrollbar-face-color: #AABBAA;
	//!					scrollbar-shadow-color: #DDDDDD;
	//!					scrollbar-highlight-color: #CCCCCC;
	//!					scrollbar-3d-light-color: #003300; overflow: scroll; width: 50px; height: 50px; border: 1px solid black; background-color: white"></textarea>
	//! </body></html>
}

test("ScrollbarColors") language C++;
require CSS_SCROLLBARS_SUPPORT;
{
	state.window->SetLayoutMode(LAYOUT_NORMAL);
	HTML_Element* e = find_element("textarea", 1);
	verify(e && "OOM when fetching element");
	OpWidget *widget = e->GetFormObject()->GetWidget();
	if (g_pcdisplay->GetIntegerPref(PrefsCollectionDisplay::EnableScrollbarColors, (const uni_char*)NULL) && !widget->LeftHandedUI())
	{
		OpString8 filename;
		RETURN_IF_ERROR(filename.Set(test_path.CStr()));
		RETURN_IF_ERROR(filename.Append("css_scrollbars.png"));
		BOOL result_equal = OpStatus::IsSuccess(VerifyImage(filename.CStr(), 200, 200));
		if (!result_equal)
			output("\nERROR. The result doesn't match '%s'.\n", filename.CStr());
		verify(result_equal);
	}
}

html
{
	//! <html>
	//! <style>
	//! body { margin: 5px; padding: 5px; font-family: "Bitstream Vera Sans"; font-size: 12px; line-height: 14px; }
	//! select { margin: 0px; padding: 0px; }
	//! </style>
	//! <body>
	//! <nobr>
	//! <select multiple size=3 style="width: 50px; border: 1px solid black; background-color: white; font-family: 'Bitstream Vera Sans'; font-size: 10px;">
	//! <option style="background-color: red"></option>
	//! <option style="background-color: green"></option>
	//! <option style="background-color: blue"></option>
	//! </select>
	//! <select multiple size=3 style="width: 50px; border: 1px solid black; background-color: yellow; font-family: 'Bitstream Vera Sans'; font-size: 10px;">
	//! <option></option>
	//! <option style="background-color: orange"></option>
	//! <option></option>
	//! </select>
	//! <select multiple size=3 style="width: 50px; border: 1px solid black; background-color: white; font-family: 'Bitstream Vera Sans'; font-size: 10px;">
	//! <optgroup>
	//! <option></option>
	//! <option style="background-color: orange"></option>
	//! </optgroup>
	//! </select>
	//! <select multiple size=3 style="width: 50px; border: 1px solid black; background-color: white; font-family: 'Bitstream Vera Sans'; font-size: 10px;">
	//! <optgroup style="background-color: yellow">
	//! <option></option>
	//! <option style="background-color: orange"></option>
	//! </optgroup>
	//! </select>
	//! </nobr>
	//! </body></html>
}

test("OptionColors") language C++;
require undefined WIDGETS_CHECKBOX_MULTISELECT;
{
	state.window->SetLayoutMode(LAYOUT_NORMAL);
	OpString8 filename;
	RETURN_IF_ERROR(filename.Set(test_path.CStr()));
	RETURN_IF_ERROR(filename.Append("option_color.png"));
	BOOL result_equal = OpStatus::IsSuccess(VerifyImage(filename.CStr(), 250, 100));
	if (!result_equal)
		output("\nERROR. The result doesn't match '%s'.\n", filename.CStr());
	verify(result_equal);
}

html
{
	//! <html>
	//! <body>
	//! <input name="edit" type="text" value="">
	//! </body></html>
}

test("AutoCompletion") language C++;
{
	HTML_Element* e = find_element("input", 1);
	verify(e && "OOM when fetching element");
	OpEdit *edit = (OpEdit *) e->GetFormObject()->GetWidget();
	edit->autocomp.SetType(AUTOCOMPLETION_ACTIONS);

	OpString tmp;
	OpInputAction next_line(OpInputAction::ACTION_NEXT_LINE);
	OpInputAction prev_line(OpInputAction::ACTION_PREVIOUS_LINE);
	OpInputAction keypress(OpInputAction::ACTION_LOWLEVEL_KEY_PRESSED);
	OpInputAction enter(OpInputAction::ACTION_LOWLEVEL_KEY_PRESSED);
	enter.SetKeyCode(OP_KEY_ENTER);

	keypress.SetKeyCode(OP_KEY_S); keypress.SetActionKeyValue(UNI_L("s")); edit->OnInputAction(&keypress);
	keypress.SetKeyCode(OP_KEY_C); keypress.SetActionKeyValue(UNI_L("c")); edit->OnInputAction(&keypress);
	keypress.SetKeyCode(OP_KEY_R); keypress.SetActionKeyValue(UNI_L("r")); edit->OnInputAction(&keypress);
	keypress.SetKeyCode(OP_KEY_O); keypress.SetActionKeyValue(UNI_L("o")); edit->OnInputAction(&keypress);
	keypress.SetKeyCode(OP_KEY_L); keypress.SetActionKeyValue(UNI_L("l")); edit->OnInputAction(&keypress);
	edit->GetText(tmp); verify_string(tmp, "scrol");

	// Should select first match (Scroll down or any other scroll action)
	edit->OnInputAction(&next_line);
	edit->GetText(tmp); verify(!uni_str_eq(tmp.CStr(), UNI_L("scrol")));

	// Should select the entered text again and the list match should be unselected.
	edit->OnInputAction(&prev_line);
	edit->GetText(tmp); verify_string(tmp, "scrol");

	// Select and close a match
	edit->OnInputAction(&next_line);
	edit->OnInputAction(&enter);
	edit->GetText(tmp); verify(!uni_str_eq(tmp.CStr(), UNI_L("scrol")));
}

html
{
	//! <html>
	//! <body>
	//! <select size=20>
	//! <option selected>dummy
	//! <option>Op
	//! <option>dummy
	//! <option>Opera
	//! <option>Opera
	//! <option>dummy
	//! <option>Opera!
	//! </select>
	//! </body></html>
}

test("InlineFindListbox") language C++;
{
	HTML_Element* e = find_element("select", 1);
	verify(e && "OOM when fetching element");
	OpListBox *listbox = (OpListBox *) e->GetFormObject()->GetWidget();

	OpInputAction keypress(OpInputAction::ACTION_LOWLEVEL_KEY_PRESSED);

	verify(listbox->GetSelectedItem() == 0);
	keypress.SetKeyCode(OP_KEY_O); keypress.SetActionKeyValue(UNI_L("O")); listbox->OnInputAction(&keypress);
	verify(listbox->GetSelectedItem() == 1);
	keypress.SetKeyCode(OP_KEY_P);	keypress.SetActionKeyValue(UNI_L("p")); listbox->OnInputAction(&keypress);
	verify(listbox->GetSelectedItem() == 1);
	keypress.SetKeyCode(OP_KEY_E);	keypress.SetActionKeyValue(UNI_L("e")); listbox->OnInputAction(&keypress);
	verify(listbox->GetSelectedItem() == 3);
	keypress.SetKeyCode(OP_KEY_R);	keypress.SetActionKeyValue(UNI_L("r")); listbox->OnInputAction(&keypress);
	keypress.SetKeyCode(OP_KEY_A);	keypress.SetActionKeyValue(UNI_L("a")); listbox->OnInputAction(&keypress);
	verify(listbox->GetSelectedItem() == 3);
	keypress.SetKeyCode(OP_KEY_1);	keypress.SetActionKeyValue(UNI_L("!")); listbox->OnInputAction(&keypress);
	verify(listbox->GetSelectedItem() == 6);
}

html
{
	//! <html>
	//! <body>
	//! <textarea rows=2 cols=20>0 Aaaaaa		</textarea>
	//! </body></html>
}

test("OpMultilineEdit Tab character") language C++;
require success "HasMonospaceFont";
{
	OpString tmp;
	OpMultilineEdit *widget;

	// Special case with tab characters that has caused OpTextCollectionBlock to crash before.
	// Pass if no crash or assert.
	HTML_Element* ta = find_element("textarea", 1);
	verify(ta && "OOM when fetching element");
	widget = (OpMultilineEdit *) ta->GetFormObject()->GetWidget();
	widget->GetText(tmp, TRUE); verify_string(tmp, "0 \r\nAaaaaa\t\t");
}

// contents of text collection, string to test against, max length, offset, result
table test_strings(const uni_char*, const uni_char*, int, unsigned int, int) {
    { UNI_L("neither a borrower nor a lender be"), UNI_L("neither a borrower nor a lender be"), -1, 0, 0 }
    { UNI_L("neither a borrower nor a lender be"), UNI_L("neither a lender nor a borrower be"),  7, 0, 0 }
    { UNI_L("neither a borrower nor a lender be"), UNI_L("neither a lender nor a borrower be"), -1, 0, 'b'-'l' }
    { UNI_L("neither a borrower nor a lender be"), UNI_L("nor a lender be"), -1, 19, 0 }
    { UNI_L("neither a lender nor a borrower be"), UNI_L("nor a bastard be"), 7, 17, 0 }
    { UNI_L("neither a borrower nor a lender be"), UNI_L("nor a bastard be"), -1, 19, 'l'-'b' }
    { UNI_L("neither a borrower nor a lender be"), UNI_L("neither a borrower"), -1, 0, (int)' ' }
    { UNI_L("neither a borrower"), UNI_L("neither a borrower nor a lender be"), -1, 0, -(int)' ' }
    // will cause several blocks
    { UNI_L("bite\r\nme"), UNI_L("bite\r\nme"), -1, 0, 0 }
    { UNI_L("bite\r\nme"), UNI_L("e\r\nme"),    -1, 3, 0 }
    { UNI_L("bite\r\nme"), UNI_L("\r\nme"),     -1, 4, 0 }
    { UNI_L("bite\r\nme"), UNI_L("\nme"),       -1, 5, 0 }
    { UNI_L("bite\r\nme"), UNI_L("me"),         -1, 6, 0 }
    { UNI_L("bite\r\nme"), UNI_L("bite\r\nmX"),  7, 0, 0 }
    { UNI_L("bite\r\nme"), UNI_L("bite\r\nXe"),  6, 0, 0 }
    { UNI_L("bite\r\nme"), UNI_L("bite\rXme"),   5, 0, 0 }
    { UNI_L("bite\r\nme"), UNI_L("biteX\nme"),   4, 0, 0 }
    { UNI_L("bite\r\nme"), UNI_L("biteme"),     -1, 0, '\r'-'m' }
    { UNI_L("bite\r\nme"), UNI_L("bit\r\nme"),  -1, 0, 'e'-'\r' }
};
html
{
//! <html>
//! <body>
//! <textarea></textarea>
//! </body>
//! </html>
}
test("OpTextCollection::CompareText")
{
    HTML_Element* ta = find_element("textarea");
    verify(ta && ta->Type() == HE_TEXTAREA);
    OpMultilineEdit* w = (OpMultilineEdit*)ta->GetFormObject()->GetWidget();
    iterate(contents, compare, max_len, offset, result) from test_strings
    {
	verify(OpStatus::IsSuccess(w->SetText(contents)) && "OOM");
	verify(w->CompareText(compare, max_len, offset) == result);
    }
}

test("OpSlider with tickmarks")
{
	OpSlider* slider = NULL;
	INT32 w1,h1,w2,h2;
	verify(OpStatus::IsSuccess(OpSlider::Construct(&slider)));
	slider->GetPreferedSize(&w1, &h1, 50, 1);
	slider->ShowTickLabels(TRUE);
	slider->GetPreferedSize(&w2, &h2, 50, 1);
	verify(h2 > h1); // widget should be a bit taller than without tick labels
}
finally
{
	if(slider)
		slider->Delete();
}

test("OpSlider SetValue")
{
    // create slider with range [0; 100[
    OpSlider* slider = NULL;
    verify(OpStatus::IsSuccess(OpSlider::Construct(&slider)) && "OOM");
    const int min = 0, max = 99;
    const OpRect rect(0, 0, max+1, 11);
    slider->SetSize(rect.width, rect.height);
    slider->SetMin(min);
    slider->SetMax(max);

    const int values[] = { min, 7, 11, 17, 50, max };

    OpPoint point(rect.x, rect.y + (rect.height >> 1));
    for (unsigned int i = 0; i < ARRAY_SIZE(values); ++i)
    {
        slider->SetValue(values[i]);
        verify(slider->GetValue() == values[i]);
        point.x = rect.x + slider->GetValue();
        slider->UpdateTrack(rect);
        verify(slider->IsPointInKnob(point));
    }
}
finally
{
    if (slider)
        slider->Delete();
}

test("OpSlider SetValue while dragging")
{
    // create slider with range [0; 100[
    OpSlider* slider = NULL;
    verify(OpStatus::IsSuccess(OpSlider::Construct(&slider)) && "OOM");
    const int min = 0, max = 99;
    // this rect is passed directly to UpdateTrack, which should
    // ensure that knob position matches value exactly
    const OpRect rect(0, 0, max+1, 11);
    slider->SetSize(rect.width, rect.height);
    slider->SetMin(min);
    slider->SetMax(max);

    OpPoint cursor(0, rect.height >> 1);

    // test that dragging without calling SetValue works
    slider->SetValue(0);
    slider->UpdateTrack(rect);
    cursor.x = slider->GetValue();
    verify(slider->IsPointInKnob(cursor));
    slider->OnMouseDown(cursor, MOUSE_BUTTON_1, 1);
    cursor.x += 40;
    slider->OnMouseMove(cursor);
    slider->OnMouseUp(cursor, MOUSE_BUTTON_1, 1);
    verify(slider->GetValue() == cursor.x);
    slider->UpdateTrack(rect);
    verify(slider->IsPointInKnob(cursor));

    // grab the handle
    slider->SetValue(0);
    slider->UpdateTrack(rect);
    cursor.x = slider->GetValue();
    verify(slider->IsPointInKnob(cursor));
    slider->OnMouseDown(cursor, MOUSE_BUTTON_1, 1);
    // call SetValue, to check that this doesn't mess up the anchor point
    slider->SetValue(50);
    // move the handle
    cursor.x += 40;
    slider->OnMouseMove(cursor);
    // release handle - value should have changed according to the
    // handle movement
    slider->OnMouseUp(cursor, MOUSE_BUTTON_1, 1);
    verify(slider->GetValue() == cursor.x);
    slider->UpdateTrack(rect);
    verify(slider->IsPointInKnob(cursor));
}
finally
{
    if (slider)
        slider->Delete();
}

setup
{
}

html
{
//! <html><body><textarea type="text" ></textarea></body></html>
}
test ("Undo on select")
require WIDGETS_UNDO_REDO_SUPPORT;
{
	HTML_Element* he = find_element("textarea");
	verify(he);
	OpWidget* widget = he->GetFormObject()->GetWidget();
	verify(widget->GetType() == OpTypedObject::WIDGET_TYPE_MULTILINE_EDIT);
	OpMultilineEdit* edit = (OpMultilineEdit*)widget;

	OpString text;

	// set original text
	const uni_char* const orig = UNI_L("biteme");
	verify(OpStatus::IsSuccess( edit->SetText(orig) ));
	verify(OpStatus::IsSuccess( edit->GetText(text) ));
	verify(text == orig);

	// set selection
	const INT32 sel_start = 1, sel_end = 4;
	widget->SetSelection(sel_start, sel_end);
	INT32 _s, _e;
	widget->GetSelection(_s, _e);
	verify( sel_start == _s && sel_end == _e);

	// replace with undo
	edit->SetReceivedUserInput(TRUE);
	const uni_char* const set = UNI_L("");
	verify(OpStatus::IsSuccess( edit->SetTextWithUndo(set) ));
	verify(OpStatus::IsSuccess( edit->GetText(text) ));
	verify(text == set);

	// trigger undo and verify that original text is restored
	edit->Undo();
	verify(OpStatus::IsSuccess( edit->GetText(text) ));
	verify(text == orig);
}

exit
{
}
