<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
          "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<link rel=stylesheet href="../../coredoc/coredoc.css" />
<title>Module: AUTOPROXY</title>
</head>

<body>

<h1>Module: AUTOPROXY</h1>

<h2>About this module</h2>

<p>The AUTOPROXY module implements a Netscape technology: "Automatic
proxy configuration through JavaScript".</p>

<p>The general idea is that there exists a special script that the
browser loads.  Every time the browser tries to load a URL, the script
is run and returns information about how to go about fetching the
document at that URL: whether to connect directly to the host, or to
connect through a proxy.  In the latter case, the script also returns
information about the proxy to use.</p>

<p>The technology is popular in large companies, which can use it to
balance traffic among multiple proxies or to different proxies at
different times of the day.</p>


<h2>Visibility in Opera</h2>

<h3>Setting up a proxy script</h3>

<p>The proxy script is a JavaScript source file defining a global
function <code>FindProxyForURL</code> that takes some specific
arguments and returns some specific values; it is described in <a
href="proxyconf.html">Netscape's documentation</a>.</p>

<p>In the (Windows) preferences UI, go to the "Network" panel, click
the "Proxy servers" button, and at the bottom of the dialog check the
box for "Use automatic proxy configuration" and enter a URL to
the proxy configuration script in the box below it.  Then "OK" your
way out.</p>

<p>Power users may edit the "[Proxy]" section of opera6.ini, like this:
<pre>
  [Proxy]
  Use Automatic Proxy Configuration=1
  Automatic Proxy Configuration URL=file:///C:/mydir/myautoproxy.pac
</pre>
The ".pac" extension is traditional, though other extensions are
known (".jsc", for "JavaScript Configuration").
</p>


<h3>Interactions inside Opera</h3>

<p>If Opera is compiled with
<code>SUPPORT_AUTO_PROXY_CONFIGURATION</code> (controlled by the feature <code>FEATURE_AUTO_PROXY_CONFIG</code>) then the
proxy-determining code in <code>URL_DataStorage</code> will consult
the autoproxy module about a configured proxy for some URLs.  Exactly
which URLs is determined by clients of this code (ie, the URL
module).</p>


<h3>Policies</h3>

<p>The following policies are currently in effect, implemented partly by
   the autoproxy module and partly by the URL module:</p>

<ul>
<li><p>If the autoproxy URL cannot be loaded, then autoproxy functionality is
    disabled until the autoproxy preferences are changed.
(FIXME: It is a known bug that Opera reports that Proxy Configuration will be disabled for the rest of the session. This is the old behaviour)
</p>

<li><p>If the autoproxy script contains a syntax error, then an error is
    posted to the JS console with information about the location of
	the error, autoproxy functionality is disabled until the autoproxy preferences are changed.
	(FIXME: It should also be reloaded if the script is changed)
</p>

<li><p>If the autoproxy script throws an unhandled exception
    at run-time, then the exception is posted to the JS console,
	autoproxy functionality is disabled until the autoproxy preferences are changed.</p>

<li><p>If the autoproxy script accesses network functionality while it is
    being initialized, then autoproxy functionality is disabled until the autoproxy preferences are changed. 
(<b>FIXME:</b> It doesn't say <b>why</b> it was disabled; this sounds like a bug.)</p>

<li><p>Buggy scripts are handled by cutting them off after a fairly large number of computation steps 
(currently 10 million steps). A script that fails with an error will cause the URL not to be loaded at all.</p>
</ul>


<h2>BTS</h2>

<p>Autoproxy bugs are flagged with the string <tt>[AUTOPROXY]</tt> in
the Summary field and usually have the component "Proxy".</p>


<h2>Interface overview and API documentation</h2>

<p><a href="api/index.html">API documentation generated by
Doxygen</a> contains all necessary information.</p>


<h2>Implementation description</h2>

<h3>Overview</h3>

<p><a href="internal/index.html">Implementation documentation
generated by Doxygen</a> contains what you need to know.</p>


<h3>Footprint</h3>

<p>The module is small and can be disabled completely.</p>

<p>Older versions of autoproxy stores the proxy configuration library as
a unicode string (probably about 20KB) in the library itself. Newer versions
store this library in compiled form, thus reducing footprint.</p>

<h3>Dynamic memory use and OOM handling</h3>

(I'm using "UAPCL" as an abbreviation for "URL_AutoProxyConfig_LoadHandler"
below.)

<dl>
<dt>OOM policies
<dd>
<p>Since the autoproxy module runs as a client of the URL module, it
generally uses the same OOM outward signalling mechanisms as the URL
module.</p>

<p>An OOM result is generally signalled through a call on
<nobr><code>MemoryManager::RaiseCondition</code></nobr>, while at the
same time an error code is posted to the URL layer: either returned as
a COMM_REQUEST_FAILED error from
<nobr><code><abbr title="URL_AutoProxyConfig_LoadHandler">UAPCL</abbr>::Load()</code></nobr> or posted as an error on that
load handler (MSG_COMM_LOADING_FAILED, with error
ERR_AUTO_PROXY_CONFIG_FAILED).</p>

<p>Internally in the module OOM is usually handled by propagating
OP_STATUS values.</p>

<dt>Who handles OOM?
<dd>
<p>Whoever created the load handler and called
<code><abbr title="URL_AutoProxyConfig_LoadHandler">UAPCL</abbr>::Load()</code> on it must be prepared to handle OOM,
signalled as described above.  The autoproxy module only performs
local cleanup, making sure that things remain consistent and
leak-free.  Generally the responsibility falls on the URL module.</p>

<dt>Flow
<dd>
<p>All entry points to the module are through
<nobr><code><abbr title="URL_AutoProxyConfig_LoadHandler">UAPCL</abbr>::Load()</code></nobr> and
<code><abbr title="URL_AutoProxyConfig_LoadHandler">UAPCL</abbr>::HandleCallback()</code>; follow the flow from there, into
<code><abbr title="URL_AutoProxyConfig_LoadHandler">UAPCL</abbr>::ExecuteScript()</code>.  It's straightforward.</p>

<p>Also see the general implementation description, above.</p>

<dt>Heap memory usage
<dd>
<p>The module itself allocates very little: only a few small objects
to hold data temporarily.  But it does use the ECMAScript engine,
which can allocate quite a lot.  Autoproxy creates one global
ES_Runtime, as well as one ES_Context per request, to run
requests.</p>

<p>The autoproxy module caches an ES_Runtime, and this may prevent
some memory from being freed even if all windows are closed.  See
"Caching and freeing memory" below.</p>

<dt>Stack memory usage
<dd>
<p>The module itself uses no recursive calls and no stack-allocated
arrays or large objects.  It calls the ECMAScript engine and the URL
layer; they may use more.  Locally in the module I'd say that less
than 50 words of stack memory are live in the worst case on a system
with a dense processor stack (like x86).</p>

<dt>Static memory usage
<dd>
<p>The module currently has three global variables (total of three
words of memory).</p>

<dt>Caching and freeing memory
<dd>
<p>One ES_Runtime is cached by the module and may hold onto some
usually not very large amount of memory (though there are no bounds on
how much memory a runtime can reference.)</p>

<p>The caches can be cleaned out by calling the global function
<code>ReleaseAutoProxyResources()</code>.  It is safe to call this
function at any time.  If there are no pending autoproxy requests,
this will release all dynamic memory that is currently held by the
module.  In order to actually free memory held by the ECMAScript
environment, it may be necessary to run a garbage collection; the
autoproxy module does not do that.</p>

<dt>Freeing memory on exit
<dd>
<p>The function <code>ReleaseAutoProxyResources()</code> must be
called on exit before the ECMAScript environment is destroyed.</p>

<dt>Temp buffers
<dd><p>One of the methods in the autoproxy module is using the buffer
returned from <code>MemoryManager::GetTempBuffer()</code>.  There is no
check on whether this buffer is used outside the module.  (Reuse of
the buffer internally is not a problem: this is the only place in the
code that uses the temp buffer, and the code does not call any
interesting functions.)  It would be trivial to allocate a temporary
string on the heap to serve the same purpose.</p>

<dt>Memory tuning
<dd><p>No known opportunities in the module proper.</p>

<dt>Tests
<dd><p>There are no tests, since memory use is fairly trivial.</p>

<p>If the deallocation function is not called before Opera exits, one
will get an assert in the ECMAScript engine when that is
destroyed.</p>

<dt>Coverage
<dd><p>Running the selftests for the module (see comments in
<code>testsuite/autoproxy.ot</code> for detailed description; it is
more than running with <code>-test</code>) should exercise most of the
code.</P>

<dt>Design choices
<dd>
<p>One trade-off has been made: an ES_Runtime is cached, to avoid
having to recreate it for every URL lookup.  This means that RAM use
is higher than the theoretical minimum.  It is probably the case that
it is not practical to avoid at least some kind of caching.</p>

<p>There are no other known tradeoffs.</p>

<dt>Improvements
<dd>
<p>There are no planned improvements.  All known improvements would
come as a result of the ECMAScript engine improving its memory use.</p>

</dl>


<h3>Performance</h3>

<p>The performance of the module is largely dependent on the
performance of the ECMAScript engine.</p>

<p>The important things that happen in the autoproxy module are:</p>

<ul>
<li><p>Reading the autoproxy script from a URL, creating a runtime for
    it, and compiling it.<p>

    <p>These operations are performed whenever the script changes.</p>

<li><p>Running a FindProxyForURL request.  This consists of compiling a
    small script, creating a context, and running the script for a quantum.
    If the script finishes within its first quantum (most do) then it
    takes no penalty; otherwise, it is rescheduled to run in 50ms.</p>

    <p><b>FIXME:</b> Here the time may well be dominated by invoking
    the compiler.  We can avoid running the compiler by instead
    looking up the function and calling it directly.</p>

    <p><b>FIXME:</b> The 50ms reschedule is usually too long; if we
    could use the standard scheduler we could do better.</p>

<li><p>Performing name lookups.</p>

    <p>Name lookups are synchronous for the script that invokes them,
    but take no time per se except waiting for the lookup to complete.</p>

<li><p>Executing proxy library functions: <code>shExpMatch</code> and the like.</p>

    <p><code>shExpMatch</code> is written in C and is probably not a
    bottleneck.  The other library functions are written in
    JavaScript, but they are generally simple and it is not clear they
    should be a problem.  With the new ECMAScript compiler they should
    be faster still.</p>

</ul>

<h2>References</h2>

<p>
<a href="../../ecmascript/documentation/index.html">ECMAScript module</a><br>
<a href="../../ecmascript_utils/documentation/index.html">ECMAScript utilities module</a><br>
<a href="proxyconf.html">Netscape's original documentation</a> (local copy)<br>
<a href="revised_apc.html">A revised version of Netscape's documentation that include some design choices</a> (local copy)<br>
<a href="http://wiki.palace.opera.no/developerwiki/index.php/Modules/autoproxy">Module repository page</a> (Wiki)<br>
<a href="http://www.ecma-international.org/publications/standards/ECMA-262.HTM">ECMAScript 3rd edition</a> (external)<br>
</p>

<hr>
<p>$Id$</p>

</body>

</html>
