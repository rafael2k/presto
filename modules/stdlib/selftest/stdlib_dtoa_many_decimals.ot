/* -*- Mode: c++; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*-
 *
 * Copyright (C) 2009-2010 Opera Software ASA.  All rights reserved.
 *
 * This file is part of the Opera web browser.  It may not be distributed
 * under any circumstances.
 *
 * Anders Oredsson
 */

group "stdlib.dtoa";

global
{
	char* generateNumber(char digitA, int nof_digitA, char digitB, int nof_digitB, char digitC, int nof_digitC)
	{

		OP_ASSERT('0' <= digitA && digitA <= '9');
		OP_ASSERT('0' <= digitB && digitB <= '9');
		OP_ASSERT('0' <= digitC && digitC <= '9');

		char* number_string = OP_NEWA(char, nof_digitA + 1 + nof_digitB + nof_digitC + 1);
		char* str_offset = number_string;

		op_memset(str_offset, digitA, nof_digitA);

		str_offset += nof_digitA;
		*str_offset++ = '.';

		op_memset(str_offset, digitB, nof_digitB);
		str_offset += nof_digitB;

		op_memset(str_offset, digitC, nof_digitC);
		str_offset += nof_digitC;

		*str_offset++ = '\0';

		return number_string;
	}

	char* doubleToBits(double d)
	{

		char* bits = OP_NEWA(char, (sizeof(double)*8) + 1);
		size_t bitCount = sizeof(double)*8;
		char* p = bits;

		unsigned char* data = (unsigned char*)&d;
		unsigned char bitMask = 1;
		int bitInByteCount = 0;

		// check the bits
		for (size_t i = 0; i < bitCount; i++)
		{
			if ( ((*data) & bitMask) )
				*p = '1';
			else
				*p = '0';
			p++;

			bitMask = bitMask << 1;
			bitInByteCount += 1;

			if (bitInByteCount >= 8)
			{
				bitInByteCount = 0;
				data++;
				bitMask = 1;
			}
		}

		//0-terminate
		*p = 0;

		return bits;
	}
}

// -- testcases ---------------------------------------------------------

// #1: Number of digits before dot.
// #2: Number of zeros after dot.
// #3: Number of digits after zeros after dot
// #4: Digit to use
// #5: Bitstring with expected result

table dtoa_tests(char, int, char, int, char, int, const char *)
{
	{ '0', 1, '0', 5, '4', 5, "1111010101010001111110010111101011000100001001010100101101111100"},

	{ '0', 1, '0', 1000, '4', 1000, "0000000000000000000000000000000000000000000000000000000000000000"},
	{ '3', 1, '0', 1000, '3', 1000, "0000000000000000000000000000000000000000000000000001000000000010"},
	{ '0', 1, '0', 2000, '2', 1000, "0000000000000000000000000000000000000000000000000000000000000000"},

	{ '0', 1, '0', 10000, '1', 1000, "0000000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 9900, '2', 1000, "0000000000000000000000000000000000000000000000000000000000000000"},
	{ '3', 1, '0', 9900, '3', 1000, "0000000000000000000000000000000000000000000000000001000000000010"},

	{ '0', 1, '0', 1000, '1', 1000, "0000000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 100, '1', 1000, "1001110111010011100001101001101000101011010001110001111101010100"},
	{ '0', 1, '0', 10, '1', 1000, "1011011001011000101010000111101111111111011101100001010110111100"},
	{ '0', 1, '0', 1, '1', 1000, "1110100000110110100000110110100000110110100000110110000111111100"},

	{ '0', 1, '0', 900, '1', 1000, "0000000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 800, '1', 1000, "0000000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 700, '1', 1000, "0000000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 600, '1', 1000, "0000000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 500, '1', 1000, "0000000000000000000000000000000000000000000000000000000000000000"},

	// These 10 lines trigger an assert in dmg's dtoa code (see CORE-10928 and CORE-26097)
	//{ 0, 480, 1000, 1, "0000000000000000000000000000000000000000000000000000000000000000"},
	//{ 0, 450, 1000, 1, "0000000000000000000000000000000000000000000000000000000000000000"},
	//{ 0, 400, 1000, 1, "0000000000000000000000000000000000000000000000000000000000000000"},
	//{ 0, 350, 1000, 1, "0000000000000000000000000000000000000000000000000000000000000000"},
	//{ 0, 340, 1000, 1, "0000000000000000000000000000000000000000000000000000000000000000"},
	//{ 0, 330, 1000, 1, "0000000000000000000000000000000000000000000000000000000000000000"},
	//{ 0, 325, 1000, 1, "0000000000000000000000000000000000000000000000000000000000000000"},
	//{ 0, 323, 1000, 1, "0000000000000000000000000000000000000000000000000000000000000000"},
	//{ 0, 323, 1000, 1, "0000000000000000000000000000000000000000000000000000000000000000"},
	//{ 0, 323, 1000, 2, "0000000000000000000000000000000000000000000000000000000000000000"},

	{ '0', 1, '0', 323, '3', 1000, "1000000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 323, '4', 1000, "1000000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 323, '5', 1000, "1000000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 323, '6', 1000, "1000000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 323, '7', 1000, "0100000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 323, '8', 1000, "0100000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 323, '9', 1000, "0100000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 322, '1', 1000, "0100000000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 321, '1', 1000, "0110100000000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 320, '1', 1000, "1000011100000000000000000000000000000000000000000000000000000000"},
	{ '0', 1, '0', 300, '1', 1000, "0001000101100110001001010100000001110001001100001100111010000000"},
	{ '0', 1, '0', 200, '1', 1000, "0010001011000101010001101111010011101011101000111010110001101000"},

}

test("numbersShouldBeConvertedPreciselyAsBefore")
	require STDLIB_DTOA_CONVERSION;
{
	iterate (digitA, nof_digitA, digitB, nof_digitB, digitC, nof_digitC, answer) from dtoa_tests
	{
		// Generate the string
		char* number_string = generateNumber(digitA, nof_digitA, digitB, nof_digitB, digitC, nof_digitC);

		// Run op_strtod
		double dtoa = op_strtod(number_string,0);

		// Get bits and match with answer
		char*  bits = doubleToBits(dtoa);
		bool   match = op_strcmp(bits, answer) == 0;

		OP_DELETEA(number_string);
		OP_DELETEA(bits);

		verify(match);
	}
}

test("dtoaShouldParseAsManyBytesAsBefore")
	require STDLIB_DTOA_CONVERSION;
{
	iterate (digitA, nof_digitA, digitB, nof_digitB, digitC, nof_digitC, answer) from dtoa_tests
	{
		// Generate the string
		char* number_string = generateNumber(digitA, nof_digitA, digitB, nof_digitB, digitC, nof_digitC);
		int number_string_len = op_strlen(number_string);

		// Run op_strtod
		char* parse_end;
		op_strtod(number_string, &parse_end);

		// Find parsed distance
		int parsed_len = parse_end - number_string;

		OP_DELETEA(number_string);
		verify(number_string_len == parsed_len);
	}
}

test("theoreticalSmallestDoubleNumber")
	require STDLIB_DTOA_CONVERSION;
{
	const char* theoreticalSmallest =
	"0.000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000494065645841246544176568792868221372365059802614324764425585682500675507270"
	"20875186529983636163599237979656469544571773092665671035593979639877479601078187"
	"81263007131903114045278458171678489821036887186360569987307230500063874091535649"
	"84387312473397273169615140031715385398074126238565591171026658556686768187039560"
	"31062493194527159149245532930545654440112748012970999954193198940908041656332452"
	"47571478690147267801593552386115501348035264934720193790268107107491703332226844"
	"75333572083243193609238289345836806010601150616980975307834227731832924790498252"
	"47307763759272478746560847782037344696995336470179726777175851256605511991315048"
	"91101451037862738167250955837389733598993664809941164205702637090279242767544565"
	"229087538682506419718265533447265625";

	const char* theoreticalSmallerThenSmallestRoundedDown =
	"0.000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000247032822920623272088284396434110686182529901307162382212792841250337753635"
	"10437593264991818081799618989828234772285886546332835517796989819938739800539093"
	"90631503565951557022639229085839244910518443593180284993653615250031937045767824"
	"92193656236698636584807570015857692699037063119282795585513329278343384093519780"
	"15531246597263579574622766465272827220056374006485499977096599470454020828166226"
	"23785739345073633900796776193057750674017632467360096895134053553745851666113422"
	"37666786041621596804619144672918403005300575308490487653917113865916462395249126"
	"23653881879636239373280423891018672348497668235089863388587925628302755995657524"
	"45550725518931369083625477918694866799496832404970582102851318545139621383772282"
	"6145437693412532098591327667236328125";

	const char* approximatedSmallerThenSmallestRoundedUp =
	"0.000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000000000000000000000000000000000000000000000000000000000000000000000000000000"
	"00000247032822920623272088284396434110686182529901307162382212792841250337753635"
	"10437593264991818081799618989828234772285886546332835517796989819938739800539093"
	"90631503565951557022639229085839244910518443593180284993653615250031937045767824"
	"92193656236698636584807570015857692699037063119282795585513329278343384093519780"
	"15531246597263579574622766465272827220056374006485499977096599470454020828166226"
	"23785739345073633900796776193057750674017632467360096895134053553745851666113422"
	"37666786041621596804619144672918403005300575308490487653917113865916462395249126"
	"23653881879636239373280423891018672348497668235089863388587925628302755995657524"
	"45550725518931369083625477918694866799496832404970582102851318545139621383772282"
	"6145437693412532098591327667236328125"
	"0000000000000000000001"; // we can add more zeros before the 1

	// Run op_strtod
	double dtoa1 = op_strtod(theoreticalSmallest,0);
	double dtoa2 = op_strtod(theoreticalSmallerThenSmallestRoundedDown,0);
	double dtoa3 = op_strtod(approximatedSmallerThenSmallestRoundedUp,0);

	// Get bits and match with answer
	char*  bits1 = doubleToBits(dtoa1);
	char*  bits2 = doubleToBits(dtoa2);
	char*  bits3 = doubleToBits(dtoa3);

	verify_string(bits1, "1000000000000000000000000000000000000000000000000000000000000000"); // theoreticalSmallest
	verify_string(bits2, "0000000000000000000000000000000000000000000000000000000000000000"); // theoreticalSmallerThenSmallestRoundedDown
	verify_string(bits3, "1000000000000000000000000000000000000000000000000000000000000000"); // approximatedSmallerThenSmallestRoundedUp

	OP_DELETEA(bits1);
	OP_DELETEA(bits2);
	OP_DELETEA(bits3);
}
