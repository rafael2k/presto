/* -*- Mode: c++; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*-
 *
 * Copyright (C) 1995-2011 Opera Software ASA.  All rights reserved.
 *
 * This file is part of the Opera web browser.  It may not be distributed
 * under any circumstances.
 *
 * Lars T Hansen
 * Peter Krefting
 * Morten Rolland
 */

group "stdlib.date";

include "modules/stdlib/util/opdate.h";

global
{
#ifdef QUIET_NAN_IS_ONE
	double nan = op_implode_double( 0x7fffffffUL, 0xffffffffUL );
#else
	double nan = op_implode_double( 0x7ff7ffffUL, 0xffffffffUL );
#endif

/* Functions that break up a Unix timestamp into year/month/day etc will usually
 * return a "struct tm" where the days are indexed from 1 but the months are indexed
 * from 0. Thus, "month==1" and "day==1" actually means the 1st Feb and not 1st Jan.
 * To avoid confusion, the following defines are used instead of integer literals
 * for hardcoded months in this file.
 */
#define MONTH_JAN 0
#define MONTH_FEB 1
#define MONTH_MAR 2
#define MONTH_APR 3
#define MONTH_MAY 4
#define MONTH_JUN 5
#define MONTH_JUL 6
#define MONTH_AUG 7
#define MONTH_SEP 8
#define MONTH_OCT 9
#define MONTH_NOV 10
#define MONTH_DEC 11

// The number of milliseconds in a day (24h).
#define DAY_MS 24.0*60*60*1000.0

// The number of days between "1st Jan 00:00:00 year 0" to "YEAR-01-01 00:00:00"
// (if you're unclear on the existence and length of year zero see setup {} section below).
#define DAYS_FROM_YEAR_0_TO_YEAR_X(year) (((year>0)?1:0) + (year)*365 + (year-(year>0?1:0))/4 - (year-(year>0?1:0))/100 + (year-(year>0?1:0))/400)

	/** Used in test("Parsing dates without timezone: ...") to store the parsed
	 * result of the first date in the table TZLessDates. All other dates in
	 * that table are expected to yield the same value. */
	double tz_less_dates_reference;
}
setup
{
	// Note that historians typically don't include an actual year zero (i.e. in
	// their world the calendar year 1 BC is followed by the calendar year 1 AD).
	// However, Ecmascript uses ISO 8601:2004 dates and it has an actual year zero
	// which is also a leap year. For clarification, here are some asserts:
	OP_STATIC_ASSERT(DAYS_FROM_YEAR_0_TO_YEAR_X(-5) == -1826);
	OP_STATIC_ASSERT(DAYS_FROM_YEAR_0_TO_YEAR_X(-4) == -1461);
	OP_STATIC_ASSERT(DAYS_FROM_YEAR_0_TO_YEAR_X(-1) == -365);
	OP_STATIC_ASSERT(DAYS_FROM_YEAR_0_TO_YEAR_X(0) == 0);
	OP_STATIC_ASSERT(DAYS_FROM_YEAR_0_TO_YEAR_X(1) == 366);
	OP_STATIC_ASSERT(DAYS_FROM_YEAR_0_TO_YEAR_X(4) == 1461);
	OP_STATIC_ASSERT(DAYS_FROM_YEAR_0_TO_YEAR_X(5) == 1827);

	tz_less_dates_reference = -1;
}

test("verify sanity of days at year formula")
{
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(-101) == -36889);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(-100) == -36524);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(-99) == -36159);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(-5) == -1826);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(-4) == -1461);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(-3) == -1095);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(-2) == -730);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(-1) == -365);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(0) == 0);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(1) == 366); // Year 0 was a leap year
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(2) == 366 + 365);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(3) == 366 + 365 + 365);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(4) == 366 + 365 + 365 + 365);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(5) == 366 + 365 + 365 + 365 + 366);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(99) == 36160);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(100) == 36525);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(101) == 36890);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(399) == 145732);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(400) == 146097);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(401) == 146463);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(1900) == 693961);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(1970) == 719528);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(2000) == 730485);
	verify(DAYS_FROM_YEAR_0_TO_YEAR_X(2004) == 731946);
}

table yearfromtime(double, int)
{
	// Verify that year -400 was a leap year.
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-400) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 1) * DAY_MS,		-401 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-400) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			-400 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-400) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365) * DAY_MS,		-400 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-400) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365 + 1) * DAY_MS,	-399 },

	// Verify that year -100 was not a leap year.
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-100) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 1) * DAY_MS,		-101 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-100) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			-100 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-100) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 363) * DAY_MS,		-100 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-100) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 364) * DAY_MS,		-100 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-100) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365) * DAY_MS,		-99 },

	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-15) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			-15 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-14) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			-14 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-13) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			-13 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-12) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			-12 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-11) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			-11 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(-10) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			-10 },

	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 9*365 + 2) * DAY_MS,	-9 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 8*365 + 3) * DAY_MS,	-9 },

	// Verify first and last days of year -8 (which was a leap year in the proleptic gregorian calendar).
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 8*365 + 2) * DAY_MS,	-8 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 7*365 + 2) * DAY_MS,	-8 },

	// Verify first and last days of years -7, -6 and -5
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 7*365 + 1) * DAY_MS,	-7 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 6*365 + 2) * DAY_MS,	-7 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 6*365 + 1) * DAY_MS,	-6 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 5*365 + 2) * DAY_MS,	-6 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 5*365 + 1) * DAY_MS,	-5 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 4*365 + 2) * DAY_MS,	-5 },

	// Verify first and last days of year -4 (which was a leap year in the proleptic gregorian calendar).
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 4*365 + 1) * DAY_MS,	-4 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 3*365 + 1) * DAY_MS,	-4 },

	// Verify first and last days of years -3, -2 and -1 (all regular years).
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 3*365) * DAY_MS,	-3 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 2*365 + 1) * DAY_MS,	-3 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 2*365) * DAY_MS,	-2 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365 + 1) * DAY_MS,	-2 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365) * DAY_MS,		-1 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 1) * DAY_MS,		-1 },

	{ 0.0 - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) * DAY_MS,			0 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 1) * DAY_MS,		0 },
	// Still year zero because year zero had 366 days (leap year).
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 365) * DAY_MS,		0 },

	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 366) * DAY_MS,		1 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 2*365) * DAY_MS,	1 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 2*365 - 1) * DAY_MS,	2 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 3*365) * DAY_MS,	2 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 3*365 - 1) * DAY_MS,	3 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 4*365) * DAY_MS,	3 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 4*365 - 1) * DAY_MS,	4 },
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 5*365) * DAY_MS,	4 },
	// Since both year 0 and year 4 are leap years, we're still in year 4:
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 5*365 - 1) * DAY_MS,	4 },
	// First day of year 5
	{ 0.0 - (DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 5*365 - 2) * DAY_MS,	5 },

	// Verify that year 100 is NOT a leap year
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(100) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 1) * DAY_MS,		99 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(100) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			100 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(100) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 364) * DAY_MS,		100 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(100) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365) * DAY_MS,		101 },

	// Verify that year 400 is a leap year
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(400) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) - 1) * DAY_MS,		399 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(400) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			400 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(400) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365) * DAY_MS,		400 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(400) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 366) * DAY_MS,		401 },


	// Note: 25567 days passed between 1900 and 1970

	// Verify that the year 1900 had exactly 365 days (non leap year).
	{ 0.0 - (25567.0 + 1) * DAY_MS,               			1899 },
	{ 0.0 - 25567.0 * DAY_MS,               			1900 },
	{ 0.0 - (25567.0 - 364) * DAY_MS,              			1900 },
	{ 0.0 - (25567.0 - 365) * DAY_MS,              			1901 },

	{ 0.0 - (25567.0 - 365*4 + 1) * DAY_MS,				1903 },
	{ 0.0 - (25567.0 - 365*4) * DAY_MS,				1904 },
	{ 0.0 - (25567.0 - 365*4 - 1) * DAY_MS,				1904 },
	{ 0.0 - (25567.0 - 365*5) *  DAY_MS,				1904 },
	{ 0.0 - (25567.0 - 365*5 - 1) * DAY_MS,				1905 },

	{ 0 - (2*365+2)	* DAY_MS,					1967 },
	{ 0 - (2*365+1)	* DAY_MS,					1968 },
	{ 0 - (2*365) * DAY_MS,						1968 },
	{ 0 - (1*365+1)	* DAY_MS,					1968 },
	{ 0 - (1*365) * DAY_MS,						1969 },
	{ 0,								1970 },
	{ 0 + (1*365) * DAY_MS,						1971 },
	{ 0 + (2*365) * DAY_MS,						1972 },
	{ 0 + (3*365) * DAY_MS,						1972 },
	{ 0 + (3*365+1) * DAY_MS,					1973 },

	{ 0 + (30*365+6) * DAY_MS,					1999 },
	// 30 * 365 + 7 days after "1970-01-01 00:00:00" was "2000-01-01 00:00:00" since there was 7 leap years between 1970 and 2000
	// These two cases verifies that the year 2000 really has 366 days (it's a leap year since it's divisable by 400).
	{ 0 + (30*365+7) * DAY_MS,					2000 },
	{ 0 + (30*365+7+365) * DAY_MS,					2000 },

	{ 0 + (30*365+7+365+1) * DAY_MS,				2001 },
	{ 0 + (30*365+7+365+365) * DAY_MS,				2001 },

	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2002) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			2002 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2002) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 364) * DAY_MS,		2002 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2002) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365) * DAY_MS,		2003 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2003) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			2003 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2003) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 364) * DAY_MS,		2003 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2003) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365) * DAY_MS,		2004 },

	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2000) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 4*365) * DAY_MS,		2003 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2000) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 4*365 + 1) * DAY_MS,	2004 },
	// These two are both still in 2004 since both 2000 and 2004 are leap years
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2000) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 5*365) * DAY_MS,		2004 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2000) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 5*365 + 1) * DAY_MS,	2004 },

	// First day in 2005
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2000) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 5*365 + 2) * DAY_MS,	2005 },

	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2099) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			2099 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2099) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 364) * DAY_MS,		2099 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2099) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365) * DAY_MS,		2100 },
	// Year 2100 is divisable by 100 but not 400, so it's not a leap year (365 days only).
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2099) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365 + 364) * DAY_MS,	2100 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2099) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970) + 365 + 365) * DAY_MS,	2101 },

	// Some extra testcases that verifies year correctness very close to new year's eve.
	// (Mozilla's testsuite showed that our code has problems with these cases at first).
	{ -62167219200000.0 - 60*60*1000,	-1 }, // 1 h before 00:00:00 on 1st Jan year 0000
	{ -62167219200000.0 - 61*1000,		-1 }, // 61 s before
	{ -62167219200000.0 - 1000,		-1 }, // 1 s before
	{ -62167219200000.0 - 1,		-1 }, // 1 ms before
	{ -62167219200000.0,			0 },
	{ -62167219200000.0 + 1,		0 },  // 1 ms after
	{ -62167219200000.0 + 1000,		0 },  // 1 s after
	{ -62167219200000.0 + 61*1000,		0 },  // 61 s after
	{ -62167219200000.0 + 60*60*1000,	0 },  // 1 h after

	// Checking that we're rounding day counts as expected on year day 0 far back
	// in time: -3509827290000000.0 == Fri Jan 02 -109252 00:00:00 GMT+0100
	{ -3509827290000000.0,	-109252},
	{ -3509827290000000.0 + 1,	-109252},
	{ -3509827290000000.0 - 2,	-109252},
	{ -3509827290000002.0 - 24 * 60 * 60 * 1000, -109253},

	// One millisecond before, exactly at and 1 ms after "00:00:00 at 1st Jan 2004"
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2004) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS - 1,		2003 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2004) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			2004 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2004) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS + 1,		2004 },

	// One millisecond before, exactly at and 1 ms after "00:00:00 at 1st Jan 2005"
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2005) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS - 1,		2004 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2005) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS,			2005 },
	{ 0.0 + (DAYS_FROM_YEAR_0_TO_YEAR_X(2005) - DAYS_FROM_YEAR_0_TO_YEAR_X(1970)) * DAY_MS + 1,		2005 },

}

test("verify sanity of OpDate::YearFromTime")
{
	iterate (t, expected_year) from yearfromtime
	{
		int actual_year = OpDate::YearFromTime(t);
#if 0
		time_t t_as_time_t = static_cast<time_t>(t/1000);
		char* timestamp = ctime(&t_as_time_t);
		op_strstr(timestamp, "\n")[0] = 0;
		printf ("\ntimestamp == '%s',  t == %21.6f,  expected == %d,  actual == %d,  equal == %s   ", timestamp, t, expected_year, actual_year, (actual_year == expected_year) ? "yes" : "NO THEY DONT MATCH");
#endif
		verify(actual_year == expected_year);
	}
}

test("Verify size of time_t")
{
	// This test will verify that the STDLIB_SIXTY_FOUR_BIT_TIME_T macro
	// correctly reflects the size of the 'time_t' system type.
	//
	// It needs to reflect the actual size of the 'time_t' system type
	// in order for one or more of the stdlib function to work correctly.
	//
	// If this test fails because the default value of the macro
	// STDLIB_SIXTY_FOUR_BIT_TIME_T is somehow incorrect, the tweak
	// TWEAK_STDLIB_SIXTY_FOUR_BIT_TIME_T (in the stdlib module) can
	// be applied to override the default assumption of having 64-bit
	// time_t on 64-bit systems, and 32-bit time_t on 32-bit systems.

#if STDLIB_SIXTY_FOUR_BIT_TIME_T
	verify(sizeof(time_t) == 8);
#else
	verify(sizeof(time_t) == 4);
#endif
}

table Times(time_t, int, int, int, int, int, int, int, int, int)
{
	/*
	 * Order of fields is order specified in the ANSI C '89 library spec for
	 * struct tm.  GMT has no DST, so gmtime should always yield 0 for isdst.
	 *      time, sec, min, hour, mday, mon, year, wday, yday, isdst
	 */

	/* Positive 32-bit time_t values */
	{           0,  0,   0,    0,    1,   0,   70,    4,    0, 0 },
	{           1,  1,   0,    0,    1,   0,   70,    4,    0, 0 },
	{     5097599, 59,  59,   23,   28,   1,   70,    6,   58, 0 },
	{     5097600,  0,   0,    0,    1,   2,   70,    0,   59, 0 },
	{    31535999, 59,  59,   23,   31,  11,   70,    4,  364, 0 },
	{    31536000,  0,   0,    0,    1,   0,   71,    5,    0, 0 },
	{    36633599, 59,  59,   23,   28,   1,   71,    0,   58, 0 },
	{    36633600,  0,   0,    0,    1,   2,   71,    1,   59, 0 },
	{    63071999, 59,  59,   23,   31,  11,   71,    5,  364, 0 },
	{    63072000,  0,   0,    0,    1,   0,   72,    6,    0, 0 },
	{    68169599, 59,  59,   23,   28,   1,   72,    1,   58, 0 },
	{    68169600,  0,   0,    0,   29,   1,   72,    2,   59, 0 },
	{    68255999, 59,  59,   23,   29,   1,   72,    2,   59, 0 },
	{    68256000,  0,   0,    0,    1,   2,   72,    3,   60, 0 },
	{    94694399, 59,  59,   23,   31,  11,   72,    0,  365, 0 },
	{    94694400,  0,   0,    0,    1,   0,   73,    1,    0, 0 },
	{    99791999, 59,  59,   23,   28,   1,   73,    3,   58, 0 },
	{    99792000,  0,   0,    0,    1,   2,   73,    4,   59, 0 },
	{   126230399, 59,  59,   23,   31,  11,   73,    1,  364, 0 },
	{   126230400,  0,   0,    0,    1,   0,   74,    2,    0, 0 },
	{   131327999, 59,  59,   23,   28,   1,   74,    4,   58, 0 },
	{   131328000,  0,   0,    0,    1,   2,   74,    5,   59, 0 },
	{   157766399, 59,  59,   23,   31,  11,   74,    2,  364, 0 },
	{   157766400,  0,   0,    0,    1,   0,   75,    3,    0, 0 },
	{   162863999, 59,  59,   23,   28,   1,   75,    5,   58, 0 },
	{   162864000,  0,   0,    0,    1,   2,   75,    6,   59, 0 },
	{   189302399, 59,  59,   23,   31,  11,   75,    3,  364, 0 },
	{   189302400,  0,   0,    0,    1,   0,   76,    4,    0, 0 },
	{   194399999, 59,  59,   23,   28,   1,   76,    6,   58, 0 },
	{   194400000,  0,   0,    0,   29,   1,   76,    0,   59, 0 },
	{   194486399, 59,  59,   23,   29,   1,   76,    0,   59, 0 },
	{   194486400,  0,   0,    0,    1,   2,   76,    1,   60, 0 },
	{   220924799, 59,  59,   23,   31,  11,   76,    5,  365, 0 },
	{   220924800,  0,   0,    0,    1,   0,   77,    6,    0, 0 },
	{   226022399, 59,  59,   23,   28,   1,   77,    1,   58, 0 },
	{   226022400,  0,   0,    0,    1,   2,   77,    2,   59, 0 },
	{   252460799, 59,  59,   23,   31,  11,   77,    6,  364, 0 },
	{   252460800,  0,   0,    0,    1,   0,   78,    0,    0, 0 },
	{   257558399, 59,  59,   23,   28,   1,   78,    2,   58, 0 },
	{   257558400,  0,   0,    0,    1,   2,   78,    3,   59, 0 },
	{   283996799, 59,  59,   23,   31,  11,   78,    0,  364, 0 },
	{   283996800,  0,   0,    0,    1,   0,   79,    1,    0, 0 },
	{   289094399, 59,  59,   23,   28,   1,   79,    3,   58, 0 },
	{   289094400,  0,   0,    0,    1,   2,   79,    4,   59, 0 },
	{   315532799, 59,  59,   23,   31,  11,   79,    1,  364, 0 },
	{   315532800,  0,   0,    0,    1,   0,   80,    2,    0, 0 },
	{   320630399, 59,  59,   23,   28,   1,   80,    4,   58, 0 },
	{   320630400,  0,   0,    0,   29,   1,   80,    5,   59, 0 },
	{   320716799, 59,  59,   23,   29,   1,   80,    5,   59, 0 },
	{   320716800,  0,   0,    0,    1,   2,   80,    6,   60, 0 },
	{   347155199, 59,  59,   23,   31,  11,   80,    3,  365, 0 },
	{   347155200,  0,   0,    0,    1,   0,   81,    4,    0, 0 },
	{   352252799, 59,  59,   23,   28,   1,   81,    6,   58, 0 },
	{   352252800,  0,   0,    0,    1,   2,   81,    0,   59, 0 },
	{   378691199, 59,  59,   23,   31,  11,   81,    4,  364, 0 },
	{   378691200,  0,   0,    0,    1,   0,   82,    5,    0, 0 },
	{   383788799, 59,  59,   23,   28,   1,   82,    0,   58, 0 },
	{   383788800,  0,   0,    0,    1,   2,   82,    1,   59, 0 },
	{    10000019, 59,  46,   17,   26,   3,   70,    0,  115, 0 },
	{    20000038, 58,  33,   11,   20,   7,   70,    4,  231, 0 },
	{    30000057, 57,  20,    5,   14,  11,   70,    1,  347, 0 },
	{    40000076, 56,   7,   23,    8,   3,   71,    4,   97, 0 },
	{    50000095, 55,  54,   16,    2,   7,   71,    1,  213, 0 },
	{    60000114, 54,  41,   10,   26,  10,   71,    5,  329, 0 },
	{    70000133, 53,  28,    4,   21,   2,   72,    2,   80, 0 },
	{    80000152, 52,  15,   22,   14,   6,   72,    5,  195, 0 },
	{    90000171, 51,   2,   16,    7,  10,   72,    2,  311, 0 },
	{   100000190, 50,  49,    9,    3,   2,   73,    6,   61, 0 },
	{   110000209, 49,  36,    3,   27,   5,   73,    3,  177, 0 },
	{   120000228, 48,  23,   21,   20,   9,   73,    6,  292, 0 },
	{   130000247, 47,  10,   15,   13,   1,   74,    3,   43, 0 },
	{   140000266, 46,  57,    8,    9,   5,   74,    0,  159, 0 },
	{   150000285, 45,  44,    2,    3,   9,   74,    4,  275, 0 },
	{   160000304, 44,  31,   20,   26,   0,   75,    0,   25, 0 },
	{   170000323, 43,  18,   14,   22,   4,   75,    4,  141, 0 },
	{   180000342, 42,   5,    8,   15,   8,   75,    1,  257, 0 },
	{   190000361, 41,  52,    1,    9,   0,   76,    5,    8, 0 },
	{   200000380, 40,  39,   19,    3,   4,   76,    1,  123, 0 },
	{   210000399, 39,  26,   13,   27,   7,   76,    5,  239, 0 },
	{   220000418, 38,  13,    7,   21,  11,   76,    2,  355, 0 },
	{   230000437, 37,   0,    1,   16,   3,   77,    6,  105, 0 },
	{   240000456, 36,  47,   18,    9,   7,   77,    2,  220, 0 },
	{   250000475, 35,  34,   12,    3,  11,   77,    6,  336, 0 },
	{   260000494, 34,  21,    6,   29,   2,   78,    3,   87, 0 },
	{   270000513, 33,   8,    0,   23,   6,   78,    0,  203, 0 },
	{   280000532, 32,  55,   17,   15,  10,   78,    3,  318, 0 },
	{   290000551, 31,  42,   11,   11,   2,   79,    0,   69, 0 },
	{   300000570, 30,  29,    5,    5,   6,   79,    4,  185, 0 },
	{   310000589, 29,  16,   23,   28,   9,   79,    0,  300, 0 },
	{   320000608, 28,   3,   17,   21,   1,   80,    4,   51, 0 },
	{   330000627, 27,  50,   10,   16,   5,   80,    1,  167, 0 },
	{   340000646, 26,  37,    4,   10,   9,   80,    5,  283, 0 },
	{   350000665, 25,  24,   22,    2,   1,   81,    1,   32, 0 },
	{   360000684, 24,  11,   16,   29,   4,   81,    5,  148, 0 },
	{   370000703, 23,  58,    9,   22,   8,   81,    2,  264, 0 },
	{   380000722, 22,  45,    3,   16,   0,   82,    6,   15, 0 },
	{   390000741, 21,  32,   21,   11,   4,   82,    2,  130, 0 },
	{   400000760, 20,  19,   15,    4,   8,   82,    6,  246, 0 },
	{   946684800,  0,   0,    0,    1,   0,  100,    6,    0, 0 },
	{   951825600,  0,   0,   12,   29,   1,  100,    2,   59, 0 },
	{  1169852400,  0,   0,   23,   26,   0,  107,    5,   25, 0 },
	{  1172397272, 32,  54,    9,   25,   1,  107,    0,   55, 0 },
	{  1174942144,  4,  49,   20,   26,   2,  107,    1,   84, 0 },
	{  1177487016, 36,  43,    7,   25,   3,  107,    3,  114, 0 },
	{  1180031888,  8,  38,   18,   24,   4,  107,    4,  143, 0 },
	{  1182576760, 40,  32,    5,   23,   5,  107,    6,  173, 0 },
	{  1185121632, 12,  27,   16,   22,   6,  107,    0,  202, 0 },
	{  1187666504, 44,  21,    3,   21,   7,  107,    2,  232, 0 },
	{  1190211376, 16,  16,   14,   19,   8,  107,    3,  261, 0 },
	{  1192756248, 48,  10,    1,   19,   9,  107,    5,  291, 0 },
	{  1195301120, 20,   5,   12,   17,  10,  107,    6,  320, 0 },
	{  1197845992, 52,  59,   22,   16,  11,  107,    0,  349, 0 },
	{  2147483647,  7,  14,    3,   19,   0,  138,    2,   18, 0 },
	{  1204243200,  0,   0,    0,   29,   1,  108,    5,   59, 0 },
	{  1235865600,  0,   0,    0,    1,   2,  109,    0,   59, 0 },
	{  1500000000,  0,  40,    2,   14,   6,  117,    5,  194, 0 },
	{  1750000000, 40,   6,   15,   15,   5,  125,    0,  165, 0 },
	{  1900000000, 40,  46,   17,   17,   2,  130,    0,   75, 0 },
	{  2100000000,  0,  20,   13,   18,   6,  136,    5,  199, 0 },
	{  2114380800,  0,   0,    0,    1,   0,  137,    4,    0, 0 },
	{  2119478400,  0,   0,    0,    1,   2,  137,    0,   59, 0 },
	{  2145916799, 59,  59,   23,   31,  11,  137,    4,  364, 0 },
	{  2145916800,  0,   0,    0,    1,   0,  138,    5,    0, 0 },

#if STDLIB_SIXTY_FOUR_BIT_TIME_T || defined(STDLIB_UNSIGNED_TIME_T)
	/* Large unsigned 32-bit time_t values, or 64-bit time_t */
	{  2148552000,  0,   0,   12,   31,   0,  138,    0,   30, 0 },
	{  2148638400,  0,   0,   12,    1,   1,  138,    1,   31, 0 },
	{  4102444800,  0,   0,    0,    1,   0,  200,    5,    0, 0 },
	{  4107542399, 59,  59,   23,   28,   1,  200,    0,   58, 0 },
	{  4107542400,  0,   0,    0,    1,   2,  200,    1,   59, 0 },
	{  4133980799, 59,  59,   23,   31,  11,  200,    5,  364, 0 },
	{  4133980800,  0,   0,    0,    1,   0,  201,    6,    0, 0 },
	{  4294967295, 15,  28,    6,    7,   1,  206,    0,   37, 0 },
#endif

#ifndef STDLIB_UNSIGNED_TIME_T
	/* Negative 32-bit time_t values */
	{          -1, 59,  59,   23,   31,  11,   69,    3,  364, 0 },
	{   -41341500,  0,  15,   12,    9,   8,   68,    1,  252, 0 },
	{ -2147472000,  0,   0,    0,   14,  11,    1,    6,  347, 0 },
	{ -2145916800,  0,   0,    0,    1,   0,    2,    3,    0, 0 },
	{ -2147483647, 53,  45,   20,   13,  11,    1,    5,  346, 0 },
	{ -2145916800,  0,   0,    0,    1,   0,    2,    3,    0, 0 },
	{ -2140819201, 59,  59,   23,   28,   1,    2,    5,   58, 0 },
	{ -2140819200,  0,   0,    0,    1,   2,    2,    6,   59, 0 },
	{ -2114380801, 59,  59,   23,   31,  11,    2,    3,  364, 0 },
	{ -2114380800,  0,   0,    0,    1,   0,    3,    4,    0, 0 },
	{ -2109283201, 59,  59,   23,   28,   1,    3,    6,   58, 0 },
	{ -2109283200,  0,   0,    0,    1,   2,    3,    0,   59, 0 },
	{ -2082844801, 59,  59,   23,   31,  11,    3,    4,  364, 0 },
	{ -2082844800,  0,   0,    0,    1,   0,    4,    5,    0, 0 },
	{ -2077747201, 59,  59,   23,   28,   1,    4,    0,   58, 0 },
	{ -2077747200,  0,   0,    0,   29,   1,    4,    1,   59, 0 },
	{ -2077660801, 59,  59,   23,   29,   1,    4,    1,   59, 0 },
	{ -2077660800,  0,   0,    0,    1,   2,    4,    2,   60, 0 },
	{ -2051222401, 59,  59,   23,   31,  11,    4,    6,  365, 0 },
	{ -2051222400,  0,   0,    0,    1,   0,    5,    0,    0, 0 },
	{ -2046124801, 59,  59,   23,   28,   1,    5,    2,   58, 0 },
	{ -2046124800,  0,   0,    0,    1,   2,    5,    3,   59, 0 },
	{ -2019686401, 59,  59,   23,   31,  11,    5,    0,  364, 0 },
	{ -2019686400,  0,   0,    0,    1,   0,    6,    1,    0, 0 },
	{ -2014588801, 59,  59,   23,   28,   1,    6,    3,   58, 0 },
	{ -2014588800,  0,   0,    0,    1,   2,    6,    4,   59, 0 },
	{ -2145916800,  0,   0,    0,    1,   0,    2,    3,    0, 0 },
	{ -2140819201, 59,  59,   23,   28,   1,    2,    5,   58, 0 },
	{ -2140819200,  0,   0,    0,    1,   2,    2,    6,   59, 0 },
	{ -2114380801, 59,  59,   23,   31,  11,    2,    3,  364, 0 },
	{ -2114380800,  0,   0,    0,    1,   0,    3,    4,    0, 0 },
	{ -2109283201, 59,  59,   23,   28,   1,    3,    6,   58, 0 },
	{ -2109283200,  0,   0,    0,    1,   2,    3,    0,   59, 0 },
#endif

#if STDLIB_SIXTY_FOUR_BIT_TIME_T
	/* Larger 64-bit time_t values */
	{  7258118400,  0,   0,    0,    1,   0,  300,    3,    0, 0 },
#endif
}

test("op_gmtime")
{
	iterate (t, sec, min, hour, mday, mon, year, wday, yday, isdst) from Times
	{
		struct tm* res = op_gmtime(&t);
		verify(res->tm_year == year);
		verify(res->tm_yday == yday);
		verify(res->tm_mon == mon);
		verify(res->tm_mday == mday);
		verify(res->tm_wday == wday);
		verify(res->tm_isdst == isdst);
		verify(res->tm_hour == hour);
		verify(res->tm_min == min);
		verify(res->tm_sec == sec);
	}
}

table RFC3339Dates(const uni_char*, int, int, int, int, int, int, int)
{
	{ UNI_L("1968-09-09T12:45:55.123Z"),
			1968, 8, 9, 12, 45, 55, 123 },
	{ UNI_L("1967-09-09T12:45:55.123Z"),
			1967, 8, 9, 12, 45, 55, 123 },
	{ UNI_L("1966-09-09T12:45:55.123Z"),
			1966, 8, 9, 12, 45, 55, 123 },
	{ UNI_L("1965-09-09T12:45:55.123Z"),
			1965, 8, 9, 12, 45, 55, 123 },
	{ UNI_L("1964-09-09T12:45:55.123Z"),
			1964, 8, 9, 12, 45, 55, 123 },
	{ UNI_L("1963-09-09T12:45:55.123Z"),
			1963, 8, 9, 12, 45, 55, 123 },
	{ UNI_L("2008-12-24T17:00:00+01:00"),
			2008, 11, 24, 16, 0, 0, 0 },
	{ UNI_L("2000-01-01T12:00:00-00:30"),
			2000, 0, 1, 12, 30, 0, 0 },
	{ UNI_L("2000-01-01T12:00:00-01:00"),
			2000, 0, 1, 13, 0, 0, 0 },
	{ UNI_L("2000-01-01T12:00:00-01:30"),
			2000, 0, 1, 13, 30, 0, 0 },
	{ UNI_L("1937-11-30T12:05:27.871-03:20"),
			1937, 10, 30, 15, 25, 27, 871 },

	// Valid ISO dates (Full range of month-days)
	{ UNI_L("2008-01-01T00:00:00.000Z"), // January
			2008, 0, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-01-31T00:00:00.000Z"),
			2008, 0, 31, 0, 0, 0, 0 },


	{ UNI_L("2008-02-01T00:00:00.000Z"), // February
			2008, 1, 1, 0, 0, 0, 0 },
	{ UNI_L("2000-02-29T00:00:00.000Z"), // Every 400 year is a leap year
			2000, 1, 29, 0, 0, 0, 0 },
	{ UNI_L("2008-02-29T00:00:00.000Z"), // Every 4 year is a leap year
			2008, 1, 29, 0, 0, 0, 0 },
	{ UNI_L("2009-02-28T00:00:00.000Z"), // ... which 2009 isn't
			2009, 1, 28, 0, 0, 0, 0 },

	{ UNI_L("2100-02-28T00:00:00.000Z"), // Every 100 year is not a leap year
			2100, 1, 28, 0, 0, 0, 0 },
	{ UNI_L("2200-02-28T00:00:00.000Z"),
			2200, 1, 28, 0, 0, 0, 0 },
	{ UNI_L("2300-02-28T00:00:00.000Z"),
			2300, 1, 28, 0, 0, 0, 0 },
	{ UNI_L("2400-02-29T00:00:00.000Z"), // ... but this one is again
			2400, 1, 29, 0, 0, 0, 0 },

	{ UNI_L("2008-03-01T00:00:00.000Z"), // March
			2008, 2, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-03-31T00:00:00.000Z"),
			2008, 2, 31, 0, 0, 0, 0 },

	{ UNI_L("2008-04-01T00:00:00.000Z"), // April
			2008, 3, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-04-30T00:00:00.000Z"),
			2008, 3, 30, 0, 0, 0, 0 },

	{ UNI_L("2008-05-01T00:00:00.000Z"), // May
			2008, 4, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-05-31T00:00:00.000Z"),
			2008, 4, 31, 0, 0, 0, 0 },

	{ UNI_L("2008-06-01T00:00:00.000Z"), // June
			2008, 5, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-06-30T00:00:00.000Z"),
			2008, 5, 30, 0, 0, 0, 0 },

	{ UNI_L("2008-07-01T00:00:00.000Z"), // July
			2008, 6, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-07-31T00:00:00.000Z"),
			2008, 6, 31, 0, 0, 0, 0 },

	{ UNI_L("2008-08-01T00:00:00.000Z"), // August
			2008, 7, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-08-31T00:00:00.000Z"),
			2008, 7, 31, 0, 0, 0, 0 },

	{ UNI_L("2008-09-01T00:00:00.000Z"), // September
			2008, 8, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-09-30T00:00:00.000Z"),
			2008, 8, 30, 0, 0, 0, 0 },

	{ UNI_L("2008-10-01T00:00:00.000Z"), // October
			2008, 9, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-10-31T00:00:00.000Z"),
			2008, 9, 31, 0, 0, 0, 0 },

	{ UNI_L("2008-11-01T00:00:00.000Z"), // November
			2008, 10, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-11-30T00:00:00.000Z"),
			2008, 10, 30, 0, 0, 0, 0 },

	{ UNI_L("2008-12-01T00:00:00.000Z"), // December
			2008, 11, 1, 0, 0, 0, 0 },
	{ UNI_L("2008-12-31T00:00:00.000Z"),
			2008, 11, 31, 0, 0, 0, 0 },
}

test("RFC 3339 date parsing")
{
	iterate (date, y, mo, d, h, mi, s, ms) from RFC3339Dates
	{
		double time = OpDate::ParseRFC3339Date(date);

		verify(OpDate::YearFromTime(time) == y);
		verify(OpDate::MonthFromTime(time) == mo); // Month is zero indexed
		verify(OpDate::DateFromTime(time) == d);
		verify(OpDate::HourFromTime(time) == h); // in GMT time
		verify(OpDate::MinFromTime(time) == mi);
		verify(OpDate::SecFromTime(time) == s);
		verify(OpDate::msFromTime(time) == ms);

		// Also check that ordinary date-parsing handles these dates as well
		double delta = time - OpDate::ParseDate(date);
		verify(delta == 0.0);
	}
}

table ES31ISODates(const char *, int, int, int, int, int, int, int)
{
	{ "1995",
			1995, 0, 1, 0, 0, 0, 0 },
	{ "1995-02",
			1995, 1, 1, 0, 0, 0, 0 },
	{ "1995T12:00",
			1995, 0, 1, 12, 0, 0, 0 },
	{ "1995T12:00Z",
			1995, 0, 1, 12, 0, 0, 0 },
	{ "1995T12:00+03:00",
			1995, 0, 1, 9, 0, 0, 0 },
	{ "1995T12:00-03:00",
			1995, 0, 1, 15, 0, 0, 0 },
	{ "1995T12:13:14",
			1995, 0, 1, 12, 13, 14, 0 },
	{ "1995-02T12:13:14.750",
			1995, 1, 1, 12, 13, 14, 750 },
	{ "1995-02T12:13:14.750Z",
			1995, 1, 1, 12, 13, 14, 750 },

	{ "1979-03-24T00:00:00Z",
			1979, 2, 24, 0, 0, 0, 0 },
	{ "1979-03-24T24:00:00Z",
			1979, 2, 25, 0, 0, 0, 0 },

	{ "1995-02T12:13:14.7Z",
			1995, 1, 1, 12, 13, 14, 700 },
	{ "1995-02T12:13:14.07Z",
			1995, 1, 1, 12, 13, 14, 70 },
	{ "1995-02T12:13:14.70Z",
			1995, 1, 1, 12, 13, 14, 700 },
	{ "1995-02T12:13:14.0Z",
			1995, 1, 1, 12, 13, 14, 0 },
	{ "1995-02T12:13:14.1000Z",
			1995, 1, 1, 12, 13, 14, 100 },
	{ "1995-02T12:13:14.10001222Z",
			1995, 1, 1, 12, 13, 14, 100 },
}

foreach (date, y, mo, d, h, mi, s, ms) from ES31ISODates
{
	test("Ecmascript ISO date parsing: " date)
	{
		OpString date_str; date_str.Set(date);
		double time = OpDate::ParseDate(date_str.CStr(), FALSE);

		verify(OpDate::YearFromTime(time) == y);
		verify(OpDate::MonthFromTime(time) == mo); // Month is zero indexed
		verify(OpDate::DateFromTime(time) == d);
		verify(OpDate::HourFromTime(time) == h); // in GMT time
		verify(OpDate::MinFromTime(time) == mi);
		verify(OpDate::SecFromTime(time) == s);
		verify(OpDate::msFromTime(time) == ms);
	}
}

table Dates(const uni_char *)
{
	{ UNI_L("Wednesday 2006-09-27 12:34:56 GMT"			) },
	{ UNI_L("09/27/2006 12:34:56 PM UTC"				) },
	{ UNI_L("Wednesday 27 September 2006 12:34:56 GMT"	) },
	{ UNI_L("Wednesday 27 September 2006 12:34:56 Z"	) },
	{ UNI_L("Wednesday 27 September 2006 12:34:56 UT"	) },
}

test("Arbitrary date parsing")
{
	iterate(date) from Dates
	{
		double time = OpDate::ParseDate(date);
		verify(OpDate::YearFromTime(time) == 2006);
		verify(OpDate::MonthFromTime(time) == 8); // Month is zero indexed
		verify(OpDate::DateFromTime(time) == 27);
		verify(OpDate::HourFromTime(time) == 12); // in GMT time
		verify(OpDate::MinFromTime(time) == 34);
		verify(OpDate::SecFromTime(time) == 56);
		verify(OpDate::msFromTime(time) == 0);
		verify(OpDate::WeekDay(time) == 3);
	}
}

table TZLessDates(const char *)
{
	{ "Wednesday 2006-09-27 12:34:56"		 },
	{ "09/27/2006 12:34:56 PM"				 },
	{ "Wednesday 27 September 2006 12:34:56" },
}

foreach (date) from TZLessDates
{
	test("Parsing dates without timezone: " date)
	{
		OpString date_str; date_str.Set(date);
		double time = OpDate::ParseDate(date_str.CStr());
		verify(OpDate::LocalTime(OpDate::UTC(time)) == time);
		verify(OpDate::YearFromTime(time) == 2006);
		verify(OpDate::MonthFromTime(time) == 8); // Month is zero indexed
		verify(OpDate::DateFromTime(time) >= 26 && OpDate::DateFromTime(time) <= 28);
		verify(OpDate::MinFromTime(time) == 34);
		verify(OpDate::SecFromTime(time) == 56);
		verify(OpDate::msFromTime(time) == 0);
		verify(OpDate::WeekDay(time) == 3);
		if (tz_less_dates_reference != -1)
		{
			verify(time == tz_less_dates_reference);
		}
		else
		{
			tz_less_dates_reference = time;
		}
	}
}

table IECompatibleDates(const uni_char *, int, int, int)
{
	// YMD (Y >= 70)
	{ UNI_L("70/10/33 12:00:00"),			1970, 10, 2 },
	{ UNI_L("99/12/99 12:00:00"),			2000,  2, 8 },
	{ UNI_L("1970/10/33 12:00:00"),			1970, 10, 2 },
	{ UNI_L("2006/10/33 12:00:00"),			2006, 10, 2 },
	{ UNI_L("2006/10/366 12:00:00"),		2007,  9, 1 },


	// MDY (M < 70)
	{ UNI_L("10/33/70 12:00:00"),			1970, 10, 2 },
	{ UNI_L("10/33/1970 12:00:00"),			1970, 10, 2 },
	{ UNI_L("69/68/67 12:00:00"),			1972, 10, 7 },

	// Long format
	{ UNI_L("32 October 2006 12:00:00"),	2006, 10, 1 },

	{ UNI_L("February/301/20  12:00"),		301, 1, 20 },
	{ UNI_L("February/20/301  12:00"),		301, 1, 20 },
	{ UNI_L("69/December/70   12:00"),		1971, 1, 7 },
	{ UNI_L("70/December/69   12:00"),		1971, 1, 7 },

	// These are strictly not for IE compatibility, but for completeness
	{ UNI_L("2009/28/February 12:00"),		2009, 1, 28 },
	{ UNI_L("28/2009/February 12:00"),		2009, 1, 28 },
}

test("IE compatible out-of-bounds parsing")
{
	iterate(date, year, month, day) from IECompatibleDates
	{
		double time = OpDate::ParseDate(date);
		int y = OpDate::YearFromTime(time);
		int m = OpDate::MonthFromTime(time);
		int d = OpDate::DateFromTime(time);

		verify(y == year);
		verify(m == month);
		verify(d == day);
	}
}

table LeapSecondTimestamps(const uni_char *, int, int, int, int, int, int)
{
	// 1972 had leap seconds in both June and December
	{ UNI_L("1972/06/30 23:59:59 UTC"),			1972, MONTH_JUN, 30, 23, 59, 59 },
	{ UNI_L("1972/06/30 23:59:60 UTC"),			1972, MONTH_JUL, 01, 00, 00, 00 },
	{ UNI_L("1972/06/30 23:59:61 UTC"),			1972, MONTH_JUL, 01, 00, 00, 01 },

	{ UNI_L("1972/12/31 23:59:59 UTC"),			1972, MONTH_DEC, 31, 23, 59, 59 },
	{ UNI_L("1972/12/31 23:59:60 UTC"),			1973, MONTH_JAN, 01, 00, 00, 00 },
	{ UNI_L("1972/12/31 23:59:61 UTC"),			1973, MONTH_JAN, 01, 00, 00, 01 },

	// 1973 had a leap second in December (but not in June)
	{ UNI_L("1973/06/30 23:59:59 UTC"),			1973, MONTH_JUN, 30, 23, 59, 59 },
	{ UNI_L("1973/06/30 23:59:60 UTC"),			1973, MONTH_JUL, 01, 00, 00, 00 },
	{ UNI_L("1973/06/30 23:59:61 UTC"),			1973, MONTH_JUL, 01, 00, 00, 01 },

	{ UNI_L("1973/12/31 23:59:59 UTC"),			1973, MONTH_DEC, 31, 23, 59, 59 },
	{ UNI_L("1973/12/31 23:59:60 UTC"),			1974, MONTH_JAN, 01, 00, 00, 00 },
	{ UNI_L("1973/12/31 23:59:61 UTC"),			1974, MONTH_JAN, 01, 00, 00, 01 },

	// 1980 had no leap seconds at all
	{ UNI_L("1980/06/30 23:59:59 UTC"),			1980, MONTH_JUN, 30, 23, 59, 59 },
	{ UNI_L("1980/06/30 23:59:60 UTC"),			1980, MONTH_JUL, 01, 00, 00, 00 },
	{ UNI_L("1980/06/30 23:59:61 UTC"),			1980, MONTH_JUL, 01, 00, 00, 01 },

	{ UNI_L("1980/12/31 23:59:59 UTC"),			1980, MONTH_DEC, 31, 23, 59, 59 },
	{ UNI_L("1980/12/31 23:59:60 UTC"),			1981, MONTH_JAN, 01, 00, 00, 00 },
	{ UNI_L("1980/12/31 23:59:61 UTC"),			1981, MONTH_JAN, 01, 00, 00, 01 },

	// 1981 has a leap second in June (but not in December)
	{ UNI_L("1981/06/30 23:59:59 UTC"),			1981, MONTH_JUN, 30, 23, 59, 59 },
	{ UNI_L("1981/06/30 23:59:60 UTC"),			1981, MONTH_JUL, 01, 00, 00, 00 },
	{ UNI_L("1981/06/30 23:59:61 UTC"),			1981, MONTH_JUL, 01, 00, 00, 01 },

	{ UNI_L("1981/12/31 23:59:59 UTC"),			1981, MONTH_DEC, 31, 23, 59, 59 },
	{ UNI_L("1981/12/31 23:59:60 UTC"),			1982, MONTH_JAN, 01, 00, 00, 00 },
	{ UNI_L("1981/12/31 23:59:61 UTC"),			1982, MONTH_JAN, 01, 00, 00, 01 },

	// Regression test from bug CORE-20386
	{ UNI_L("01/04/2009 01:01:60 UTC"),			2009, MONTH_JAN, 04, 01, 02, 00 },
}

/* Make sure leap second timestamps are _NOT_ treated specially.
 * Per ECMA-262 5th edition (DRAFT) section 15.9.1.1 leap seconds
 * should be ignored (thus we're treating them as normal overflowing
 * seconds; ensuring Firefox compatibility). */
test("Leap second timestamps")
{
	iterate(timestamp_string, year, month, day, hour, minute, second) from LeapSecondTimestamps
	{
		double time = OpDate::ParseDate(timestamp_string);
		int actual_year = OpDate::YearFromTime(time);
		int actual_month = OpDate::MonthFromTime(time);
		int actual_day = OpDate::DateFromTime(time);
		int actual_hour = OpDate::HourFromTime(time);
		int actual_minute = OpDate::MinFromTime(time);
		int actual_second = OpDate::SecFromTime(time);

		verify(actual_year == year);
		verify(actual_month == month);
		verify(actual_day == day);
		verify(actual_hour == hour);
		verify(actual_minute == minute);
		verify(actual_second == second);
	}
}

table InvalidDates(const uni_char*)
{
	{ UNI_L("Not a date") },
	{ UNI_L("The answer is 21 times 2") },
	{ UNI_L("January 1") },
	{ UNI_L("11/12") },
	{ UNI_L("1 Jan Jan 70") },
	{ UNI_L("1 Jan 70 70") },
	{ UNI_L("1 Jan 70 1") },
	{ UNI_L("1/1/70 1/1/70") },
	{ UNI_L("1/1/70 12:00 12:00") },
	{ UNI_L("1/1/70 12:00PM PM") },
	{ UNI_L("1/1/70 12:00 AM PM") },
	{ UNI_L("1/1/70 12:00 -0100 +0100") },
	{ UNI_L("1/1/70 12:13:14: GMT") },

	// ISO dates does not allow out-of range values
	{ UNI_L("2008-00-01") },
	{ UNI_L("2008-01-00") },
	{ UNI_L("2008-01-32") },

	{ UNI_L("2000-02-30") }, // Every 400 year is a leap year
	{ UNI_L("2008-02-30") }, // Every 4 years is a leap year
	{ UNI_L("2009-02-29") }, // ... which 2009 isn't
	{ UNI_L("2100-02-29") }, // Every 100 year is not a leap year
	{ UNI_L("2200-02-29") },
	{ UNI_L("2300-02-29") },
	{ UNI_L("2400-02-30") }, // ... but this one is again (every 400 years)

	{ UNI_L("2008-03-32") },
	{ UNI_L("2008-04-31") },
	{ UNI_L("2008-05-32") },
	{ UNI_L("2008-06-31") },
	{ UNI_L("2008-07-32") },
	{ UNI_L("2008-08-32") },
	{ UNI_L("2008-09-31") },
	{ UNI_L("2008-10-32") },
	{ UNI_L("2008-11-31") },
	{ UNI_L("2008-12-32") },
	{ UNI_L("2008-13-01") },

	// ISO dates with illegal time
	{ UNI_L("2005-01-01T24:00:00.001Z") },
	{ UNI_L("2005-01-01T24:00:00.001") },
	{ UNI_L("2005-01-01T24:00:01.000Z") },
	{ UNI_L("2005-01-01T24:01:00.000Z") },
	{ UNI_L("2005-01-01T23:60:00.000Z") },
	{ UNI_L("2005-01-01T23:00:61.000Z") },

	// ISO dates with syntax errors in date fields
	{ UNI_L("999-01-01T12:00:00.000Z") },
	{ UNI_L("2005-1-01T12:00:00.000Z") },
	{ UNI_L("2005-01-1T12:00:00.000Z") },
	{ UNI_L("02005-01-01T12:00:00.000Z") },
	{ UNI_L("2005-012-01T12:00:00.000Z") },
	{ UNI_L("2005-01-030T12:00:00.000Z") },
	{ UNI_L("999-01-01 1/1/70") },
	{ UNI_L("2005-1-01 1/1/70") },
	{ UNI_L("2005-01-1 1/1/70") },
	{ UNI_L("02005-01-01 1/1/70") },
	{ UNI_L("2005-012-01 1/1/70") },
	{ UNI_L("2005-01-030 1/1/70") },

	// ISO dates with syntax errors in time fields
	{ UNI_L("2005-01-01T1:00:00.000Z") },
	{ UNI_L("2005-01-01T012:00:00.000Z") },
	{ UNI_L("2005-01-01T12:1:00.000Z") },
	{ UNI_L("2005-01-01T12:010:00.000Z") },
	{ UNI_L("2005-01-01T12:00:1.000Z") },
	{ UNI_L("2005-01-01T12:00:010.000Z") },
	{ UNI_L("2005-01-01T12:00:00.000U") },
	{ UNI_L("2005-01-01T12:00:00.0011") },
	{ UNI_L("2005-01-01T12:00:00.01") },

	// ISO dates with syntax errors in timezone (and beyond) fields
	{ UNI_L("2005-01-01T21:22:23z") },
	{ UNI_L("2005-01-01T21:22:23ZU") },
	{ UNI_L("2005-01-01T21:22:23MOON") },
	{ UNI_L("2005-01-01T21:22:23Z ") },
	{ UNI_L("2005-01-01T21:22:23 Z ") },
	{ UNI_L("2005-01-01T21:22:23Z\t\r\n") },
	{ UNI_L("2005-01-01T21:22:23GMZ") },
	{ UNI_L("2005-01-01T21:22:23GMZ ") },

	// ISO dates with invalid leading whitespace
	{ UNI_L(" 2005-01-01T21:22:23Z") },
	{ UNI_L("  2005-01-01T21:22:23ZU") },
	{ UNI_L("\t 2005-01-01T21:22:23ZU") },
	{ UNI_L("\t\r\n2005-01-01T21:22:23ZU") }
}

test("Invalid date parsing")
{
	iterate(date) from InvalidDates
	{
		double invalidtime = OpDate::ParseDate(date);
		verify(op_isnan(invalidtime));
	}
}

table ValidDates(const uni_char*, int, int, int, int, int, int)
{
	{ UNI_L("1/1/70 12: GMT"), 1970, 0, 1, 12, 0, 0 },
	{ UNI_L("1/1/70 12:13: GMT"), 1970, 0, 1, 12, 13, 0 },
	{ UNI_L("1/1/70 12:13:14 GMT"), 1970, 0, 1, 12, 13, 14 }
}

test("Valid date parsing")
{
	iterate(date, y, mo, d, h, mi, s) from ValidDates
	{
		double time = OpDate::ParseDate(date);

		verify(OpDate::YearFromTime(time) == y);
		verify(OpDate::MonthFromTime(time) == mo); // Month is zero indexed
		verify(OpDate::DateFromTime(time) == d);
		verify(OpDate::HourFromTime(time) == h); // in GMT time
		verify(OpDate::MinFromTime(time) == mi);
		verify(OpDate::SecFromTime(time) == s);
	}
}

test("Bug#265156: Do not parse stray numbers as timezone")
	disabled;
{
	double parsed = OpDate::ParseDate(UNI_L("1999/01/09 10 GMT+0100"));
	double reference = OpDate::ParseRFC3339Date(UNI_L("1999-01-09T00:00:00+01:00"));
	// Older versions gave "1999-01-09T10:00:00+0100"
	//                                 ^^
	verify(parsed == reference);
}

test("MakeTime")
{
	double time = OpDate::MakeTime(1, 2, 3, 4);
	verify(OpDate::HourFromTime(time) == 1);
	verify(OpDate::MinFromTime(time)  == 2);
	verify(OpDate::SecFromTime(time)  == 3);
	verify(OpDate::msFromTime(time)   == 4);
}

test("MakeTime sanity")
{
	verify(!op_isfinite(OpDate::MakeTime(nan, 2, 3, 4)));
	verify(!op_isfinite(OpDate::MakeTime(1, nan, 3, 4)));
	verify(!op_isfinite(OpDate::MakeTime(1, 2, nan, 4)));
	verify(!op_isfinite(OpDate::MakeTime(1, 2, 3, nan)));
}

test("MakeDay and MakeDate")
{
	double time =
		OpDate::MakeDate(OpDate::MakeDay(2006, 9, 31), OpDate::MakeTime(1, 2, 3, 4));
	verify(OpDate::YearFromTime(time)  == 2006);
	verify(OpDate::MonthFromTime(time) == 9);
	verify(OpDate::DateFromTime(time)  == 31);
	verify(OpDate::HourFromTime(time)  == 1);
	verify(OpDate::MinFromTime(time)   == 2);
	verify(OpDate::SecFromTime(time)   == 3);
	verify(OpDate::msFromTime(time)    == 4);
}

test("MakeDay sanity")
{
	verify(!op_isfinite(OpDate::MakeDay(nan,  9,   31)));
	verify(!op_isfinite(OpDate::MakeDay(2006, nan, 31)));
	verify(!op_isfinite(OpDate::MakeDay(2006, 9,  nan)));
}

test("MakeDate sanity")
{
	verify(!op_isfinite(OpDate::MakeDate(nan, OpDate::MakeTime(1, 2, 3, 4))));
	verify(!op_isfinite(OpDate::MakeDate(OpDate::MakeDay(2006, 9, 31), nan)));
}

test("op_time")
{
	verify(op_time(NULL) != 0);

	time_t t1, t2;
	t2 = op_time(&t1);
	verify( t1 == t2 );
}

test("op_localtime, op_gmtime, op_mktime")
{
	struct tm origtime;
	origtime.tm_hour = 12;
	origtime.tm_min  = 13;
	origtime.tm_sec  = 14;
	origtime.tm_year = 106; /* 2006 */
	origtime.tm_mon  = 9; /* October */
	origtime.tm_mday = 10;
	origtime.tm_isdst = -1;

	time_t timeref = op_mktime(&origtime);
	verify(timeref > 0); // All we can say, really
	verify(origtime.tm_yday == 282); /* Calculated by mktime */
	verify(origtime.tm_wday == 2); /* Calculated by mktime */

	origtime.tm_sec ++;
	verify(op_mktime(&origtime) > timeref);
	origtime.tm_sec --; /* restore for later tests */

	struct tm *newtime_p = op_localtime(&timeref);
	verify(newtime_p);
	verify(newtime_p->tm_year == origtime.tm_year);
	verify(newtime_p->tm_mon  == origtime.tm_mon);
	verify(newtime_p->tm_mday == origtime.tm_mday);
	verify(newtime_p->tm_hour == origtime.tm_hour);
	verify(newtime_p->tm_min  == origtime.tm_min);
	verify(newtime_p->tm_sec  == origtime.tm_sec);

	struct tm savetime = *newtime_p;
	newtime_p = op_gmtime(&timeref);
	verify(newtime_p);
	verify(newtime_p->tm_year == savetime.tm_year);
	verify(newtime_p->tm_mon  == savetime.tm_mon);
	verify(newtime_p->tm_min  == savetime.tm_min);
	verify(newtime_p->tm_sec  == savetime.tm_sec);
	verify(newtime_p->tm_wday == savetime.tm_wday);
}
