<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
          "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<link rel=stylesheet href="../../coredoc/coredoc.css" />
<title>Module: Upload</title>
</head>

<body>

<h1>Module: Upload</h1>

<h2>About this module</h2>

The Upload module encodes mailmessages and HTTP form upload
<p>
Supported protocols:
<p>
<UL>
<li> <a href="http://www.ietf.org/rfc/rfc2045.txt">MIME 1</a> <a href="http://www.ietf.org/rfc/rfc2046.txt">2</a>  <a href="http://www.ietf.org/rfc/rfc2047.txt">3</a> <a href="http://www.ietf.org/rfc/rfc2048.txt">4</a>   <a href="http://www.ietf.org/rfc/rfc2049.txt">5</a>
<li> <a href="http://www.ietf.org/rfc/rfc2231.txt">RFC 2231</a>
</UL>


<h2>Interface overview and API documentation</h2>

<h3>Upload classes</h3>

<p> The Upload classes (derived from Upload_Base) are used to construct and generate various forms of MIME formatted bodies for transmission either through HTTP (HTTP requests are based on the Upload classes), SMTP, NNTP or other formats.</p>

<p> Upload_Base maintains the list of headers and manages the overall generation process, while subclasses perform payload operations.</p>

<h2>Implementation description</h2>

<p><a href="all/index.html">API documentation generated by
Doxygen</a> contains information about the internal organization of the module.</p>

<p>The module is moderately large</p>

<p>Various features can be enabled or disabled, either through feature defines or specific defines</p>

<h3>Dynamic memory use and OOM handling</h3>

<dl>
<dt>OOM policies
<dd><p>Most of the functions LEAVE in case of OOM</p>

<dt>Who handles OOM?
<dd>In the case of LEAVE functions the caller must TRAP the errors, and handle the OOM situations. In the case of the internal functions these usually aborts their operation with an error message, and a raised status flag, which must be handled either by the caller, or the document.

<dt>Flow
<dd><p>Most of the module is client pull based, and OOM is reported to the caller</p>

<dt>Heap memory usage
<dd>

<p> Upload elements are usually not kept for long, and their allocated size depends on the number of elements and actual bodysize.

<dt>Stack memory usage
<dd><p>Usually large objects are allocated. In some cases sizeable objects are placed on the stack but only for shorter periods.</p> 
<p>In most cases stack consumption should be less than 300 bytes.</p>

<dt>Static memory usage
<dd><p>The module does not use global variables, but few small const arrays exist</p>

<dt>Caching and freeing memory
<dd><p>No caching is performed. All storage is for the current request and only lives as long as the owner permits it.</p>

<dt>Freeing memory on exit
<dd><p>No persistent memory is allocated by the module. The owners of the Upload elements must make sure to delete the objects they have created.</p>

<dt>Temp buffers
<dd><p>The RFC 2231 header parameter construction use the shared TempBuf and TempBuf2 buffers. No check about previous use are made</p>

<dt>Memory tuning
<dd><p>At present there are no opportunities to tune memory use.</p>
	
<dt>Tests
<dd><p>Selftests, but they do not check memory usage.</p>

<dt>Coverage
<dd><p>Selftests, uploading files, posting forms, sending email, ordinary HTTP surfing.</p>

<dt>Design choices
<dd><p>Headers and uploade elements are implemented as lists to ease construction</p>


<dt>Improvements
<dd>

<p>No improvements planned</p>


</dl>

<h3>An overview of the module's implementation</h3>

<p>The central code is in Upload_Handler and Upload_Base with implementations adapted to specific use 
as sub-classes of the Upload_Handler class. The classes include 
<ul>
<li>Upload_OpString8 used for 8-bit string bodies
<li>Upload_EncapsulatedElement, used to encapsulate another Upload element and use it as a part of itself
<li>Upload_External_Body, and implementation of Upload_EncapsulatedElement
<li>Upload_URL, used to upload a document referenced by a URL
<li> Upload_BinaryBuffer, used to upload binary data
<li> Upload_Multipart, used to upload several uploade elements as a MIME multipart
</ul>

Headers are organized as lists of individual headers that contain a list of parameters. Each parameter can be represented as a more complex implementation used to prepare the resulting header.

The primary API for adding headers and parameters are on the upload element.

It is possible to add pregenerated header blocks, but these are usually subject to filtering to avoid security problems.

The base classes extract and output the header informations as a header block, and then extract the actual content from the implementations into a caller created buffer. Repeated requests are often necessary to complete the process.
</p>
