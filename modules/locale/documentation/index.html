<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html lang="en" dir="ltr">
<head>
 <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
 <title>Locale module</title>
 <link rev="made" href="mailto:peter@opera.com">
 <link rel="stylesheet" href="../../coredoc/coredoc.css" type="text/css" media="all">
 <link rel="contents" href="../../coredoc/index.html" type="text/html" title="Core API">
 <style type="text/css">
  body { background: white; color: black; 
         quotes: '\201C' '\201D' '\2018' '\2019' '\201C' '\201D'; }
  ul#tocUl { list-style: none; padding-left: 0; }
 </style>
 <script type="text/javascript" src="../../coredoc/createtoc.js"></script>
</head>

<body>
 <h1>Locale module</h1>
 <p id="toc">
  Copyright 1995-2012 Opera Software ASA. All rights reserved.
  This file is part of the Opera web browser. It may not be distributed
  under any circumstances.
 </p>

 <h2 id="intro">Introduction</h2>
 <h3 id="localemodule">The locale module</h3>
 <p>
  The <em>Locale module</em> provides the
  <a href="api/classOpLanguageManager.html">OpLanguageManager</a>
  interface used to retrieve text strings used for display in the user
  interface in Opera.
  Nowhere in Opera may hard-coded strings be displayed in the user
  interface, except for debugging information and similar.
 </p>
 <p>
  The <a href="api/classOpLanguageManager.html">OpLanguageManager</a>
  defines the interface available to the Opera core.
  No platform-independent code must ever use any other methods than the
  ones defined in the <code>OpLanguageManager</code> interface.
 </p>

 <h3 id="buildsystem">The build system</h3>
 <p>
  The code in the locale module requires that certain scripts are set up to
  generate the relevant locale include files.
  These include files are generated by the
  <a href="../../hardcore/documentation/operasetup.html">operasetup
  script in hardcore</a>.
  You will also need to generate <strong>run-time or compile-time language
  files</strong> (depending on your platform), so that your program has
  access to the language strings at run time, please refer to the
  <a href="../../../data/translations/documentation/index.html#scripts-makelang">makelang
  documentation in the translations module</a> for information on how to
  do that.
 </p>
 <p>
  If you are interested in the internals of the <strong>build system for
  locale data</strong>, please refer to the
  <a href="../../../data/strings/documentation/index.html#buildsystem">strings
  module documentation on the build scripts</a>.
  The rest of the documentation here is for the language string
  <em>access</em> code.
 </p>

 <p>
  <a href="http://wiki.oslo.opera.com/developerwiki/index.php/Locale_module">Current
  information about the Locale module</a>.
 </p>

 <h2 id="api">
  Interface overview and
  <abbr title="Application programming interface">API</abbr>
  documentation
 </h2>
 <p>
  The
  <a href="api/index.html">API documentation</a>
  is extracted automatically by Doxygen.
 </p>

 <h2 id="usecases">Use-cases</h2>
 <h3 id="usecase-retrievingstring">Retrieving a string for use inside the
  core or in the UI</h3>
 <p>
  The normal use-case of this module is that the core or UI code requests
  a string, using the enumeration value defined in the
  <a href="api/classStr.html">Str</a> class.
  This is performed by calling the <code>GetStringL()</code> or
  <code>GetString()</code> methods on the
  <a href="api/classOpLanguageManager.html">g_languageManager</a>
  global object.
 </p>

 <h3 id="usecase-addingstring">Adding new language strings</h3>
 <p>
  If you need to add new language strings to the string database, please
  <a href="../../../data/strings/documentation/index.html#newstrings">refer
  to the documentation in the strings module</a>
  for details.
 </p>

 <h3 id="usecase-multiple">Supporting multiple languages at once</h3>
 <p>
  In some cases, the Opera engine needs to be able to have simultaneous
  support for several languages.
 </p>
 <p>
  When having to support <strong>different localizations in different
  concurrent windows</strong>, for example in Opera Mini, the locale module
  <a href="../module.export">exports the API <code>API_LOC_CONTEXTS</code></a>
  which enables the <code>OpLanguageManager::SetContext()</code> method.
  You will need to implement the context switching code in your platform
  implementation of the <code>OpLanguageManager</code> interface, however.
 </p>
 <p>
  If all you need is to be able to get strings from a &ldquo;fall-back
  language&rdquo; <strong>for strings that are missing in your
  translation</strong>, the standard APIs in the
  <a href="api/classOpPrefsFileLanguageManager.html">OpPrefsFileLanguageManager</a>
  implementation should be enough, it will load both the currently configured
  user language and what is designated the default in preferences (English).
 </p>
 <p>
  When you need to also have the strings from this fall-back <strong>available
  alongside the translated strings</strong>, for instance to generate menu
  shortcut letters for East Asian localizations, you should probably just
  instantiate your own copy of the
  <a href="api/classOpPrefsFileLanguageManager.html">OpPrefsFileLanguageManager</a>
  object and load the default translation into it.
  This way you will have fast access to the default strings, while the core
  code will use the selected localization for all the strings it needs.
 </p>

 <h2 id="standards">Supported standards</h2>
 <p>
  None.
  The <code>LNG</code> file format is however based on the standard Windows
  <code>INI</code> file format, with some extensions.
 </p>

 <h2 id="design">Implementation and design</h2>
 <h3 id="strlocalestring">The Str::LocaleString class</h3>
 <p>
  The <a href="api/classStr_1_1LocaleString.html">Str::LocaleString</a>
  class encapsulates a platform-independent way of identifying
  language strings, allowing the build system to define the necessary
  strings. Due to a limitation in Visual C++ where the sum of the debug
  information for enumerations is limited to 64kb, Str::LocaleString
  is defined as a class, and not an enumeration. The class wraps several
  actual enumerations.
 </p>

 <h3 id="generalisation">Generalisation and re-implementation</h3>
 <p>
  To avoid limiting all Opera platforms to using the same storage model
  for language strings, the abstract interface
  <a href="api/classOpLanguageManager.html">OpLanguageManager</a>
  is all the core code in Opera sees of the string handling.
  This interface can easily be re-implemented on different platforms,
  for example providing a version that read language strings from static
  resources instead of the normal, file-based, lookup.
 </p>
 <p>
  The
  <a href="api/classOpLanguageManager.html">OpLanguageManager</a>
  uses the enumeration of available strings provided by the
  <a href="../../../data/strings/documentation/index.html"><var>english.db</var>
  file</a> as described above.
  The numerical equivalents of the enumeration values are <em>not</em>
  used by the Opera core, and can easily be replaced for platforms
  requiring so, for example where the resource compiler itself maps
  numbers to resources.
 </p>
 <p>
  While the core code only is allowed to use the interface defined by
  <code>OpLanguageManager</code>, platform-specific code may of course use
  any special features available in their platform implementation.
 </p>
 <p>
  When re-implementing the interface, take care to make sure that your
  implementation passes all the selftests for this module. Core may
  behave in unexpected ways if it does not. Especially take care to
  ensure that the UniString object returns are properly
  reference-counted and do not go out of scope. This can be done by
  either using UniString as an internal storage model, or by always
  having the <code>GetString()</code> interface copy the string into
  the passed UniString object.
 </p>

 <h4 id="textfile">Text file based language manager</h4>
 <p>
  The
  <a href="api/classOpPrefsFileLanguageManager.html">OpPrefsFileLanguageManager</a>
  class defined in
  <code>modules/locale/src/opprefsfilelanguagemanager.h</code>
  is intended as a cross-platform
  implementation to be used by platforms.
  It implements the language support by loading a LNG file from disk.
  It is enabled by <code>FEATURE_LANGUAGE_FILE</code>.
 </p>

 <h4 id="binaryfile">Binary file based language manager</h4>
 <p>
  The
  <a href="api/classOpBinaryFileLanguageManager.html">OpBinaryFileLanguageManager</a>
  class defined in
  <code>modules/locale/src/opbinaryfilelanguagemanager.h</code>
  is intended for small systems where there is no requirement that the
  language files are human-readable.
  The files are stored in a pre-sorted binary format that can be read
  directly into memory without the need for costly
  postprocessing/conversion.
  It is enabled by <code>FEATURE_BINARY_LANGUAGE_FILE</code>.
</p>

 <h4 id="dummylanguage">Dummy language manager</h4>
 <p>
  For builds not requiring language files, or for use while building prototypes,
  there is a
  <a href="api/classOpDummyLanguageManager.html">OpDummyLanguageManager</a>
  class that will return empty
  strings for all requests.
  This version is enabled by defining
  <code>USE_DUMMY_LANGUAGEMANAGER</code>.
 </p>

 <h4 id="reimplementing">Re-implementing OpLanguageManager</h4>
 <p>
  Platforms that require different string handling can re-implement
  <a href="api/classOpLanguageManager.html">OpLanguageManager</a>
  Since the core code will never use the numerical ids, but only the
  <a href="api/classStr_1_1LocaleString.html">LocaleString</a>
  enumeration, platforms that need to have the
  enumeration generated elsewhere should be easy to accommodate.
 </p>
 <p>
  If platforms require the language strings available in a special format,
  these can easily be generated from the language database file, since it has
  a well-defined format.
 </p>

 <h3 id="initialisation">Initialisation</h3>
 <p>
  The locale module knows how to bootstrap itself for the provided
  implementations of the
  <a href="api/classOpLanguageManager.html">OpLanguageManager</a>
  interface.
  If your platform is using its own implementation, you will need to
  initialise it manually before calling <code>Opera::InitL()</code>
  by calling
  <code><a href="api/classLocaleModule.html">LocaleModule</a>::SetLanguageManager()</code>.
 </p>
 
 <h3 id="memorymanagement">Memory management</h3>
 <p>
  This discussion concerns the <code>OpPrefsFileLanguageManager</code>
  and <code>OpBinaryLanguageManager</code> implementations.
  The <code>OpDummyLanguageManager</code> implementation does not allocate
  any strings or use any memory beyond the global pointer.
 </p>

 <h4 id="memorymanagement-heap">Heap usage</h4>
 <p>
  The <code>OpPrefsFileLanguageManager</code> and
  <code>OpBinaryLanguageManager</code> implementations
  will read translation files from disk and store the strings in memory.
  By its very nature it needs to retain these allocated strings during the
  entire life-time of Opera, something which requires a careful design, so
  that the memory overhead is not too great, especially when considering
  smaller devices.
  The memory overhead must, however, be offset against the time consumed for
  string lookups, which are quite frequent.
 </p>
 <p>
  During the initial loading operation, the
  <code>OpPrefsFileLanguageManager</code>
  will use more than double the amount of memory it retains during normal
  execution.
  Here the language file is parsed and loaded into memory using the
  <code>PrefsFile</code> interface provided by the
  <a href="../../prefsfile/documentation/index.html">prefsfile module</a>.
  After the file has been loaded, <code>OpPrefsFileLanguageManager</code>
  will transfer it into its internal storage, which consists of a
  UniString object large enough to carry all the strings in the file,
  plus an array of indices with pointers to the strings inside the first
  array. When the loading is finished,
  <code>OpPrefsFileLanguageManager</code> will
  release the <code>PrefsFile</code> object and just keep its optimised
  storage area.
 </p>
 <p>
  <code>OpBinaryLanguageManager</code> does not require the extra overhead
  of loading, converting and copying the language strings, it will instead
  allocate an array of strings into which it will read the language strings
  directly from the language file, without using any intermediate storage.
  This means that the initialisation will have the overhead of the
  <code>OpFile</code> object needed for accessing the language file.
 </p>

 <p>
  The storage, which is proportional to the number and lengths of the
  strings, is kept in memory until the
  <code>OpPrefsFileLanguageManager</code> or
  <code>OpBinaryLanguageManager</code>
  objects are destroyed, which happens in <code>Opera::Destroy()</code>.
 </p>

 <h4 id="memorymanagement-stack">Stack usage</h4>
 <p>
  There are no recursive calls, and no arrays or large objects are allocated
  on the stack.
 </p>

 <h4 id="memorymanagement-static">Static memory usage</h4>
 <p>
  There is one global pointer, which is handled by the LocaleModule object.
 </p>

 <h4 id="memorymanagement-oom"><abbr title="Out of memory">OOM</abbr> policies</h4>
 <p>
  All of the interfaces to functionality that can require memory to be
  allocated is using the <code>TRAP</code>/<code>LEAVE</code>
  convention.
  There is, however, a convenience wrapper function for retrieving strings
  which instead returns a status code; it is implemented as a wrapper
  around the leaving interface.
  Inherited interfaces only implement the version using leave.
 </p>

 <h3 id="performance">Performance</h3>
 <p>
  The string lookup is realised by a binary search using an integer
  lookup key in the file-based language manager implementations,
  and should be quite fast.
  Due to the many possible implementations of the
  <code>OpLanguageManager</code> interface, all string lookups require
  data copying, and possible allocation (embedded in the use of the
  <code>OpString</code> class in the interface).
 </p>

 <h2 id="references">References</h2>
 <ul>
  <li><a href="../../prefsfile/documentation/index.html">Prefsfile module</a>
  <li><a href="../../../data/strings/documentation/index.html">Strings module</a>
  <li><a href="../../../data/translations/documentation/index.html">Translations module</a>
 </ul>

</body>
</html>
