<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>

<title>Doug Lea's malloc implementation</title>
<script type="text/css">
	.setting dt { font-family: monospace; }
</script>

</head>
<body>

<h1>Doug Lea's malloc implementation</h1>

<p> This module packages Doug Lea's <code>malloc</code> implementation and
extends it in various optional ways developed at Opera.  Its <a
href="api/index.html">API documentation</a> may be generated by running the
command <code>doxygen</code> in the <code>documentation/</code> sub-directory.  Its
<em>primary</em> API comprises the C standard library memory management
functions plus, for C++, the operators <code>new</code>, <code>new []</code>, <code>delete
[]</code> and <code>delete</code>.  It has a secondary API to manage its
initialization and shut-down; and, when compiled in single-block mode, to
interrogate the status of its single block of memory. </p>

<p> Since this module provides, at least in some of its configurations, the
memory allocation infrastructure relied upon by all other Opera code, including
during initialization and termination, it must be initialized first and shut
down last.  Consequently it does not participate in core-2's global Opera object
process, but is rather part of the OpMemoryState infrastructure provided by the
memory module.  The interval between the OpMemoryState object's initialization
and shut-down is this module's <q>life-time</q>; normally, its primary API is
not available except during this life-time, although these rules may be bent if
you know what you're doing (see below).  Please refer to the OpMemoryState
documentation for more information on the initialization and deinitialization of
the memory infrastructure. </p>

<p> On some operating systems (e.g. Linux), the underlying system calls by which
this module obtains memory from the operating system may <q>over commit</q> the
machine's memory.  In such a case, there is normally no way for this module to
abide by ANSI C's specified behaviour for memory allocation when insufficient
memory is available; a call to <code>malloc()</code> may return a non-<code>NULL</code>
pointer to memory which, when actually accessed, turns out to not be available.
This makes OOM-handling impossible.  However, if we only call the underlying
system once, during start-up, to lay claim to all the memory we are ever going
to need, this module can manage that monolithic block of memory without running
into problems with over-commit.  Subsequently this module can correctly report
OOM, when it happens, and Opera can reclaim memory suitably.  Consequently,
projects with a strong need for correct OOM-handling should use single-block
mode (see <code>API_DLM_SINGLE_BLOCK</code> below). </p>

<h2 id="Config">Configuration</h2>

<p> The module is configured via the feature, tweak and API systems in core-2
but by direct use of its own defines in core-1.  Relevant settings (and the
defines they activate when <code>YES</code>): </p><dl>

 <dt>Features:</dt><dd><dl class="setting">

  <dt>FEATURE_3P_LEA_MALLOC (HAVE_DL_MALLOC)</dt><dd> If this is YES, this module's
implementation of <code>malloc</code> is compiled and used by Opera.  Otherwise, all
of the following is irrelevant. </dd>

  <dt>FEATURE_LEA_MALLOC_PREFIX (USE_DL_PREFIX)</dt><dd> If <code>YES</code>, prefix
the primary API function names with <code>dl</code> so that this memory allocation
infrastructure may be used alongside the system one; otherwise, this
implementation supersedes the system one. </dd>

  <dt>FEATURE_LEA_MALLOC_CONSTRAINED (CONSTRAIN_OPERA_MEMORY_USAGE)</dt><dd>
If <code>YES</code>, use the Opera allocator for the whole process and constrain
memory usage by selectively allowing for allocations to fail on OOM depending on
where they originate from. The memory usage is constrained by setting limits on
the heap size and/or the total amount of memory allocated from the constrained
allocation sites. </dd>

 </dl></dd>
 <dt>Tweaks (see <code>module.tweaks</code> for the gory details):</dt><dd><dl>

  <dt>TWEAK_LEA_MALLOC_LOCK (USE_MALLOC_LOCK)</dt><dd><p> Thread-safety support:
protects each call to any primary API function with calls to
<code>OpMemory::MallocLock()</code>/<code>OpMemory::MallocUnlock()</code>
functions (as declared in <code>pi/system/OpMemory.h</code>). This TWEAK will be
replaced by the equivalent from the memory module:
<code>TWEAK_MEMORY_USE_LOCKING</code> (<code>MEMORY_USE_LOCKING</code>).
</p></dd>

  <dt>TWEAK_LEA_MALLOC_PLATFORM_CONFIG (LEA_MALLOC_CONFIG_HEADER)</dt><dd><p>
The underlying <code>malloc</code> implementation provided by Doug Lea has some
further defines with which interested parties might wish to experiment.  Put
settings for these internal defines for the module in a header within your
platform, then tweak <code>LEA_MALLOC_CONFIG_HEADER</code> to be a string naming
that file relative to the Opera root directory (or some other directory in your
compiler's include path); the module shall use a <code>#include</code> of that
file to obtain its config.  This tweak's default,
<code>"modules/lea_malloc/<a href="api/dummy__config_8h.html">dummy_config.h</a>"</code>,
contains documentation for what you may want to set in your platform
configuration.  (If this file contains configuration for your platform, you
should move it out to your own configuration header.) </p></dd>

  <dt>TWEAK_LEA_MALLOC_REENTRANT (MALLOC_BLOCK_SIGNALS)</dt><dd><p> Experimental
re-entrancy prevention.  Needed if any signal handler (in use by any part of the
application, including shared libraries) is liable to call the primary API
functions; otherwise, if such a signal is caught during a call to a primary API
function, the resulting re-entrant call may find preconditions it takes for
granted being violated.  That can lead to very nasty and confusing consequences.
Signal-handlers should not generally call this module's primary API
functions. </p></dd>

</dl></dd>

 <dt>APIs (see module.export):</dt><dd><dl>

  <dt>API_DLM_CHECK (LEA_MALLOC_EXTERN_CHECK)</dt><dd><p> Provides a minimal API
for asking this module to check sanity of its internal state. </p></dd>

  <dt>API_DLM_CONSTRAIN (LEA_MALLOC_API_CONSTRAIN)</dt><dd><p> Support for
limits on the amount of memory we use, adaptable so that only selected parts of
our own code are in danger of suffering OOM, provided <q>fake</q> memory
management functions are used to check for potential OOM before calling other
code (e.g. shared libraries) which shall perform real allocations. </p></dd>

  <dt>API_DLM_FULL_MEMAPI (LEA_MALLOC_FULL_MEMAPI)</dt><dd><p> Include all
functions of the standard memory API, not just the ones used directly by Opera.
This is needed if <code>FEATURE_LEA_MALLOC_PREFIX</code> is off and the binary
loads shared libraries - either via shared linkage or as plugins - which might
conceivably call functions in this full API. </p></dd>

  <dt>API_DLM_SINGLE_BLOCK (LEA_MALLOC_MONOBLOCK)</dt><dd><p> Provides the
SingleBlockHeap class (see <code>lea_monoblock</code>).</p></dd>

 </dl></dd>
</dl>

<p> In builds which rely on dynamically linked (a.k.a. shared) libraries, the
initialization hooks of such libraries are called before <code>main</code> and,
consequently, outside this module's life-time.  It is possible that such hook
functions may call memory allocation functions (c.f. <a
href="https://bugs.opera.com/show_bug.cgi?id=174325">bug #174325</a>).  There
are three ways to prevent that being disastrous, when using this module:
</p><ul>

 <li> turn on <code>FEATURE_LEA_MALLOC_PREFIX</code> (define
<code>USE_DL_PREFIX</code>) and map <code>op_malloc</code> and friends to
(optionally: wrapper functions which call) the suitably-prefixed versions of
this module's primary API functions; libraries will then use the system's
equivalents of this module's API, so you must take care to prevent any mix-up
between memory managed by this module and by the system; </li>

 <li> ensure that Opera is entirely single-threaded (so you must use synchronous
DNS) and use static memory and initialization for this module's state data; this
isn't an option if you use any library which spawns its own threads (at least,
not if those threads are apt to call this module's primary API); </li>

 <li> turn on <code>TWEAK_MEMORY_USE_LOCKING</code>
(<code>MEMORY_USE_LOCKING</code>) (or <code>TWEAK_LEA_MALLOC_LOCK</code>
(<code>USE_MALLOC_LOCK</code>) if the former is not available) to prevent the
threading from causing grief, and implement your own
<code>OpMemory::MallocLock()</code>/<code>OpMemory::MallocUnlock()</code>
functions (as declared in <code>pi/system/OpMemory.h</code>).  Your provided
locking functions must properly handle being called from outside
<code>main()</code>.  Here are two ways of achieving this:<ul>
	<li> Statically initialize the lock, so that the locking functions may
	be readily used outside <code>main()</code>. </li>
	<li> If you can ensure that no <em>simultaneous</em> calls to the
	primary API will happen outside of <code>main()</code>, you may forego
	locking until the lock is initialized, and simply have the locking
	functions return immediate success before the lock is initialized. </li>
</ul>
</ul><p> Note that the second of these is incompatible with Core's policy on
globals (the third might also be, depending on how you choose to implement your
lock). </p>

<h2>Footprint</h2>

<p> There are numerous functions that can be removed from this package to reduce
code size, if only slightly: <code>valloc</code>, <code>pvalloc</code>,
<code>independent_calloc</code>, <code>independent_comalloc</code>, and possibly
some of the tuning functions. </p>

<p> However, we have no way to know which libraries we might load at runtime
that might try to exercise these functions.  If we don't provide all of them,
and a library exercises one we missed, it'll get the system libraries, which can
lead to very mysterious crashers !  However, when using
<code>FEATURE_LEA_MALLOC_PREFIX</code>, this should not be an issue. </p>

<h2>Statement on memory usage and management</h2>

<ul>
 <li> This module allocates almost no memory for itself, but rather allocates
memory from the system on behalf of other modules. Thus, it functions as a layer
of code between Opera's memory management infrastructure (i.e. op_malloc(),
op_free, and friends), and the platform's memory management infrastructure.</li>
 <li> The OOM policy is very simple; if an allocation fails, <code>NULL</code>
is returned, and must be handled appropriately by the caller.</li>
 <li> These is no usage or handling of exceptions (e.g. <code>TRAP/LEAVE</code>)
in this module.</li>
 <li> The module is extremely tunable in how it requests and releases memory
from the underlying platform. Please read the documentation on the various
TWEAKs and APIs offered by the module for more information.</li>
 <li>The selftests provided by this module, features a comprehensive
verification of the module's functionality. However, stress-testing (either in
number of allocations, or in size of allocations) is not done by the selftests
in order to work on as many platforms as possible.</li>
 <li>The long-term goal of the module is to stay as close as possible (both in
behaviour and implementation) to the upstream dlmalloc source. This includes
minimizing the number of Opera-specific hacks done within the module, and
separating any necesarry hacks as much as possible from the original code in
<code>malloc.c</code>.</li>
</ul>

<h2>Implementation overview</h2>

<p> As stated above, the main part of this module is a repackaging of Doug Lea's
<code>malloc</code> implementation. His code is found largely unchanged in
<code>malloc.c</code> and <code><a href="api/malloc_8h.html">malloc.h</a></code>.
Any other code found in this module provides Opera-specific extensions or
workarounds, but in the end, everything centers around Doug Lea's
<code>malloc</code>. </p>

<p> For an overview of how Doug Lea's <code>malloc</code> works, please refer to
<a href="http://gee.cs.oswego.edu/dl/html/malloc.html">this article</a>. Also,
<code>malloc.c</code> is heavily commented with documentation on how the code
works. </p>

<p> Here follows an overview of the Opera-specific extensions and workarounds
provided elsewhere in this module: </p>

<dl>

 <dt>Secondary API for initialization/shutdown/metainformation</dt>
 <dd><p> Found in <code><a href="api/lea__malloc_8h.html">lea_malloc.h</a></code>
and <code>lea_malloc.cpp</code>. Provides the secondary memory API: Code
responsible for initialization, shutdown and (in single-block mode; see below)
interrogating the block and free memory space. </p></dd>

 <dt>Single-block allocation manager</dt>
 <dd><p> Found in <code><a href="api/lea__monoblock_8h.html">lea_monoblock.h</a></code>
and <code>lea_monoblock.cpp</code>. Provides the <code>SingleBlockHeap</code>
class for making a dlmalloc allocator managing a single contiguous block of
memory. See <code>API_DLM_SINGLE_BLOCK</code> for more details. </p></dd>

 <dt>Other extensions and workarounds</dt>
 <dd><p> Most of these are found in <code>malloc_extra.cpp</code>. These include
implementations of C++'s operator <code>new</code> and <code>delete</code>, and
code related to <code>FEATURE_LEA_MALLOC_CONSTRAINED</code>. </p></dd>

</dl>

<address><a href="mailto:eddy@opera.com">Edward Welbourne</a> and
<a href="mailto:johanh@opera.com">Johan Herland</a>
</address>

</body>
</html>
