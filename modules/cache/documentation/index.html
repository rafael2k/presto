<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
          "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<link rel="stylesheet" href="../../coredoc/coredoc.css" />
<title>Module: Cache</title>
</head>

<body>

<h1>Module: Cache</h1>

<h2>About this module</h2>

The Cache module maintains an index of all URLs currently in use by Opera as well as copies of as many of those recently visited as fits in the space allocated on disk or in memory for this purpose.
It also provides access to the documents in the cache, and on the local filesystem.
The cache is partitioned into different "contexts" each which can have its own storage and quota settings.

<h2>Interface overview and API documentation</h2>

<p><a href="api/index.html">API documentation generated by
Doxygen</a> contains all necessary information for the external APIs.</p>

<h2>Architecture And Implementation</h2>
<p>The Cache_Manager class is part of the URL_Manager class from the URL module, and is used as part of the API provided through the URL API and URL_Manager.</p>

<p>Central to the cache is the concept of context, basically a separated cache, persistent or temporary, dedicated to a specific task (a widget, a privacy tab...). Each context is identified by a context ID stored in each URL_Rep object associated with the store. Each context is managed by a <b>Context_Manager</b>, and all the context managers are managed by the <b>Cache_Manager</b> that is included in the <b>URL_Manager</b> class.</p>

<p>Starting with Core 2.5, we introduced a <b>chained cache architecture</b>, that allows Opera to have multiple levels of cache. This is achieved chaining several Context_Managers.</p>

<p>Additionally, the module provides the URLs Cache_Storage API objects for accessing downloaded documents in RAM or disk storage (browser's cache or local disk, persistent or temporary). Other modules also define implementations based on this hierarchy.</p>

<p>For a more detailed explanation, look at the <a href="architecture.html">Architecture And Implementation Documetation</a>.</p>

<h2>Performance improvements</h2>
<p>The development of Core 2.3 was performance driven, with the aim to improve the behavior on mobile phones and devices, because sometimes they disable the cache for performance reasons. The disk activity is greatly reduced, so devices with a slow disk should get a nice boost.</p>
<p>A lot of TWEAKs have been provided to tune the memory / performance ratio, hoping that the default values are a meaningful starting point. </p>
<p>For a more detailed explanation, look at the <a href="performances.html">Performances Improvements</a>.</p>

<h2>Multimedia Cache</h2>
<p>As part of a task intended to improve the bandwidth management for the audio and video tag, a cache tailored to manage multimedia content has been developed.</p>
<p>The key requirement was managing out of order download of huge files, storimg in the cache the segments already downloaded.</p>
<p>For a more detailed explanation, look at the <a href="multimedia.html">Multimedia Cache</a>.</p>

<h2>Advanced view</h2>
<p>A new opera:cache page is now available that lets the user filter the content of the cache, and (with a small support outside of core) also export it. Apart for being a nice feature (with the current settings you could watch a video on YouTube and then export it), it should also be well received by the people that did not like the removal of the extensions from the cache files.</p>
<p>TWEAK_CACHE_ADVANCED_VIEW control this feature.</p>

<h2>Sample usage</h2>
<p>Listed here is a sample usage of the cache which will hopefully aid someone new to the cache to get the big picture.</p>
<p>To reduce a bit the complexity, the description does not consider the <i>chaining</i> functionality.
Just assume that if a level cannot perform an operation (or if the operation is "global enough"), the request will be passed to the next manager</p>
<p>
A URL is requested through <b>g_url_api-&gt;GetURL()</b> which will trickle down via URL_Manager::LocalGetURL() and Cache_Man::GetResolvedURL() 
to <b>Context_Manager::GetResolvedURL()</b>. The context manager will first check if a URL_Rep already exists in the URL_Store by calling 
URL_Store::GetURL_Rep(). If it can be found it means it has either already been requested or was created during start-up because it 
exists in the cache.<br />
If it cannot be found in the URL_Store a new URL_Rep will be created and returned.<br />
No assumptions can be made as to whether the returned URL_Rep has a URL_DataStorage or not.<br />
At this point nothing more is initiated until the resulting URL is later loaded by calling <b>URL:LoadDocument()</b>.
</p>
<p>
LoadDocument() will ask the URL_Rep to create its URL_DataStorage (in this instance because it needed to set an attribute on the storage, 
but it would've been created a bit later anyway before the loading proceeded). After that asynchronous loading is kicked off by a call 
to URL_Rep::Load().
</p> 
<p>
The first time data is received for the URL via the socket it will trickle up via URL_LoadHandler::ProcessReceivedData() to 
<b>URL_DataStorage::ReceiveDataL()</b> that will create the cache storage. The Cache_Storage is allocated in <b>URL_DataStorage::CreateNewCache()</b>, that will create a storage of one of several types (Persistent_Storage, Session_Only_Storage, Multimedia_Storage...).
The received data will be stored in the base class attribute <b>cache_content</b> by calling StoreData() and after that the message 
<b>MSG_URL_DATA_LOADED</b> will be broadcasted. At this point the cache item exists in memory only.
</p> 
<p>
At some later point, either when the URL is no longer used or when a cache write is forced (e.g. <b>Cache_Manager::WriteCacheIndexesL()</b>) 
<b>URL_DataStorage::DumpSourceToDisk()</b> will be called. The cache storage will be flushed and if it is of type File_Storage it will be written 
to disk in one of three ways:
<ul>
<li><i>Embedded into the index file</i></li>
This is done for small files of size no larger than CACHE_SMALL_FILES_SIZE. Cache_Storage::ManageEmbedding() checks if the file is 
"Embeddable" i.e. small enough and persistent, and also makes sure the number of embedded files won't exceed CACHE_SMALL_FILES_LIMIT. The actual 
embedded entry is written in Context_Manager::WriteIndexFileSimpleL()
<li><i>In a Cache_Container</i></li>
This is done for medium sized files (or small files if the embedded limit is exceeded) of size no larger than CACHE_CONTAINERS_FILE_LIMIT. 
There is no maximum limit on the number of containers that can be kept but currently only 5 are resident in memory at any point. Each 
container can hold up to CACHE_CONTAINERS_ENTRIES (usually 8) files. A container only stores files belonging to the same domain.
The actual data is stored in the container in Cache_Storage::StoreInContainer(), called from Cache_Manager::AddCacheItemToContainer().
<li><i>In a file</i></li>
For files larger than CACHE_CONTAINERS_FILE_LIMIT. Cache_Storage::CopyCacheFile() writes the actual data and is called from 
Cache_Storage::SaveToFile().
</ul>
</p> 

<h2>Footprint</h2>

<p>The module is moderately large</p>

<p>Various features can be enabled or disabled, either through feature defines or specific defines, one example is access to files on disk.</p>

<p>Due to the requirements from various modules (including the url module) and platforms it is very difficult to reduce the footprint<p>

<h2>Dynamic memory use and OOM handling</h2>

<dl>
<dt>OOM policies
<dd><p>Most of internal module functions handles OOM locally, and signals an OOM by raising the OOM signal in the memory manager, and aborts the current action. If appropriate a message is posted to the document.</p>
<p>However, much of the public API is now LEAVE based, and in those cases the caller must TRAP errors and handle them. Some internal functions will also LEAVE, but these are TRAPed internally</p>

<dt>Who handles OOM?
<dd>In the case of LEAVE functions the caller must TRAP the errors, and handle the OOM situations. In the case of the internal functions these usually aborts their operation with an error message, and a raised status flag, which must be handled either by the caller, or the document.

<dt>Flow
<dd><p>Some of the module maintainance functions are message callback based, and these functions are not able to report OOM situations directly to the documents or UI. In these cases the current operation will be terminated, and errormessages sent.</p>

<p> Much of the external API is based on direct calls, but some classes do use virtual functions. In many cases these are LEAVE bases, and callers must TRAP them and handle them appropriately.</p>

<dt>Heap memory usage
<dd>

<p>NOTE: these numbers tend to be estimates, not actual measurements </p>

<p>Unloaded URL will usually consume approximately 40 bytes, plus the URL's path segment<p>
<p>Loaded URL_Reps will probably,on average, use 300-400 bytes, depending on the lengh of the URL's name. URL_Reps that uses RAM cache will additionally store the entire document in RAM.

<p>RAM usage for memory cache is kept to a minimum, although in desktop versions 1 MB can be generally used for such caching. In RAM only versions the disk-cache size if used, and on limited memory platforms the memeory use is kept as close to 0 as possible.

<dt>Stack memory usage
<dd><p>Usually, large objects are allocated. In some cases sizeable objects are placed on the stack but only for shorter periods. </p>

<p>In most cases stack consumption should be less than 300 bytes.</p>

<dt>Static memory usage
<dd><p>No global memory is used, except through the URL_Manager.</p>

<dt>Caching and freeing memory
<dd><p>URLs are kept in a list, and memory used by these URLs can be freed by the following g_url_api (URL module calls):</p>

<ul>
	<li>g_url_manager-&gt;FreeUnusedResources: Removal of temporary data used by URLs
	<li>g_url_manager-&gt;EmptyDCache : Removal of all files in the cache, URLs remain if they are in use
	<li>g_url_api-&gt;PurgeData : Complete removal of specified types of data
</ul>

<p>In addition the size of the allocated resources are controlled by the preference: PrefsCollectionNetwork::DiskCacheSize</p>

<dt>Freeing memory on exit
<dd> <p>Memory is freed as part of the URL module's shutdown, when all URLs and independent cache contexts are destroyed.</p>

<dt>Temp buffers
<dd>
<p>A few functions use the g_memory_manager's tempbuffers</p>

<p>There is no check for external use of these buffers, and the use of different buffers should prevent internal collisions, unless implementations also use them in calls to/from these functions.</p> 

<dt>Memory tuning
<dd>

<p>At present there are no opportunities to tune memory use, aside from a couple of tweaks to increase memeory use before flushing to disk.</p>

<dt>Tests
<dd><p>Selftests, but they do not check memory usage.</p>

<dt>Coverage
<dd><p>Selftests, ordinary surfing.</p>

<dt>Design choices
<dd><p>URL_Rep, URL_DataStorage and several other classes are independent objects owned by other objects to reduce the use of unnecesarily large objects.</p>

<dt>Improvements
<dd>
<p>In the future we will probably try to store less of the URLs known to Opera in memory, and move more of it out into a database on disk.</p>
<p>It may be possible to force compression of data in the cache, in particular generated memory-only cache entries.</p>

</dl>
</body>
</html>
