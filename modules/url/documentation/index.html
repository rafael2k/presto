<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" 
          "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<link rel=stylesheet href="../../coredoc/coredoc.css" />
<title>Module: URL</title>
</head>

<body>

<h1>Module: URL</h1>

<h2>About this module</h2>

The URL module performs, among other things the following:

<UL>
<li> All loading of documents referenced by URLs (local or externally stored)
<li> All storage of loaded documents in the cache
<li> All access to locally stored documents
<li> Administrates cookies and their filters
<li> List of visited links, and referenced URLs
<li> Encodes mailmessages and HTTP form upload
<li> Decodes mailmessages
</UL>
<p>
Supported protocols:
<p>
<UL>
<li> <a href="http://www.ietf.org/rfc/rfc2616.txt">HTTP 1.1</a>
<li> <a href="http://www.ietf.org/rfc/rfc959.txt">FTP</a>
<li> <a href="http://wp.netscape.com/newsref/std/cookie_spec.html">Netscape Cookies</a>
<li> <a href="http://www.ietf.org/rfc/rfc2965.txt">RFC 2965</a>
<li> The <a href="http://www.ietf.org/rfc/rfc2396.txt">URL</a> specification
<li> <a href="http://www.ietf.org/rfc/rfc2045.txt">MIME 1</a> <a href="http://www.ietf.org/rfc/rfc2046.txt">2</a>  <a href="http://www.ietf.org/rfc/rfc2047.txt">3</a> <a href="http://www.ietf.org/rfc/rfc2048.txt">4</a>   <a href="http://www.ietf.org/rfc/rfc2049.txt">5</a>
<li> <a href="http://www.ietf.org/rfc/rfc2818.txt">HTTPS</a>/<a href="http://www.ietf.org/rfc/rfc2246.txt">TLS</a>  through the <a href="../../libssl/documentation/index.html">libssl</a> module.
<li> <a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft2">SPDY/2</a> and <a href="http://www.chromium.org/spdy/spdy-protocol/spdy-protocol-draft3">SPDY/3</a>.
</UL>


<h2>Interface overview and API documentation</h2>

<p><a href="api/index.html">API documentation generated by
Doxygen</a> contains all necessary information for the external APIs.</p>

<h3>How to use URLs</h3>

<h4>About URL objects</h4>

<p>URLs are contained in URL objects, and represents the entire documents. All actions 
involving URL are initiated through the URL classes API.

<p>A URL object consists of two pointers, one to a URL_Rep object that contains all the URL informations, and one to a URL_RelRep object (owned by the URL_Rep object) that identifies the  fragment identifier part of the URL (the "#name" part of the URLname). Refernece counters ar updated in these objects each time a new URL object is created or destroyed.</p>

<p>URL objects are primarily created by the <code>g_url_api->GetURL()</code> function call, which 
have several options, such as creating a completely new URL, or a URL referenced relative to an already known URL.</p>

<p>Additionally, URL constructors can be used to create "copies" of URLs (they are not copies, just references), or adding fragment identifiers ("#name").</p>

<p>Documents intending to use or display the data contained by a URL must lock it, using a URL_InUse object, which will prevent destruction of the URL's data while it is being used.</p>

<h4>Unique URLs</h4>

<p>There are two types of URLs, normal URLs, that are always retriveable through the cache and visited URL list, and unique URL that are not accessible through the cache and visited URL list. Unique URLs are primarily used for POST form requests and are created the same way as normal URLs, but with the unique flag set to TRUE, and unlike normal URLs cannot be accessed through new calls to <code>g_url_api->GetURL()</code>, and new references can only be created by creating copies of a URL object. When no document locks a unique URL the cached document is deleted, and when no URL objects references it, the URL_Rep is destroyed.<p>

<h4>Start Loading a URL</h4>

<p>There are several fuctions available to load URLs</p>

<p>The preferred function is URL::LoadDocument, which will perform all necessary cache validation checks before deciding how to load, based on a caller specified policy. The other functions are now deprecated.</p>

<P>To resume a download URL::ResumeLoad is used. this fucntion will, if possible restart the load on the location where the loading was aborted previously.<p>

<p>Additionally, it is possible to create URLs that are created using the URL::WriteDocumentData() functions, but these should be used only in special cases, like email and news decoding.<p>

<h4>URL load progress</h4>

<p>A loading URL can post several messages, which the caller must listen for.<p>

<p>The messages are on the form (msg, par1, par2). par1 is ALWAYS the Id() of the URL posting the message (retrived by URL::Id() ), par2 depends on the message (msg) posted. 

<dl>
<dt>
MSG_HEADER_LOADED
<dd>
The URL has received enough information to know what the document is, the document may now decide what to do with it. par2 is non-zero if the URL has been marked URL::KIsFollowed. This is the first message in a successful load.
<dt>
MSG_URL_DATA_LOADED	
<dd>
This is sent each time more data has been received, as long as the status is URL_LOADING. The last message is sent as the URL changes status to URL_LOADED This message is also sent by data descriptors while there are more data available from the URL and it is no longer loading (The descriptor must be initialized with a message handler). par2 is non-zero if one of the loading clients specified inline loading.
<dt>
MSG_MULTIPART_RELOAD	
<dd>
This message is sent to inform the document that a new header and body for the same URL will be received shortly, and should replace the current display of the document as soon as it arrives. MSG_INLINE_REPLACE is also sent at the same time. The next successful loading message will be MSG_HEADER_LOADED
<dt>
MSG_URL_LOADING_FAILED
<dd>An error occured during load, par2 indicates the error code. The error code ERR_SSL_ERROR_HANDLED, means that the error has already been handled, and that loading should be silently ended.
<dt>
MSG_URL_INLINE_LOADING	
<dd>
Only sent to indicate end of loading, par2 is a HIWORD/LOWORD combination (each 16 bit long) the HIWORD is the load status (URL::KLoadStatus) of the URL, the LOWORD may be an error code. This message will be removed in the near future.

<dt>
MSG_URL_LOADING_DELAYED	
<dd>
Indicates that the URL will take some time to load, and the document should continue as best as it can without the data being retrieved. It is sent if it takes more than 3 seconds to get a response from the server.
<dt>
MSG_URL_MOVED
<dd>
The URL is being redirected to a new location, which is being loaded. the URL::KMovedToURL attribute returns the target URL. par2 is the Id of the redirect target.
</dl>

<h4>Retrieving data from the URL</h4>

<p>The data from a URL are retrived by requesting a URL_DataDescriptor object from the URL by calling URL::GetDescriptor. The data can be retrived in binary raw form,  without content-encoding (in case they are compressed) or in UTF-16 form (converted from the document's original encoding).</p>

<P>Datadescriptors can be message driven (where messages are posted if there are more data), or polling based (where it is the caller's responsibility to retrieve all pending data).</p>

<h4>Retrieving information about the URL</h4>

<p>A number of informations attributes exists inside a URL object, while some of these can be retrieved by dedicated functions,  the primary API for retrieving and updating the attributes are the GetAttribute/GetAttributeL and SetAttribute/SetAttributeL functions.<p>

<p>These functions takes as argument an enumerated value that selects the actual attribute, and either returns the value, or updates it, depending on the function.<p>

<p> The enumerated values are grouped into lists depending on the type of data the corresponding attribute is representeted as: Unsigned integers (including enums and signed integers, which must be typecasted), strings, URLs and general "void" pointers (which must be type casted). Strings can be retrieved both as const strings (with a few exceptions, and be copied into a separate OpString* object<p>

<dl>

<dt> The enums
<dd> The attribute enums are defined as part of the URL class, and are on the form <code>URL::KNameOfAttribute</code> Most of the names are on the same for as the previous function, so <code>GetNameOfAttribute();</code> can be replaced by <code>[(typecast)] GetAttribute(URL::KNameOfAttribute);</code>. The enums are arranged in groups concerning unsigned integers, strings, URLs and arbitrary typed void pointers.

<dt>GetAttribute
<dd>These functions returns the value the selected attribute. Strings are returned as <code>const OpStringC*</code> objects, that may be accessed directly. The results from the version returning <code>unsigned ints</code> must be typecasted to the appropriate type of the attribute before being used. (This approach was chosen to prevent having to created too many implementations of this function). The default return values unless specified otherwise are 0 (for integers), empty string (for string attributes), empty URLs (for the URL attributes) and NULL (for the void pointer attributes). Optionally, these fucntions can follow redirects.

<dt>GetAttributeL
<dd> This function retrieves the value of the selected string attribute, and copies it into the provided string object. In case of OOM and other problems it may LEAVE, but the default return value is an empty string. Some attributes that have a "_L" suffix are ONLY retrievable via this API function. Optionally, these fucntions can follow redirects.

<dt>SetAttributeL
<dd>These functions are used to update the value of the selected attribute. As they may have to construct new objects inside the URL these functions may LEAVE, as they may do if any other allocation needed fails. Note that some attributes cannot be set through this API, and that no failure notice will be given in these cases. These functions ONLY act on the current object.

<dt>SetAttribute
<dd>Use of these functions are not recommended, but are provided to let functions that are not yet able to LEAVE to use the SetAttributeL API without adding an enormous amout of TRAPs in the code. These functions will TRAP any LEAVEs and return them as OP_STATUS values to the caller.

</dl>

<code>
  URL url;<br>
<br>
  URLStatus status1 = (URLStatus) url.GetAttribute(URL::KLoadStatus); // Get the load status of the URL<br>
  URLStatus status2 = (URLStatus) url.GetAttribute(URL::KLoadStatus, TRUE); // Follow the redirect chain and get the load status of the URL at the end of the chain<br>
<br>
  OpStringC8  name1 = url.GetAttribute(URL::KName_Escaped); // Access the %XX escaped name of the URL as a const string<br>
  OpStringC  name2 = url.GetAttribute(URL::KUniNamed); // Access the UTF-8 deescaped name of the URL as a const string<br>
<br>
  OpString8 name3;<br>
  url.GetAttributeL(URL::KName_Escaped, name3); // Retrive the %XX escaped name of the URL and store it in the "name3" string object<br>
<br>
  OpString  name4<br>
  url.GetAttributeL(URL::KUniNamed, name4); // Access the UTF-8 deescaped name of the URL and store it in the "name4" string object<br>
<br>  
<br>
  url.SetAttributeL(URL::KLoadStatus, URL_LOADED); // Set the load status of the URL
<br>
<br>
  url.SetAttrubuteL(URL::KMIME_ForceContentType, "text/plain; charset=iso-8859-1"); // Force the MIME-type (and in this case, charset), of the URL
</code>

<h3>Other API's</h3>

<h4>g_url_api</h4>

<p>g_url_api is primarily used to construct new URLs, but also contain some cookie releated, and some UI action functions.</p>

<h4>ServerName</h4>

<p>ServerName objects contains information about: </p>
<ul>
<li> The server's name
<li> cookie filters
<li> Authentication information
<li> Network IP addresses
<li> Secure session information
</ul>

For each unique servername there will only exist a single ServerName object. the urlManager object maintains the servername database.

URL's contains pointers to ServerName objects and to find out if two URLs are from the same server it suffices to compare the ServerName pointers from the objects.

<h2>Implementation description</h2>

<p><a href="all/index.html">API documentation generated by
Doxygen</a> contains information about the internal organization of the module.</p>

<h3>The URL_Rep class </h3>

<p> General layout of the URL_Rep and related classes (The list is abbreviated):</p>

<dl>
<dt>URL_Name
<dd> The name of the URL (including some flags), split into components
<dt>Flags
<dd>Flags used by all URLs even if they are not loaded
<dt>last_visited
<dd> When was the URL last visited?
<dt>reference count
<dd> Number of URL objects referencing this object
<dt>used
<dd> Number of documents or other customers that have locked access to the data
<dt>storage
<dd> Contains all data relevant to a loaded document, such as what the data is, and the actual data.
  <dl>
  <dt> mh_list
  <dd> The list of documents waiting for the data thsi URL is loading
  <dt> info
  <dd> Flags either specifying information needed to load the document, or the result.
  <dt>local_time_loaded
  <dd> When this this loadoperation start?
  <dt> Content-size
  <dt> Content-Type
  <dt>Charset
  <dt>Secure protocol information
  <dt> loading
  <dd> The object handling the actual load operation
  <dt> storage
  <dd> The object maintaining the actual file or RAM stroage of the loaded document. Some classes also processes and breaks up the document in component pieces.
  <dt> Protocol specific data
  <dd> These structures contains data used by the various protocols (e.g HTTP, MIME, FTP).
  </dl>
</dl>

<h3>URL_Manager</h3>

<p> The URL manager maintains the following</p>
<ul>
<li> All URLs (except unique URLs)
<li> All ServerNames
<li> The cookie database
<li> Authentication 
<li> Cache maintainance,
<li> Connection management
<li> A number of UI actions related to the above list
</ul>

<h3>Footprint</h3>

<p>The module is fairly large, as it requires a lot of functionality. </p>

<p>Various features can be enabled or disabled, either thorugh feature defines or specific defines, one example is the HTTP stack.</p>

<p>Due to the requirements from various modules (including the url module) and platforms it is very difficult to reduce the footprint<p>

<h3>Dynamic memory use and OOM handling</h3>

<dl>
<dt>OOM policies
<dd><p>Most of internal module functions handles OOM locally, and signals an OOM by raising the OOM signal in the memory manager, and aborts the current action. If appropriate a message is posted to the document.</p>
<p>However, much of the public API is now LEAVE based, and in those cases the caller must TRAP errors and handle them. Some internal functions will also LEAVE, but these are TRAPed internally</p>

<dt>Who handles OOM?
<dd><p>In the case of LEAVE functions the caller must TRAP the errors, and handle the OOM situations. In the case of the internal functions these usually aborts their operation with an error message, and a raised status flag, which must be handled either by the caller, or the document.</p>

<dt>Flow
<dd><p>Much of the module is message callback based, and these functions are not able to report OOM situations directly to the documents or UI. In these cases the current operation will be terminated, and errormessages sent.</p>

<p> Much of the external API is based on direct calls, but some classes do use virtual fucntions. In many cases these are LEAVE bases, and callers must TRAP them and handle them appropriately.</p>

<dt>Heap memory usage
<dd>

<p>NOTE: these numbers tend to be estimates, not actual measurements </p>

<p>Unloaded URL will usually consume approximately 40 bytes, plus the URL's path segment<p>
<p>Loaded URL_Reps will probably,on average, use 300-400 bytes, depending on the lengh of the URL's name. URL_Reps that uses RAM cache will additionally store the entire document in RAM.
<p>ServerName objects will usually consume less than 200 bytes per unique servername, but actual consumption depends on servername size, and to what extent authentication and secure session information is used (session information can consume at least 1 KB per port, depending on the certificate and encryption key sizes).<p>
<p> Cookies can consume up to 4 KB per cookie, but should usually average less than 300 bytes.<p>

<p> Sequence splitter and upload elements are usually not kept for long, and their allocated size depends on the number of elements and actual bodysize.

<dt>Stack memory usage
<dd><p>Usually large objects are allocated. In some cases sizeable objects are placed on the stack but only for shorter periods. </p>
<p>In most cases stack consumption should be less than 300 bytes.</p>

<dt>Static memory usage
<dd><p>The module uses several global pointers, and several static members. These are, for the most part pointers:</p>

<ul>
<li> g_url_api
<li> urlManager
<li> http_Manager
<li> ftp_Manager
<li> URL_Name::g_tempurl
<li> URL_Name::g_tempuniurl
<li> URL_Name::g_tempunipath
<li> URL_Name::g_tempurl_len
<li> URL_Name::last_user
<li> URL_Name::last_rel_rep
<li> URL_Name::last_hide
<li> URL_Name::uni_last_user
<li> URL_Name::uni_last_rel_rep
<li> URL_Name::uni_last_hide
</ul>

<p>Several of these are buffers that (alongside buffers in URL_Manager) will grow as longer URLs are encountered.</p>

<p>Most of the allocated objects are dleted by URL_Manager or URL_API on exit</p>

<p>In addition a number of compiled const arrays exists. These may be automatically converted to allocated arrays on some platforms.</p>

<dt>Caching and freeing memory
<dd><p>There are calls to free unused resources on URL_Manager and URLs that can be called when needed by the memory manager.</p>

<p>Additionally, the URL_Manager, either directly or through the Cache_Manager (from the cache module) keeps the number of URL, ServerNames, connections, cookies. etc. within the total number and size limits specified.</p>

<dt>Freeing memory on exit
<dd><p>URL_Manager and URL_API destroys all allocated URLs, connections etc.</p>

<dt>Temp buffers
<dd> URL_Manager and URL_Name maintains several temporary buffers that are used internally.

<p>Additionally, several places use the memory Manager's tempbuffers, primarily TempBuf2 and TempBuf2k</p>

<p>There is no check for external use of these buffers, and the different buffers should prevent internal collisions, unless implementations also use them in calls to/from these functions.</p> 

<dt>Memory tuning
<dd><p>At present there are no opportunities to tune memory use.</p>

<dt>Tests
<dd><p>Selftests, but they do not check memory usage.</p>

<dt>Coverage
<dd><p>Selftests, ordinary surfing.</p>

<dt>Design choices
<dd><p>URL_Rep, URL_DataStorage and several other classes are independent objects owned by other objects to reduce the use of unnecesarily large objects. Common information about scheme/servername/port is stored in a single database linked from the URLs.</p>

<dt>Improvements
<dd><p>Possible improvements</p>

<ul>
<li> Allocating both the URL_Rep object and the strings used by URL_Name in the same block. This could reduce memory fragmentation a little, but make initialization of the object more complex.
<li> It is possible that URL_DataStorage and other structures are getting too large, and that they can benefit from being refactored into functional or protocol spesific classes.
</ul>

</dl>

<h2>See also</h2>
<ul>
<li><a href="useragent.html">User-Agent handling in Opera</a></li>
<li><a href="spdy/index.html">SPDY protocol implementation notes</a></li>
</ul>

</body>
</html>
